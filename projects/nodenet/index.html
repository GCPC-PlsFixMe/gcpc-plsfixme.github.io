<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>IT Infrastructure Network Animation</title>
    <style>
      body {
        font-family: "Inter", sans-serif;
        margin: 0;
        overflow: hidden; /* Prevent scrollbars */
        background-color: #000;
      }
      canvas {
        display: block;
        width: 100%;
        height: 100vh;
      }

      /* Stats Pane Styling */
      #statsPane {
        position: fixed;
        top: 0;
        right: 0;
        width: 320px;
        height: 100vh;
        background: linear-gradient(
          135deg,
          rgba(15, 23, 42, 0.95) 0%,
          rgba(30, 41, 59, 0.95) 100%
        );
        border-left: 2px solid rgba(59, 130, 246, 0.3);
        box-shadow: -4px 0 20px rgba(0, 0, 0, 0.5);
        color: #e2e8f0;
        overflow-y: auto;
        z-index: 1000;
        backdrop-filter: blur(10px);
        font-family: "Consolas", "Courier New", "Monaco", "Lucida Console",
          monospace;
        transform: translateX(0);
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      #statsPane.collapsed {
        transform: translateX(100%);
      }

      #statsPaneToggle {
        position: fixed;
        top: 50%;
        right: 320px;
        transform: translateY(-50%);
        width: 32px;
        height: 80px;
        background: linear-gradient(
          135deg,
          rgba(15, 23, 42, 0.95) 0%,
          rgba(30, 41, 59, 0.95) 100%
        );
        border: 2px solid rgba(59, 130, 246, 0.3);
        border-right: none;
        border-radius: 8px 0 0 8px;
        cursor: pointer;
        z-index: 999;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #60a5fa;
        font-size: 18px;
        backdrop-filter: blur(10px);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: -4px 0 20px rgba(0, 0, 0, 0.3);
      }

      #statsPaneToggle:hover {
        background: linear-gradient(
          135deg,
          rgba(30, 41, 59, 0.95) 0%,
          rgba(51, 65, 85, 0.95) 100%
        );
        color: #93c5fd;
        box-shadow: -4px 0 20px rgba(59, 130, 246, 0.4);
      }

      #statsPane.collapsed ~ #statsPaneToggle {
        right: 0;
        border-right: 2px solid rgba(59, 130, 246, 0.3);
        border-radius: 8px 0 0 8px;
      }

      #statsPane::-webkit-scrollbar {
        width: 8px;
      }

      #statsPane::-webkit-scrollbar-track {
        background: rgba(15, 23, 42, 0.3);
      }

      #statsPane::-webkit-scrollbar-thumb {
        background: rgba(59, 130, 246, 0.5);
        border-radius: 4px;
      }

      #statsPane::-webkit-scrollbar-thumb:hover {
        background: rgba(59, 130, 246, 0.7);
      }

      .stats-header {
        background: linear-gradient(
          135deg,
          rgba(59, 130, 246, 0.2) 0%,
          rgba(147, 51, 234, 0.2) 100%
        );
        border-bottom: 2px solid rgba(59, 130, 246, 0.4);
        padding: 20px 20px 0 20px;
      }

      .stats-title {
        margin: 0 0 16px 0;
        font-size: 20px;
        font-weight: 700;
        color: #60a5fa;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      /* Tab Navigation */
      .tab-navigation {
        display: flex;
        gap: 4px;
        margin-bottom: 0;
      }

      .tab-btn {
        flex: 1;
        padding: 10px 16px;
        background: rgba(15, 23, 42, 0.5);
        border: none;
        border-top: 2px solid transparent;
        border-bottom: 2px solid rgba(71, 85, 105, 0.3);
        color: #94a3b8;
        font-size: 12px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .tab-btn:hover {
        background: rgba(30, 41, 59, 0.7);
        color: #cbd5e1;
      }

      .tab-btn.active {
        background: rgba(59, 130, 246, 0.15);
        border-top-color: #60a5fa;
        border-bottom-color: transparent;
        color: #60a5fa;
      }

      .tab-content {
        display: none;
        animation: fadeIn 0.3s ease;
      }

      .tab-content.active {
        display: block;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      .stats-section {
        padding: 16px 20px;
        border-bottom: 1px solid rgba(71, 85, 105, 0.3);
      }

      .stats-section-title {
        font-size: 14px;
        font-weight: 600;
        color: #94a3b8;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin: 0 0 12px 0;
      }

      .stat-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 6px 0;
        font-size: 13px;
        transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
      }

      .stat-label {
        color: #cbd5e1;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .stat-value {
        font-weight: 600;
        font-size: 14px;
        min-width: 50px;
        text-align: right;
      }

      /* Color coding for different stat types */
      .stat-green {
        color: #16a34a;
        text-shadow: 0 0 8px rgba(22, 163, 74, 0.4);
      }
      .stat-red {
        color: #f87171;
        text-shadow: 0 0 8px rgba(248, 113, 113, 0.4);
      }
      .stat-yellow {
        color: #facc15;
        text-shadow: 0 0 8px rgba(250, 204, 21, 0.4);
      }
      .stat-purple {
        color: #a855f7;
        text-shadow: 0 0 8px rgba(168, 85, 247, 0.4);
      }
      .stat-blue {
        color: #3b82f6;
        text-shadow: 0 0 8px rgba(59, 130, 246, 0.4);
      }
      .stat-sky {
        color: #60a5fa;
        text-shadow: 0 0 8px rgba(96, 165, 250, 0.4);
      }
      .stat-darkred {
        color: #dc2626;
        text-shadow: 0 0 8px rgba(220, 38, 38, 0.4);
      }
      .stat-neongreen {
        color: #39ff14;
        text-shadow: 0 0 8px rgba(57, 255, 20, 0.4);
      }
      .stat-white {
        color: #ffffff;
        text-shadow: 0 0 8px rgba(255, 255, 255, 0.4);
      }
      .stat-gold {
        color: #fbbf24;
        text-shadow: 0 0 8px rgba(251, 191, 36, 0.4);
      }

      /* Event Logs Section */
      #eventLogs {
        min-height: 50vh;
        padding: 16px 20px;
        font-size: 12px;
        color: #94a3b8;
      }

      #eventLogs .logs-title {
        font-size: 14px;
        font-weight: 600;
        color: #94a3b8;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin: 0 0 12px 0;
      }

      .log-section {
        margin-bottom: 16px;
      }

      .log-section-header {
        font-size: 11px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-bottom: 6px;
        padding: 4px 8px;
        border-radius: 3px;
        display: inline-block;
      }

      .log-section-header.critical {
        background: rgba(220, 38, 38, 0.2);
        color: #fca5a5;
      }
      .log-section-header.attack {
        background: rgba(239, 68, 68, 0.2);
        color: #fca5a5;
      }
      .log-section-header.defense {
        background: rgba(139, 92, 246, 0.2);
        color: #c4b5fd;
      }
      .log-section-header.success {
        background: rgba(16, 185, 129, 0.2);
        color: #6ee7b7;
      }
      .log-section-header.warning {
        background: rgba(245, 158, 11, 0.2);
        color: #fcd34d;
      }
      .log-section-header.info {
        background: rgba(59, 130, 246, 0.2);
        color: #93c5fd;
      }

      .log-entries-container {
        max-height: 200px;
        overflow-y: auto;
        overflow-x: hidden;
      }

      .log-entries-container::-webkit-scrollbar {
        width: 4px;
      }

      .log-entries-container::-webkit-scrollbar-track {
        background: rgba(15, 23, 42, 0.3);
      }

      .log-entries-container::-webkit-scrollbar-thumb {
        background: rgba(59, 130, 246, 0.3);
        border-radius: 2px;
      }

      .log-entry {
        padding: 6px 8px;
        margin: 3px 0;
        background: rgba(15, 23, 42, 0.5);
        border-left: 3px solid;
        border-radius: 3px;
        font-size: 10px;
        line-height: 1.4;
        animation: slideIn 0.4s ease-out;
        opacity: 0.9;
        word-wrap: break-word;
      }

      .log-entry:hover {
        opacity: 1;
        background: rgba(15, 23, 42, 0.7);
      }

      @keyframes slideIn {
        from {
          transform: translateY(-10px);
          opacity: 0;
          max-height: 0;
        }
        to {
          transform: translateY(0);
          opacity: 0.9;
          max-height: 100px;
        }
      }

      .log-timestamp {
        color: #64748b;
        font-size: 10px;
        margin-right: 8px;
      }

      .log-critical {
        border-left-color: #dc2626;
      }
      .log-warning {
        border-left-color: #f59e0b;
      }
      .log-success {
        border-left-color: #10b981;
      }
      .log-info {
        border-left-color: #3b82f6;
      }
      .log-defense {
        border-left-color: #8b5cf6;
      }
      .log-attack {
        border-left-color: #ef4444;
      }

      /* Interactive Control Panel */
      #controlPanel {
        padding: 16px 20px;
      }

      .control-panel-title {
        font-size: 13px;
        font-weight: 600;
        color: #94a3b8;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin: 0 0 12px 0;
      }

      .tool-buttons {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .tool-btn {
        flex: 1;
        min-width: 50px;
        padding: 10px 8px;
        background: rgba(30, 41, 59, 0.8);
        border: 2px solid rgba(71, 85, 105, 0.5);
        border-radius: 6px;
        color: #cbd5e1;
        font-size: 20px;
        cursor: pointer;
        transition: all 0.3s ease;
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 4px;
      }

      .tool-btn:hover {
        background: rgba(51, 65, 85, 0.9);
        border-color: rgba(59, 130, 246, 0.6);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
      }

      .tool-btn.active {
        background: rgba(59, 130, 246, 0.2);
        border-color: #3b82f6;
        box-shadow: 0 0 20px rgba(59, 130, 246, 0.5),
          inset 0 0 20px rgba(59, 130, 246, 0.2);
        color: #60a5fa;
      }

      .tool-btn-label {
        font-size: 9px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        opacity: 0.8;
      }

      /* Simulation Controls */
      .sim-controls {
        margin-top: 24px;
        padding: 24px 20px 0 20px;
        border-top: 2px solid rgba(59, 130, 246, 0.2);
      }

      .slider-control {
        margin-bottom: 20px;
      }

      .slider-label {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
        font-size: 12px;
        color: #94a3b8;
      }

      .slider-name {
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .slider-value {
        color: #60a5fa;
        font-weight: 700;
        font-size: 13px;
        min-width: 50px;
        text-align: right;
      }

      .slider {
        -webkit-appearance: none;
        appearance: none;
        width: 92%;
        height: 6px;
        border-radius: 3px;
        background: linear-gradient(
          to right,
          rgba(59, 130, 246, 0.3),
          rgba(59, 130, 246, 0.6)
        );
        outline: none;
        transition: opacity 0.2s;
      }

      .slider:hover {
        opacity: 1;
      }

      .slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: linear-gradient(135deg, #3b82f6 0%, #60a5fa 100%);
        cursor: pointer;
        box-shadow: 0 2px 8px rgba(59, 130, 246, 0.5);
        transition: all 0.2s ease;
      }

      .slider::-webkit-slider-thumb:hover {
        transform: scale(1.2);
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.8);
      }

      .slider::-moz-range-thumb {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: linear-gradient(135deg, #3b82f6 0%, #60a5fa 100%);
        cursor: pointer;
        border: none;
        box-shadow: 0 2px 8px rgba(59, 130, 246, 0.5);
        transition: all 0.2s ease;
      }

      .slider::-moz-range-thumb:hover {
        transform: scale(1.2);
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.8);
      }

      .reset-btn {
        width: 100%;
        padding: 10px 16px;
        margin-top: 16px;
        background: rgba(30, 41, 59, 0.8);
        border: 2px solid rgba(71, 85, 105, 0.5);
        border-radius: 6px;
        color: #cbd5e1;
        font-size: 12px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .reset-btn:hover {
        background: rgba(51, 65, 85, 0.9);
        border-color: rgba(59, 130, 246, 0.6);
        color: #60a5fa;
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
      }

      .reset-btn:active {
        transform: translateY(0);
        box-shadow: 0 2px 6px rgba(59, 130, 246, 0.4);
      }

      /* Zoom Controls */
      #zoomControls {
        position: fixed;
        bottom: 20px;
        left: 20px;
        background: rgba(15, 23, 42, 0.9);
        border: 1px solid rgba(56, 189, 248, 0.3);
        border-radius: 12px;
        padding: 12px 16px;
        color: #e2e8f0;
        font-family: "Inter", sans-serif;
        font-size: 13px;
        backdrop-filter: blur(8px);
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
        z-index: 1000;
        display: flex;
        flex-direction: column;
        gap: 8px;
        min-width: 180px;
      }

      .zoom-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }

      .zoom-label {
        color: #94a3b8;
        font-weight: 500;
      }

      #zoomValue {
        color: #38bdf8;
        font-family: monospace;
        font-weight: bold;
        min-width: 36px;
        text-align: right;
      }

      #zoomSlider {
        flex-grow: 1;
        height: 4px;
        background: #334155;
        border-radius: 2px;
        appearance: none;
        outline: none;
      }

      #zoomSlider::-webkit-slider-thumb {
        appearance: none;
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: #38bdf8;
        cursor: pointer;
        border: 2px solid #0f172a;
        box-shadow: 0 0 5px rgba(56, 189, 248, 0.5);
      }

      .checkbox-label {
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
        user-select: none;
      }

      .checkbox-label input[type="checkbox"] {
        accent-color: #38bdf8;
        width: 14px;
        height: 14px;
        cursor: pointer;
      }

      /* News Ticker Styling */
      #newsTicker {
        position: fixed;
        top: 0;
        left: 0;
        right: 0; /* Default: full width (panel closed) */
        height: 32px;
        background: rgba(15, 23, 42, 0.95);
        border-bottom: 1px solid rgba(59, 130, 246, 0.3);
        z-index: 900; /* Below stats pane (1000) */
        display: flex;
        align-items: center;
        overflow: hidden;
        white-space: nowrap;
        backdrop-filter: blur(5px);
        font-family: "Consolas", "Courier New", monospace;
        font-size: 12px;
        transition: right 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        pointer-events: none; /* Let clicks pass through if needed, though it's at the top */
      }

      #newsTicker.sidebar-open {
        right: 320px; /* Adjust for open sidepanel */
      }

      .ticker-item {
        position: absolute;
        white-space: nowrap;
        will-change: transform;
        color: #cbd5e1;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 8px;
        opacity: 0; /* Start hidden until positioned */
        animation: fadeInTicker 0.3s forwards;
      }

      @keyframes fadeInTicker {
        to {
          opacity: 1;
        }
      }

      .ticker-label {
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 10px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        font-weight: 700;
      }

      .ticker-critical .ticker-label {
        background: rgba(220, 38, 38, 0.3);
        color: #fca5a5;
        border: 1px solid rgba(220, 38, 38, 0.5);
      }
      .ticker-warning .ticker-label {
        background: rgba(245, 158, 11, 0.3);
        color: #fcd34d;
        border: 1px solid rgba(245, 158, 11, 0.5);
      }
      .ticker-attack .ticker-label {
        background: rgba(239, 68, 68, 0.2);
        color: #fca5a5;
        border: 1px solid rgba(239, 68, 68, 0.4);
      }
      .ticker-defense .ticker-label {
        background: rgba(139, 92, 246, 0.2);
        color: #c4b5fd;
        border: 1px solid rgba(139, 92, 246, 0.4);
      }
      .ticker-success .ticker-label {
        background: rgba(16, 185, 129, 0.2);
        color: #6ee7b7;
        border: 1px solid rgba(16, 185, 129, 0.4);
      }
      .ticker-info .ticker-label {
        background: rgba(59, 130, 246, 0.2);
        color: #93c5fd;
        border: 1px solid rgba(59, 130, 246, 0.4);
      }
      .ticker-stat .ticker-label {
        background: rgba(15, 23, 42, 0.6);
        color: #94a3b8;
        border: 1px solid rgba(148, 163, 184, 0.3);
      }

      .ticker-msg {
        text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
      }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
  </head>
  <body>
    <!-- News Ticker -->
    <div id="newsTicker"></div>

    <canvas id="networkCanvas"></canvas>

    <!-- Stats Pane -->
    <div id="statsPane" class="collapsed">
      <div class="stats-header">
        <h1 class="stats-title">üìä NodeNet NOC</h1>
        <div class="tab-navigation">
          <button class="tab-btn active" data-tab="stats">üìä Stats</button>
          <button class="tab-btn" data-tab="logs">üìã Logs</button>
          <button class="tab-btn" data-tab="tools">üõ†Ô∏è Tools</button>
        </div>
      </div>

      <!-- Stats Tab Content -->
      <div id="tab-stats" class="tab-content active">
        <!-- Node Counts -->
        <div class="stats-section">
          <h3 class="stats-section-title">üñ•Ô∏è Node Status</h3>
          <div class="stat-item">
            <span class="stat-label">Total Nodes</span>
            <span class="stat-value stat-blue" id="stat-totalNodes">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">‚úÖ Healthy</span>
            <span class="stat-value stat-green" id="stat-healthyNodes">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">‚ö†Ô∏è Warning/Down</span>
            <span class="stat-value stat-red" id="stat-downNodes">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">‚ò£Ô∏è Malware</span>
            <span class="stat-value stat-purple" id="stat-malwareNodes">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">ü§ñ Botnet</span>
            <span class="stat-value stat-darkred" id="stat-botnetNodes">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">‚ò†Ô∏è Command & Control</span>
            <span class="stat-value stat-darkred" id="stat-ccNodes">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">üåü Guardian</span>
            <span class="stat-value stat-sky" id="stat-guardianNodes">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">üõ°Ô∏è Firewall</span>
            <span class="stat-value stat-neongreen" id="stat-firewallNodes"
              >0</span
            >
          </div>
          <div class="stat-item">
            <span class="stat-label">üì° Ground Stations</span>
            <span class="stat-value stat-sky" id="stat-groundStations">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">üõ∞Ô∏è Satellites</span>
            <span class="stat-value stat-sky" id="stat-satellites">0</span>
          </div>
        </div>

        <!-- Attack/Defense Statistics -->
        <div class="stats-section">
          <h3 class="stats-section-title">‚öîÔ∏è Combat Statistics</h3>
          <div class="stat-item">
            <span class="stat-label">‚öîÔ∏è Total Attacks</span>
            <span class="stat-value stat-red" id="stat-totalAttacks">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">üõ°Ô∏è Total Defenses</span>
            <span class="stat-value stat-green" id="stat-totalDefenses">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">‚ò£Ô∏è Total Infections</span>
            <span class="stat-value stat-purple" id="stat-totalInfections"
              >0</span
            >
          </div>
          <div class="stat-item">
            <span class="stat-label">‚ú® Total Recoveries</span>
            <span class="stat-value stat-green" id="stat-totalRecoveries"
              >0</span
            >
          </div>
          <div class="stat-item">
            <span class="stat-label">üíÄ Ping Deaths</span>
            <span class="stat-value stat-darkred" id="stat-pingDeaths">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">üé£ Phish Success</span>
            <span class="stat-value stat-yellow" id="stat-phishSuccess">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">üö® Total DDOS Attacks</span>
            <span class="stat-value stat-darkred" id="stat-totalDDOSAttacks"
              >0</span
            >
          </div>
        </div>

        <!-- Packet Counts -->
        <div class="stats-section">
          <h3 class="stats-section-title">üì¶ Packet Counts</h3>
          <div class="stat-item">
            <span class="stat-label">üìä Data Packets</span>
            <span class="stat-value stat-blue" id="stat-dataPackets">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">üéõÔ∏è Control Packets</span>
            <span class="stat-value stat-green" id="stat-controlPackets"
              >0</span
            >
          </div>
          <div class="stat-item">
            <span class="stat-label">üîí Security Packets</span>
            <span class="stat-value stat-gold" id="stat-securityPackets"
              >0</span
            >
          </div>
          <div class="stat-item">
            <span class="stat-label">üõ°Ô∏è Immunity Packets</span>
            <span class="stat-value stat-white" id="stat-immunityPackets"
              >0</span
            >
          </div>
          <div class="stat-item">
            <span class="stat-label">üíÄ Ping of Death</span>
            <span class="stat-value stat-darkred" id="stat-pingPackets">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">üé£ Phishing Packets</span>
            <span class="stat-value stat-yellow" id="stat-phishPackets">0</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">üöÄ Dispatch Packets</span>
            <span class="stat-value stat-gold" id="stat-dispatchPackets"
              >0</span
            >
          </div>
          <div class="stat-item">
            <span class="stat-label">‚úÖ Packets Received</span>
            <span class="stat-value stat-green" id="stat-packetsReceived"
              >0</span
            >
          </div>
          <div class="stat-item">
            <span class="stat-label">‚ùå Packets Dropped</span>
            <span class="stat-value stat-red" id="stat-packetsDropped">0</span>
          </div>
        </div>
      </div>

      <!-- Logs Tab Content -->
      <div id="tab-logs" class="tab-content">
        <!-- Event Logs Section -->
        <div id="eventLogs">
          <h3 class="logs-title">üìã Event Logs</h3>

          <div
            class="log-section"
            id="log-section-critical"
            style="display: none"
          >
            <div class="log-section-header critical">üö® Critical</div>
            <div class="log-entries-container" id="logs-critical"></div>
          </div>

          <div
            class="log-section"
            id="log-section-attack"
            style="display: none"
          >
            <div class="log-section-header attack">‚öîÔ∏è Attacks</div>
            <div class="log-entries-container" id="logs-attack"></div>
          </div>

          <div
            class="log-section"
            id="log-section-defense"
            style="display: none"
          >
            <div class="log-section-header defense">üõ°Ô∏è Defense</div>
            <div class="log-entries-container" id="logs-defense"></div>
          </div>

          <div
            class="log-section"
            id="log-section-success"
            style="display: none"
          >
            <div class="log-section-header success">‚úÖ Success</div>
            <div class="log-entries-container" id="logs-success"></div>
          </div>

          <div
            class="log-section"
            id="log-section-warning"
            style="display: none"
          >
            <div class="log-section-header warning">‚ö†Ô∏è Warnings</div>
            <div class="log-entries-container" id="logs-warning"></div>
          </div>

          <div class="log-section" id="log-section-info" style="display: none">
            <div class="log-section-header info">‚ÑπÔ∏è Info</div>
            <div class="log-entries-container" id="logs-info"></div>
          </div>
        </div>
      </div>

      <!-- Tools Tab Content -->
      <div id="tab-tools" class="tab-content">
        <!-- Interactive Control Panel -->
        <div id="controlPanel">
          <h3 class="control-panel-title">üõ†Ô∏è Interactive Tools</h3>
          <div class="tool-buttons">
            <button class="tool-btn" data-tool="sprout" title="Sprout Node">
              <span>üå±</span>
              <span class="tool-btn-label">Sprout</span>
            </button>
            <button class="tool-btn" data-tool="prune" title="Prune Node">
              <span>‚úÇÔ∏è</span>
              <span class="tool-btn-label">Prune</span>
            </button>
            <button class="tool-btn" data-tool="infect" title="Infect Node">
              <span>‚ò£Ô∏è</span>
              <span class="tool-btn-label">Infect</span>
            </button>
            <button class="tool-btn" data-tool="cure" title="Cure Node">
              <span>üíä</span>
              <span class="tool-btn-label">Cure</span>
            </button>
            <button class="tool-btn" data-tool="harden" title="Harden Node">
              <span>üõ°Ô∏è</span>
              <span class="tool-btn-label">Harden</span>
            </button>
            <button class="tool-btn" data-tool="link" title="Link Nodes">
              <span>üîó</span>
              <span class="tool-btn-label">Link</span>
            </button>
            <button class="tool-btn" data-tool="drag" title="Drag Node">
              <span>‚úã</span>
              <span class="tool-btn-label">Drag</span>
            </button>
          </div>
        </div>

        <!-- Simulation Controls -->
        <div class="sim-controls">
          <h2 class="control-panel-title">‚öôÔ∏è Simulation Controls</h2>

          <div class="slider-control">
            <div class="slider-label">
              <span class="slider-name">Simulation Speed</span>
              <span class="slider-value" id="simSpeed-value">1.0x</span>
            </div>
            <input
              type="range"
              min="10"
              max="200"
              value="100"
              class="slider"
              id="simSpeed"
            />
          </div>

          <div class="slider-control">
            <div class="slider-label">
              <span class="slider-name">Packet Speed</span>
              <span class="slider-value" id="packetSpeed-value">1.0x</span>
            </div>
            <input
              type="range"
              min="25"
              max="300"
              value="100"
              class="slider"
              id="packetSpeed"
            />
          </div>

          <div class="slider-control">
            <div class="slider-label">
              <span class="slider-name">Attack Frequency</span>
              <span class="slider-value" id="attackFreq-value">1.0x</span>
            </div>
            <input
              type="range"
              min="10"
              max="300"
              value="100"
              class="slider"
              id="attackFreq"
            />
          </div>

          <div class="slider-control">
            <div class="slider-label">
              <span class="slider-name">Healing Speed</span>
              <span class="slider-value" id="healSpeed-value">1.0x</span>
            </div>
            <input
              type="range"
              min="25"
              max="400"
              value="100"
              class="slider"
              id="healSpeed"
            />
          </div>

          <div class="slider-control">
            <div class="slider-label">
              <span class="slider-name">Central Branches</span>
              <span class="slider-value" id="branchCount-value">6</span>
            </div>
            <input
              type="range"
              min="3"
              max="12"
              value="6"
              class="slider"
              id="branchCount"
            />
          </div>

          <button class="reset-btn" id="resetSliders">
            üîÑ Reset to Defaults
          </button>
        </div>
      </div>
    </div>

    <!-- Stats Pane Toggle Button -->
    <div id="statsPaneToggle" title="Toggle Stats Panel" class="collapsed">
      <span id="toggleIcon">¬´</span>
    </div>

    <!-- Zoom Controls (Bottom Left) -->
    <div id="zoomControls">
      <div class="zoom-row">
        <label class="zoom-label">Zoom</label>
        <input
          type="range"
          min="0.1"
          max="2.0"
          step="0.01"
          value="1.0"
          id="zoomSlider"
        />
        <span id="zoomValue">1.0x</span>
      </div>
      <div class="zoom-row">
        <label class="checkbox-label">
          <input type="checkbox" id="autoZoomCheckbox" checked />
          Auto Zoom
        </label>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("networkCanvas");
      const ctx = canvas.getContext("2d");

      let nodes = [];
      let edges = [];
      let isDragging = false;
      let draggedNode = null;
      let dispatchPackets = [];
      let pulses = [];
      let particles = []; // To store "pop" particles
      let dataPackets = []; // To store data flow packets
      let immunityPackets = []; // To store white immunity packets
      let pingOfDeathPackets = []; // To store C&C ping of death packets
      let phishPackets = []; // To store C&C phishing packets
      let counterStrikePackets = []; // To store guardian counter-strike packets
      let galaxyStars = [];
      let galaxyNebulae = [];
      let galaxyComets = [];
      let galaxyNovas = [];
      let galaxyCometExplosions = [];
      let centralImpactShake = 0;
      let centralImpactShakePhase = 0;
      let centralImpactShakeOffsetX = 0;
      let centralImpactShakeOffsetY = 0;
      // Bot Defense Mode configuration
      const BOT_DEFENSE_DURATION = 10000; // 10s active
      const BOT_DEFENSE_COOLDOWN = 20000; // 20s cooldown
      const BOT_DEFENSE_BURST_INTERVAL = 4000; // burst every 4s
      let gradientOffset = 0;
      const padding = 10; // Padding from the border (reduced 75%)
      let lastCrossingCheck = 0; // Throttles the line crossing check

      // Ticker System
      const TickerSystem = {
        container: null,
        queue: [],
        activeItems: [],
        speed: 1.0, // Pixels per frame
        lastStatTime: 0,
        STAT_INTERVAL: 5000, // Show a stat every 5 seconds if quiet

        init() {
          this.container = document.getElementById("newsTicker");
          // Initial welcome message
          this.add(
            "NodeNet Visualization System Online - Monitoring Network Traffic...",
            "info"
          );
        },

        add(text, type = "info") {
          // Prevent queue flooding - keep only the most recent 3 items
          if (this.queue.length >= 3) {
            this.queue.shift();
          }
          this.queue.push({ text, type });
        },

        update() {
          if (!this.container) return;

          // Move existing items
          for (let i = this.activeItems.length - 1; i >= 0; i--) {
            const item = this.activeItems[i];
            item.x -= this.speed;
            item.el.style.transform = `translateX(${item.x}px)`;

            // Remove if off-screen (left)
            if (item.x + item.width < -50) {
              item.el.remove();
              this.activeItems.splice(i, 1);
            }
          }

          // Check if we need to spawn a new item
          const lastItem = this.activeItems[this.activeItems.length - 1];
          const containerWidth = this.container.clientWidth;

          // Determine where the right edge of the last item is
          // If no items, right edge is effectively negative infinity (spawn immediately)
          // But we want to spawn at the right edge of the container
          const rightEdgeOfLastItem = lastItem
            ? lastItem.x + lastItem.width
            : -1000;

          // Gap between items
          const gap = 50;

          // If the last item has moved far enough left to leave a gap...
          if (rightEdgeOfLastItem < containerWidth - gap) {
            // Try to get next item from queue
            let nextData = this.queue.shift();

            // If queue is empty, check if we should show a random stat
            if (
              !nextData &&
              Date.now() - this.lastStatTime > this.STAT_INTERVAL
            ) {
              nextData = this.getRandomStat();
              this.lastStatTime = Date.now();
            }

            if (nextData) {
              this.spawn(nextData);
            }
          }
        },

        spawn(data) {
          const el = document.createElement("div");
          el.className = `ticker-item ticker-${data.type}`;

          // Icon mapping
          let icon = "‚ÑπÔ∏è";
          if (data.type === "critical") icon = "üö®";
          else if (data.type === "warning") icon = "‚ö†Ô∏è";
          else if (data.type === "attack") icon = "‚öîÔ∏è";
          else if (data.type === "defense") icon = "üõ°Ô∏è";
          else if (data.type === "success") icon = "‚úÖ";
          else if (data.type === "stat") icon = "üìä";

          el.innerHTML = `
            <span class="ticker-label">${icon} ${data.type.toUpperCase()}</span>
            <span class="ticker-msg">${data.text}</span>
          `;

          this.container.appendChild(el);

          // Measure width
          const width = el.offsetWidth;
          const startX = this.container.clientWidth;

          // Position initially
          el.style.transform = `translateX(${startX}px)`;

          this.activeItems.push({
            el,
            x: startX,
            width,
            type: data.type,
          });
        },

        getRandomStat() {
          const statTypes = [
            {
              label: "Active Nodes",
              val: nodes.filter((n) => n.state === "alive").length,
            },
            {
              label: "Data Packets",
              val: formatStatNumber(stats.totalDataPackets),
            },
            {
              label: "Threats Blocked",
              val: formatStatNumber(stats.totalDefenses),
            },
            {
              label: "Network Load",
              val: `${dataPackets.length + immunityPackets.length} pkts`,
            },
            {
              label: "Infection Rate",
              val: `${(
                (nodes.filter(
                  (n) => n.status === "malware" || n.status === "botnet"
                ).length /
                  Math.max(1, nodes.length)) *
                100
              ).toFixed(1)}%`,
            },
            {
              label: "Uptime",
              val: `${((Date.now() - lastBackgroundTime) / 1000).toFixed(0)}s`,
            },
          ];
          const randomStat =
            statTypes[Math.floor(Math.random() * statTypes.length)];
          return {
            text: `${randomStat.label}: ${randomStat.val}`,
            type: "stat",
          };
        },
      };

      // Global View State for Dynamic Zooming
      const viewState = {
        scale: 1.0,
        targetScale: 1.0,
        offsetX: 0,
        offsetY: 0,
        minScale: 0.1,
        maxScale: 1.5,
        sidePanelWidth: 320,
        isSidePanelOpen: false,
        maxNetworkRadius: 0, // Track the size of the main network
        isAutoZoom: true, // Toggle for auto-scaling
      };

      // Galaxy background state (populated on startup and resize)
      const GALAXY_STAR_COUNT = 480;
      const GALAXY_NEBULA_COUNT = 5;
      const GALAXY_COMET_CAP = 2;
      let lastBackgroundTime = Date.now();
      let lastNovaSpawn = 0;

      // Simulation speed multipliers (controlled by sliders)
      let simSpeedMultiplier = 1.0;
      let packetSpeedMultiplier = 1.0;
      let attackFreqMultiplier = 1.0;
      let healSpeedMultiplier = 1.0;
      const DEFAULT_BRANCH_COUNT = 6;
      let desiredBranchCount = DEFAULT_BRANCH_COUNT;

      // Statistics tracking object
      const stats = {
        // Packet counts (cumulative)
        totalDataPackets: 0,
        totalControlPackets: 0,
        totalSecurityPackets: 0,
        totalImmunityPackets: 0,
        totalPingPackets: 0,
        totalPhishPackets: 0,
        totalDispatchPackets: 0,
        // Packet delivery stats
        packetsReceived: 0,
        packetsDropped: 0,
        // Combat stats
        totalAttacks: 0,
        totalDefenses: 0,
        totalInfections: 0,
        totalRecoveries: 0,
        pingDeaths: 0,
        phishSuccess: 0,
        // DDOS stats
        totalDDOSAttacks: 0,
        activeDDOSAttacks: 0,
      };

      // Stats increment functions
      function incrementStat(statName) {
        if (stats.hasOwnProperty(statName)) {
          stats[statName]++;
        }
      }

      // Format large numbers for display
      function formatStatNumber(value) {
        if (value > 999999) {
          return (value / 1000000).toFixed(2) + "M";
        }
        return value.toLocaleString();
      }

      // Sort stat items within a section by their values (highest first)
      function sortStatsInSection(sectionElement, pinFirstItem = false) {
        const statItems = Array.from(
          sectionElement.querySelectorAll(".stat-item")
        );
        if (statItems.length === 0) return;

        // Get items to sort (exclude first if pinned)
        const itemsToSort = pinFirstItem ? statItems.slice(1) : statItems;
        const pinnedItem = pinFirstItem ? statItems[0] : null;

        // Extract values and sort
        const itemsWithValues = itemsToSort.map((item) => {
          const valueElement = item.querySelector(".stat-value");
          const valueText = valueElement.textContent;

          // Parse value (handle 'M' suffix for millions)
          let numericValue = 0;
          if (valueText.includes("M")) {
            numericValue = parseFloat(valueText.replace("M", "")) * 1000000;
          } else {
            numericValue = parseFloat(valueText.replace(/,/g, "")) || 0;
          }

          return { element: item, value: numericValue };
        });

        // Sort by value descending
        itemsWithValues.sort((a, b) => b.value - a.value);

        // Reorder DOM elements smoothly
        const fragment = document.createDocumentFragment();
        if (pinnedItem) {
          fragment.appendChild(pinnedItem);
        }
        itemsWithValues.forEach((item) => {
          fragment.appendChild(item.element);
        });

        // Clear and re-append in sorted order
        sectionElement
          .querySelectorAll(".stat-item")
          .forEach((item) => item.remove());
        sectionElement.appendChild(fragment);
      }

      // Update stats display in HUD
      function updateStatsDisplay() {
        // Packet counts (cumulative totals with formatting)
        document.getElementById("stat-dataPackets").textContent =
          formatStatNumber(stats.totalDataPackets);
        document.getElementById("stat-controlPackets").textContent =
          formatStatNumber(stats.totalControlPackets);
        document.getElementById("stat-securityPackets").textContent =
          formatStatNumber(stats.totalSecurityPackets);
        document.getElementById("stat-immunityPackets").textContent =
          formatStatNumber(stats.totalImmunityPackets);
        document.getElementById("stat-pingPackets").textContent =
          formatStatNumber(stats.totalPingPackets);
        document.getElementById("stat-phishPackets").textContent =
          formatStatNumber(stats.totalPhishPackets);
        document.getElementById("stat-dispatchPackets").textContent =
          formatStatNumber(stats.totalDispatchPackets);
        document.getElementById("stat-packetsReceived").textContent =
          formatStatNumber(stats.packetsReceived);
        document.getElementById("stat-packetsDropped").textContent =
          formatStatNumber(stats.packetsDropped);

        // Node counts (filter by status and type)
        const aliveNodes = nodes.filter((n) => n.state === "alive");
        const totalNodes = aliveNodes.length;
        const healthyNodes = aliveNodes.filter(
          (n) => n.status === "green" || n.status === "blue"
        ).length;
        const downNodes = aliveNodes.filter(
          (n) => n.status === "red" || n.status === "yellow"
        ).length;
        const malwareNodes = aliveNodes.filter(
          (n) => n.status === "malware"
        ).length;
        const botnetNodes = aliveNodes.filter(
          (n) => n.status === "botnet"
        ).length;
        const ccNodes = aliveNodes.filter(
          (n) => n.status === "commandControl"
        ).length;
        const guardianNodes = aliveNodes.filter((n) => n.isGuardian).length;
        const firewallNodes = aliveNodes.filter((n) => n.hasFirewall).length;
        const groundStations = aliveNodes.filter(
          (n) => n.isGroundStation
        ).length;
        const satellites = aliveNodes.filter((n) => n.isSatellite).length;

        document.getElementById("stat-totalNodes").textContent = totalNodes;
        document.getElementById("stat-healthyNodes").textContent = healthyNodes;
        document.getElementById("stat-downNodes").textContent = downNodes;
        document.getElementById("stat-malwareNodes").textContent = malwareNodes;
        document.getElementById("stat-botnetNodes").textContent = botnetNodes;
        document.getElementById("stat-ccNodes").textContent = ccNodes;
        document.getElementById("stat-guardianNodes").textContent =
          guardianNodes;
        document.getElementById("stat-firewallNodes").textContent =
          firewallNodes;
        document.getElementById("stat-groundStations").textContent =
          groundStations;
        document.getElementById("stat-satellites").textContent = satellites;

        // Combat statistics (cumulative)
        document.getElementById("stat-totalAttacks").textContent =
          stats.totalAttacks;
        document.getElementById("stat-totalDefenses").textContent =
          stats.totalDefenses;
        document.getElementById("stat-totalInfections").textContent =
          stats.totalInfections;
        document.getElementById("stat-totalRecoveries").textContent =
          stats.totalRecoveries;
        document.getElementById("stat-pingDeaths").textContent =
          stats.pingDeaths;
        document.getElementById("stat-phishSuccess").textContent =
          stats.phishSuccess;

        // DDOS statistics
        document.getElementById("stat-totalDDOSAttacks").textContent =
          stats.totalDDOSAttacks;
        // Count active DDOS attacks in real-time (kept for future alert system)
        const activeDDOS = nodes.filter(
          (n) => n.status === "commandControl" && n.ddosState === "active"
        ).length;
        stats.activeDDOSAttacks = activeDDOS;

        // Sort stats within each section (but keep Total Nodes at top of Node Status)
        const sections = document.querySelectorAll(".stats-section");
        sections.forEach((section, index) => {
          const sectionTitle = section.querySelector(".stats-section-title");
          if (sectionTitle) {
            const title = sectionTitle.textContent;
            if (title.includes("Node Status")) {
              // Keep "Total Nodes" pinned at the top
              sortStatsInSection(section, true);
            } else if (
              title.includes("Combat Statistics") ||
              title.includes("Packet Counts")
            ) {
              // Sort all items in these sections
              sortStatsInSection(section, false);
            }
          }
        });
      }

      const colors = {
        green: { r: 22, g: 163, b: 74 },
        red: { r: 248, g: 113, b: 113 },
        yellow: { r: 250, g: 204, b: 21 },
        malware: { r: 168, g: 85, b: 247 }, // purple-500
        botnet: { r: 220, g: 38, b: 38 }, // red-600 for botnet
        commandControl: { r: 139, g: 0, b: 0 }, // dark red for C&C nodes
        blue: { r: 59, g: 130, b: 246 }, // blue-500 for the central node
        gold: { r: 251, g: 191, b: 36 }, // amber-400 for pulses
        groundStation: { r: 96, g: 165, b: 250 }, // sky-400 for ground station towers
        satellite: { r: 147, g: 197, b: 253 }, // lighter sky blue for satellites
        line: { r: 209, g: 213, b: 219 }, // Light Gray (gray-300)
        white: { r: 255, g: 255, b: 255 }, // white for immunity packets
        neonGreen: { r: 57, g: 255, b: 20 }, // neon green for firewall nodes
      };

      const LOG_MESSAGES = {
        recoveryShieldExpired: ({ node }) =>
          `üõ°Ô∏è Recovery shield expired on ${
            node?.parent === null
              ? "the central node"
              : `node ${node?.id ?? "?"}`
          } after 15 seconds.`,
        recoveryShieldActivated: ({ node }) =>
          `üõ°Ô∏è Recovery shield activated on ${
            node?.parent === null
              ? "the central node"
              : `node ${node?.id ?? "?"}`
          }! Duration: 15s, Resistance: 99%.`,
        recoveryShieldAttack: ({ target }) =>
          `‚öîÔ∏è Attack on ${
            target?.parent === null
              ? "the central node"
              : `node ${target?.id ?? "?"}`
          } while the recovery shield was active! Resistance: 99%.`,
        firewallBlockedPing: ({ firewallNode }) =>
          `üõ°Ô∏è Node ${firewallNode?.id ?? "?"} blocked a Ping of Death!`,
        phishingSuccess: ({ target }) =>
          `üé£ Phishing attack successful on node ${target?.id ?? "?"}.`,
        centralCompromised: ({ node }) =>
          `üö® CRITICAL ALERT: CENTRAL NODE ${node?.id ?? "?"} COMPROMISED!`,
        firewallGained: ({ node }) =>
          `üõ°Ô∏è Node ${
            node?.id ?? "?"
          } gained firewall capability during recovery!`,
        commandControlDetected: ({ node, clusterSize }) =>
          `‚ò†Ô∏è A C&C Server has been detected at node ${
            node?.id ?? "?"
          } (cluster size: ${clusterSize ?? "?"}).`,
        ccMeshBridged: ({ node, count }) =>
          `üï∏Ô∏è C&C node ${node?.id ?? "?"} bridged to ${count} botnet node${
            count === 1 ? "" : "s"
          } in cluster`,
        botnetBridged: () =>
          "ü¶æ Botnet clusters bridged - mesh network expanding.",
        centralUnderAttack: () =>
          "‚ö†Ô∏è WARNING: Network core is under attack! Immediate defense required!",
        groundStationEstablished: ({ node }) =>
          `üì° Ground station established on node ${node?.id ?? "?"}.`,
        guardianPromotionDispatch: ({ node }) =>
          `üåü Dispatch packet inspired a new Guardian defender at node ${
            node?.id ?? "?"
          }!`,
        guardianPromotionPingRecovery: ({ node }) =>
          `üõ°Ô∏è Resilient node ${
            node?.id ?? "?"
          } recovered from Ping of Death and revealed a Guardian!`,
        guardianPromotionPhishing: ({ node }) =>
          `üï∂ A failed phishing attack exposed a Guardian node ${
            node?.id ?? "?"
          }!`,
        guardianDemoted: ({ node }) =>
          `üõ°Ô∏è Guardian node ${
            node?.id ?? "?"
          } corrupted and reverted to malware.`,
        guardianFirewallSuccess: ({ guardian, target }) =>
          `üõ°Ô∏è Guardian ${guardian?.id ?? "?"} configured a firewall on node ${
            target?.id ?? "?"
          }!`,
        commandControlAggressiveAttack: ({ ccNode, target }) =>
          `‚öîÔ∏è C&C node ${
            ccNode?.id ?? "?"
          } aggressively attacking connected green node ${target?.id ?? "?"}!`,
        pingOfDeathSent: ({ ccNode, target, targetType, pathLength }) =>
          `üíÄ Ping of Death sent from C&C ${ccNode?.id ?? "?"} to ${
            targetType ?? "node"
          } ${target?.id ?? "?"} (path length: ${pathLength ?? "?"}).`,
        pingOfDeathFailed: ({ ccNode }) =>
          `‚ö†Ô∏è Ping of Death from C&C ${
            ccNode?.id ?? "?"
          } failed: no path found to target node.`,
        commandControlPhishBurst: ({ ccNode, burstSize }) =>
          `üé£ C&C node ${
            ccNode?.id ?? "?"
          } launched phishing burst (${burstSize} packet${
            burstSize === 1 ? "" : "s"
          })!`,
        satelliteChainEstablished: ({ node, count }) =>
          `üõ∞Ô∏è Ground station ${node?.id ?? "?"} deployed ${
            count ?? 0
          } satellite${count === 1 ? "" : "s"} in a wireless chain.`,
        satelliteUntethered: ({ node }) =>
          `üõ∞Ô∏è Satellite ${
            node?.id ?? "?"
          } lost its ground station tether and is drifting into space.`,
        nodeDefended: ({ node }) =>
          `üõ°Ô∏è Node ${node?.id ?? "?"} successfully defended against an attack.`,
        nodeInfected: ({ node }) =>
          `‚ò£Ô∏è Node ${node?.id ?? "?"} succumbed to infection.`,
        statusDown: ({ node, previousStatus, isGroundStation }) =>
          `${isGroundStation ? "üü• Ground station" : "üü• Node"} ${
            node?.id ?? "?"
          } went DOWN (from ${previousStatus ?? "unknown"}).`,
        statusMalware: ({ node, previousStatus, isGroundStation }) =>
          `${isGroundStation ? "‚ò£Ô∏è Ground station" : "‚ò£Ô∏è Node"} ${
            node?.id ?? "?"
          } became infected (from ${previousStatus ?? "unknown"}).`,
        statusBotnet: ({ node, previousStatus }) =>
          `ü§ñ Node ${node?.id ?? "?"} joined a botnet cluster (from ${
            previousStatus ?? "unknown"
          }).`,
        statusRecovered: ({ node, previousStatus }) =>
          `‚úÖ Node ${node?.id ?? "?"} restored to healthy status (from ${
            previousStatus ?? "unknown"
          }).`,
        statusWarning: ({ node, previousStatus }) =>
          `‚ö†Ô∏è Node ${node?.id ?? "?"} entered warning state (from ${
            previousStatus ?? "unknown"
          }).`,
        statusCommandControl: ({ node, previousStatus }) =>
          `‚ò†Ô∏è Node ${node?.id ?? "?"} elevated to Command & Control (from ${
            previousStatus ?? "unknown"
          }).`,
        statusBlue: ({ node, previousStatus }) =>
          `üåê Central node restored (from ${previousStatus ?? "unknown"}).`,
        phishingBlocked: ({ node, defender }) =>
          `üõ°Ô∏è ${defender ?? "Defender"} ${
            node?.id ?? "?"
          } blocked a phishing attack!`,
        phishingDefended: ({ node }) =>
          `üõ°Ô∏è Node ${node?.id ?? "?"} successfully defended against phishing.`,
        dispatchBlocked: ({ target }) =>
          `‚ö†Ô∏è Remediation packet to node ${
            target?.id ?? "?"
          } was intercepted by infected nodes.`,
        dispatchSuccessful: ({ target }) =>
          `‚ú® Remediation packet reached node ${
            target?.id ?? "?"
          } - cleanup initiated.`,
        immunityHealingStarted: ({ node, packetCount }) =>
          `üíä Immunity healing started on node ${
            node?.id ?? "?"
          } (${packetCount} packet${packetCount === 1 ? "" : "s"} attached).`,
        immunityHealingCompleted: ({ node }) =>
          `‚úÖ Node ${node?.id ?? "?"} fully healed by immunity packets!`,
        immunityPacketUpgraded: ({ node, totalPackets, superchargedCount }) =>
          `‚ö° Immunity packet on node ${
            node?.id ?? "?"
          } upgraded to supercharged! (${superchargedCount}/${totalPackets} supercharged)`,
        pingOfDeathHit: ({ target, targetType }) =>
          `üíÄ Ping of Death struck ${targetType ?? "node"} ${
            target?.id ?? "?"
          }!`,
        guardianVpnCreated: ({ guardian, target }) =>
          `üîí Guardian ${guardian?.id ?? "?"} established VPN tunnel to node ${
            target?.id ?? "?"
          }.`,
        remediationStarted: ({ node }) =>
          `üîÑ Node ${node?.id ?? "?"} beginning remediation process...`,
        immunitySupercharged: ({ packetCount }) =>
          `‚ö° Central node supercharged ${packetCount} immunity packet${
            packetCount === 1 ? "" : "s"
          }!`,
        satelliteRespawning: ({ groundStation }) =>
          `üõ∞Ô∏è Ground station ${
            groundStation?.id ?? "?"
          } relaunched satellite chain...`,
        ddosCharging: ({ ccNode, botnetCount, targetBranch }) =>
          `‚ö° C&C node ${
            ccNode?.id ?? "?"
          } charging DDOS with ${botnetCount} botnet${
            botnetCount === 1 ? "" : "s"
          }, targeting branch ${targetBranch?.id ?? "?"}...`,
        ddosLaunched: ({ ccNode, targetBranch, botnetCount }) =>
          `üö® DDOS ATTACK! C&C ${ccNode?.id ?? "?"} and ${botnetCount} botnet${
            botnetCount === 1 ? "" : "s"
          } overwhelming branch ${targetBranch?.id ?? "?"}!`,
        ddosEnded: ({ ccNode, targetBranch }) =>
          `‚úÖ DDOS attack from C&C ${ccNode?.id ?? "?"} on branch ${
            targetBranch?.id ?? "?"
          } ended - network recovering.`,
        custom: ({ message }) => message ?? "",
      };

      const MAX_BRANCH_DEPTH = 4; // Maximum depth from central node (central=0, first child=1, etc.)
      const SATELLITE_DRIFT_FADE_RATE = 0.015; // Fade rate when despawning
      const SATELLITE_DRIFT_SPEED_MIN = 0.5; // Minimum drift speed when untethered
      const SATELLITE_DRIFT_SPEED_MAX = 1.5; // Maximum drift speed when untethered
      const SATELLITE_DRIFT_GRAVITY = 0.02; // Gravity effect on drifting satellites
      const OFFSCREEN_MARGIN = 50; // Margin beyond canvas before despawn

      // ORBITAL TRAJECTORY SETTINGS: Satellites orbit freely above the network
      const SATELLITE_ORBIT_RADIUS_MIN = 0.8; // Minimum orbit radius (80% of canvas half-size, higher to avoid branches)
      const SATELLITE_ORBIT_RADIUS_MAX = 0.98; // Maximum orbit radius (98% of canvas half-size)
      const ORBITAL_SPEED_BASE = 0.0015; // Base angular velocity (radians per frame) - slow drift
      const ORBITAL_SPEED_VARIANCE = 0.0005; // Random variance in speed
      const ORBITAL_SMOOTHING = 0.015; // Very gentle interpolation
      const SATELLITE_LAUNCH_DURATION = 6000; // 5 seconds to curve from ground station to orbit (slower, more visible)
      const SATELLITE_SPACING_MIN = 0.4; // Minimum angular spacing (radians) ~23¬∞
      const SATELLITE_UNLINKED_TIMEOUT = 30000; // 30 seconds before unlinked satellite despawns
      const SATELLITE_MAX_LIFESPAN = 120000; // 2 minutes maximum lifespan
      const WIRELESS_LINK_MAX_DISTANCE_RATIO = 0.42; // Maximum distance for wireless links (33% of screen diagonal)
      const GROUND_STATION_SPROUT_CHANCE = 0.02; // 2% chance per tick for healthy node to sprout ground station
      const GROUND_STATION_LAUNCH_INTERVAL = 30000; // Ground stations launch satellites every 30 seconds
      const GROUND_STATION_MAX_LIFESPAN = 120000; // 2 minutes maximum lifespan

      // Event log buffers for UI display (separate by type)
      const eventLogBuffers = {
        critical: [],
        attack: [],
        defense: [],
        success: [],
        warning: [],
        info: [],
      };
      const MAX_LOG_ENTRIES_PER_TYPE = 10;

      function logEvent(key, context = {}) {
        const template = LOG_MESSAGES[key];
        if (!template) {
          console.warn(
            `[logEvent] Missing log message for key: ${key}`,
            context
          );
          return;
        }

        const message =
          typeof template === "function" ? template(context) : template;
        if (message) {
          console.log(message);

          // Add to UI event log
          addEventToLog(message, key);
        }
      }

      function addEventToLog(message, eventKey) {
        const timestamp = new Date().toLocaleTimeString("en-US", {
          hour12: false,
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
        });

        // Determine log type based on event key or message content
        let logType = "info";
        if (
          eventKey.includes("central") ||
          eventKey.includes("critical") ||
          message.includes("üö®")
        ) {
          logType = "critical";
        } else if (
          eventKey.includes("attack") ||
          eventKey.includes("infected") ||
          eventKey.includes("malware") ||
          message.includes("‚öîÔ∏è") ||
          message.includes("‚ò£Ô∏è") ||
          message.includes("üíÄ")
        ) {
          logType = "attack";
        } else if (
          eventKey.includes("defend") ||
          eventKey.includes("blocked") ||
          eventKey.includes("shield") ||
          message.includes("üõ°Ô∏è") ||
          message.includes("üåü")
        ) {
          logType = "defense";
        } else if (
          eventKey.includes("recovered") ||
          eventKey.includes("healed") ||
          eventKey.includes("success") ||
          message.includes("‚úÖ") ||
          message.includes("‚ú®")
        ) {
          logType = "success";
        } else if (
          eventKey.includes("warning") ||
          eventKey.includes("down") ||
          message.includes("‚ö†Ô∏è")
        ) {
          logType = "warning";
        }

        // Add to appropriate buffer
        const buffer = eventLogBuffers[logType];
        if (!buffer) return;

        const logEntry = {
          timestamp,
          message,
          type: logType,
        };

        // Add to start of buffer
        buffer.unshift(logEntry);

        // Keep buffer size limited
        if (buffer.length > MAX_LOG_ENTRIES_PER_TYPE) {
          buffer.pop();
        }

        // Show the section if hidden
        const section = document.getElementById(`log-section-${logType}`);
        if (section) {
          section.style.display = "block";
        }

        // Add entry to DOM with animation
        addLogEntryToDOM(logEntry);

        // Add to Ticker if critical or important
        // Filter for high-priority events to avoid clutter
        // USER REQUEST: Filter out attack, defense, success, and warning events. Only show Critical.
        if (logType === "critical") {
          TickerSystem.add(message, logType);
        }
      }

      function addLogEntryToDOM(log) {
        const container = document.getElementById(`logs-${log.type}`);
        if (!container) return;

        // Create log entry element
        const logEntry = document.createElement("div");
        logEntry.className = `log-entry log-${log.type}`;
        logEntry.innerHTML = `<span class="log-timestamp">${log.timestamp}</span>${log.message}`;

        // Insert at the top
        container.insertBefore(logEntry, container.firstChild);

        // Remove excess entries
        while (container.children.length > MAX_LOG_ENTRIES_PER_TYPE) {
          container.removeChild(container.lastChild);
        }
      }

      // Interactive Tools System
      let activeTool = null;
      let linkSourceNode = null; // For linking tool

      // Initialize tool button handlers
      function initializeToolButtons() {
        const toolButtons = document.querySelectorAll(".tool-btn");
        toolButtons.forEach((btn) => {
          btn.addEventListener("click", () => {
            const tool = btn.dataset.tool;

            // Toggle tool selection
            if (activeTool === tool) {
              activeTool = null;
              linkSourceNode = null;
              btn.classList.remove("active");
            } else {
              // Deactivate all other tools
              toolButtons.forEach((b) => b.classList.remove("active"));
              activeTool = tool;
              linkSourceNode = null;
              btn.classList.add("active");
            }

            // Update cursor style
            canvas.style.cursor = activeTool ? "crosshair" : "default";
          });
        });
      }

      // Stats Pane Toggle
      function initializeStatsPaneToggle() {
        const statsPane = document.getElementById("statsPane");
        const toggleBtn = document.getElementById("statsPaneToggle");
        const toggleIcon = document.getElementById("toggleIcon");
        toggleBtn.classList.toggle(
          "collapsed",
          statsPane.classList.contains("collapsed")
        );
        toggleIcon.textContent = statsPane.classList.contains("collapsed")
          ? "¬´"
          : "¬ª";

        toggleBtn.addEventListener("click", () => {
          statsPane.classList.toggle("collapsed");
          toggleBtn.classList.toggle(
            "collapsed",
            statsPane.classList.contains("collapsed")
          );

          // Update viewState
          viewState.isSidePanelOpen =
            !statsPane.classList.contains("collapsed");

          // Update Ticker position
          const ticker = document.getElementById("newsTicker");
          if (ticker) {
            if (viewState.isSidePanelOpen) {
              ticker.classList.add("sidebar-open");
            } else {
              ticker.classList.remove("sidebar-open");
            }
          }

          // Update toggle icon
          if (statsPane.classList.contains("collapsed")) {
            toggleIcon.textContent = "¬´"; // Point toward center when collapsed
          } else {
            toggleIcon.textContent = "¬ª"; // Point toward edge when expanded
          }
        });
      }

      // Tab System
      function initializeTabs() {
        const tabButtons = document.querySelectorAll(".tab-btn");
        const tabContents = document.querySelectorAll(".tab-content");

        tabButtons.forEach((btn) => {
          btn.addEventListener("click", () => {
            const targetTab = btn.dataset.tab;

            // Remove active class from all buttons and contents
            tabButtons.forEach((b) => b.classList.remove("active"));
            tabContents.forEach((content) =>
              content.classList.remove("active")
            );

            // Add active class to clicked button and corresponding content
            btn.classList.add("active");
            document.getElementById(`tab-${targetTab}`).classList.add("active");
          });
        });
      }

      // Simulation Control Sliders
      function initializeSliders() {
        // Simulation Speed Slider
        const simSpeedSlider = document.getElementById("simSpeed");
        const simSpeedValue = document.getElementById("simSpeed-value");
        simSpeedSlider.addEventListener("input", (e) => {
          simSpeedMultiplier = e.target.value / 100;
          simSpeedValue.textContent = `${simSpeedMultiplier.toFixed(1)}x`;
        });

        // Packet Speed Slider
        const packetSpeedSlider = document.getElementById("packetSpeed");
        const packetSpeedValue = document.getElementById("packetSpeed-value");
        packetSpeedSlider.addEventListener("input", (e) => {
          packetSpeedMultiplier = e.target.value / 100;
          packetSpeedValue.textContent = `${packetSpeedMultiplier.toFixed(1)}x`;
        });

        // Attack Frequency Slider
        const attackFreqSlider = document.getElementById("attackFreq");
        const attackFreqValue = document.getElementById("attackFreq-value");
        attackFreqSlider.addEventListener("input", (e) => {
          attackFreqMultiplier = e.target.value / 100;
          attackFreqValue.textContent = `${attackFreqMultiplier.toFixed(1)}x`;
        });

        // Healing Speed Slider
        const healSpeedSlider = document.getElementById("healSpeed");
        const healSpeedValue = document.getElementById("healSpeed-value");
        healSpeedSlider.addEventListener("input", (e) => {
          healSpeedMultiplier = e.target.value / 100;
          healSpeedValue.textContent = `${healSpeedMultiplier.toFixed(1)}x`;
        });

        // Central Branches Slider
        const branchSlider = document.getElementById("branchCount");
        const branchValue = document.getElementById("branchCount-value");
        if (branchSlider && branchValue) {
          branchSlider.addEventListener("input", (e) => {
            desiredBranchCount = parseInt(e.target.value, 10);
            branchValue.textContent = desiredBranchCount;
          });
          branchSlider.value = desiredBranchCount;
          branchValue.textContent = desiredBranchCount;
        }

        // Reset Button
        const resetBtn = document.getElementById("resetSliders");
        resetBtn.addEventListener("click", () => {
          // Reset all sliders to default value (100 = 1.0x)
          simSpeedSlider.value = 100;
          packetSpeedSlider.value = 100;
          attackFreqSlider.value = 100;
          healSpeedSlider.value = 100;
          if (branchSlider) branchSlider.value = DEFAULT_BRANCH_COUNT;

          // Update multipliers
          simSpeedMultiplier = 1.0;
          packetSpeedMultiplier = 1.0;
          attackFreqMultiplier = 1.0;
          healSpeedMultiplier = 1.0;
          desiredBranchCount = DEFAULT_BRANCH_COUNT;

          // Update display values
          simSpeedValue.textContent = "1.0x";
          packetSpeedValue.textContent = "1.0x";
          attackFreqValue.textContent = "1.0x";
          healSpeedValue.textContent = "1.0x";
          if (branchValue) branchValue.textContent = DEFAULT_BRANCH_COUNT;
        });
      }

      // Tool implementations
      function sproutNode(parentNode) {
        if (parentNode.state !== "alive") return;

        // Create a new child node
        // IMPROVED: Sprout outward from center
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        let baseAngle;

        if (parentNode.parent === null) {
          // Central node: random angle
          baseAngle = Math.random() * Math.PI * 2;
        } else {
          // Branch node: sprout away from center
          baseAngle = Math.atan2(
            parentNode.y - centerY,
            parentNode.x - centerX
          );
        }

        // Add organic variance (+/- 60 degrees)
        const angleVariance = (Math.random() - 0.5) * (Math.PI / 1.5);
        const angle = baseAngle + angleVariance;

        // IMPROVED: Match physics engine ideal distances
        // If parent is central node, this is 1st gen -> 160px
        // If parent is branch, this is 2nd+ gen -> 80px
        const isFirstGen = parentNode.parent === null;
        const idealDist = isFirstGen ? 160 : 80;
        const distance = idealDist + (Math.random() * 20 - 10);

        const targetX = parentNode.x + Math.cos(angle) * distance;
        const targetY = parentNode.y + Math.sin(angle) * distance;

        const newNode = new Node(
          Date.now() + Math.random(),
          targetX,
          targetY,
          parentNode
        );
        parentNode.children.push(newNode);
        nodes.push(newNode);
        edges.push({
          from: parentNode,
          to: newNode,
          natural: true,
        });

        // Visual feedback
        createPopParticles(newNode.x, newNode.y, colors.green);
        logEvent("custom", {
          message: `üå± New node ${newNode.id} sprouted from node ${parentNode.id}!`,
        });
      }

      function infectNode(node) {
        if (node.state !== "alive") return;

        const previousStatus = node.status;
        let message = "";
        let particleColor = colors.malware;

        // Remove any immunity packets attached to the node
        if (
          node.attachedImmunityPackets &&
          node.attachedImmunityPackets.length > 0
        ) {
          const packetCount = node.attachedImmunityPackets.length;
          node.attachedImmunityPackets.forEach((packet) => {
            if (packet.active) {
              packet.active = false;
              packet.isAttached = false;
              packet.attachedNode = null;
              createPopParticles(packet.x, packet.y, colors.red);
            }
          });
          node.attachedImmunityPackets = [];
          node.isImmunityHealing = false;
          node.immunityHealingStartTime = 0;
          message = `‚ò£Ô∏è Stripped ${packetCount} immunity packet(s) from node ${node.id}! `;
        }

        // Escalate infection based on current status
        if (node.status === "commandControl") {
          // Already at max infection level
          message += `Node ${node.id} is already a Command & Control node!`;
        } else if (node.status === "botnet") {
          // Escalate to C&C
          node.status = "commandControl";
          node.statusChangeTime = Date.now();
          message += `Botnet ${node.id} escalated to Command & Control!`;
          particleColor = colors.commandControl;
          incrementStat("totalInfections");
        } else if (node.status === "malware") {
          // Escalate to botnet
          node.status = "botnet";
          node.statusChangeTime = Date.now();
          message += `Malware ${node.id} escalated to Botnet!`;
          particleColor = colors.botnet;
          incrementStat("totalInfections");
        } else if (
          node.status === "green" ||
          node.status === "blue" ||
          node.status === "red" ||
          node.status === "yellow"
        ) {
          // Initial infection
          node.status = "malware";
          node.statusChangeTime = Date.now();
          message += `Node ${node.id} forcibly infected with malware!`;
          particleColor = colors.malware;
          incrementStat("totalInfections");
        } else {
          return; // Unknown status, do nothing
        }

        logEvent("custom", { message });

        // Visual feedback
        createPopParticles(node.x, node.y, particleColor);
      }

      function cureNode(node) {
        if (node.state !== "alive") return;

        const isInfected =
          node.status === "malware" ||
          node.status === "botnet" ||
          node.status === "commandControl" ||
          node.status === "red";
        const isHealthy = node.status === "green";

        if (!isInfected && !isHealthy) return;

        if (isInfected) {
          const previousStatus = node.status;
          node.status = "green";
          node.statusChangeTime = Date.now();
          node.isImmunityHealing = false;
          node.attachedImmunityPackets = [];
          node.remediationState = "none";

          logEvent("custom", {
            message: `üíä Node ${node.id} instantly cured from ${previousStatus}!`,
          });

          // Visual feedback
          createPopParticles(node.x, node.y, colors.green);
          incrementStat("totalRecoveries");
          return;
        }

        // Healthy node reinforcement: grant firewall or promote to guardian if already fortified
        // Satellites cannot receive firewalls - they are just bridges
        if (!node.hasFirewall && !node.isSatellite) {
          node.hasFirewall = true;
          node.shieldActive = true;
          node.shieldOpacity = Math.min(1, node.shieldOpacity + 0.5);
          logEvent("custom", {
            message: `üõ°Ô∏è Cure tool reinforced node ${node.id} with a firewall!`,
          });
          createPopParticles(node.x, node.y, colors.blue);
          return;
        }

        if (!node.isGuardian) {
          const promoted = promoteToGuardian(node, null);
          if (promoted) {
            logEvent("custom", {
              message: `üï∂ Cure tool elevated node ${node.id} to Guardian status!`,
            });
          } else {
            logEvent("custom", {
              message: `‚ÑπÔ∏è Node ${node.id} could not be promoted to Guardian.`,
            });
          }
        } else {
          logEvent("custom", {
            message: `‚ÑπÔ∏è Node ${node.id} is already a Guardian defender.`,
          });
        }
      }

      function hardenNode(node) {
        if (node.state !== "alive") return;

        // Special handling for central node - activate all defense modes
        if (node.parent === null) {
          const now = Date.now();
          let modesActivated = [];

          // 1. Activate Recovery Shield (15 seconds, 99% resistance)
          if (!node.hasRecoveryShield) {
            node.hasRecoveryShield = true;
            node.recoveryShieldStartTime = now;
            node.shieldActive = true;
            node.shieldOpacity = 0; // Will fade in
            modesActivated.push("üõ°Ô∏è Recovery Shield (15s, 99% resistance)");
            logEvent("recoveryShieldActivated", { node });
          }

          // 2. Activate Bot Defense Mode (10 seconds, spawns immunity packets)
          if (
            !node.botDefenseModeActive &&
            now >= (node.botDefenseCooldownUntil || 0)
          ) {
            node.botDefenseModeActive = true;
            node.botDefenseModeStart = now;
            // Get infected branches for targeting
            const infectedBranches = (node.children || []).filter(
              (ch) =>
                ch &&
                ch.state === "alive" &&
                (ch.status === "malware" ||
                  ch.status === "botnet" ||
                  ch.status === "commandControl")
            );
            node.botDefenseTargets = infectedBranches;
            modesActivated.push(
              "‚öîÔ∏è Bot Defense Mode (10s, spawns immunity packets)"
            );
          }

          // 3. Self-Healing mode is only activated when infected, so skip it here

          if (modesActivated.length > 0) {
            logEvent("custom", {
              message: `üåü Central Node Defense Modes Activated:\n${modesActivated.join(
                "\n"
              )}`,
            });
            createPopParticles(node.x, node.y, colors.blue);
          } else {
            logEvent("custom", {
              message: `‚ö†Ô∏è Central node defense modes are already active or on cooldown!`,
            });
          }
          return;
        }

        // Satellites cannot be hardened - they are just bridges
        if (node.isSatellite) {
          logEvent("custom", {
            message: `‚ÑπÔ∏è Satellites are bridges and cannot be hardened.`,
          });
          return;
        }

        // Regular node hardening (firewall ‚Üí guardian progression)
        if (!node.hasFirewall) {
          node.hasFirewall = true;
          logEvent("custom", {
            message: `üõ°Ô∏è Firewall activated on node ${node.id}!`,
          });
        } else if (!node.isGuardian) {
          node.isGuardian = true;
          logEvent("custom", {
            message: `üåü Node ${node.id} promoted to Guardian status!`,
          });
        } else {
          logEvent("custom", {
            message: `‚ö†Ô∏è Node ${node.id} is already fully hardened!`,
          });
          return;
        }

        // Visual feedback
        createPopParticles(node.x, node.y, colors.blue);
      }

      function linkNodes(node) {
        if (node.state !== "alive") return;

        if (!linkSourceNode) {
          // First node selected
          linkSourceNode = node;
          logEvent("custom", {
            message: `üîó Link source set to node ${node.id}. Click another node to complete the link.`,
          });

          // Visual feedback
          createPopParticles(node.x, node.y, colors.blue);
        } else {
          // Second node selected - create link
          if (linkSourceNode === node) {
            logEvent("custom", { message: `‚ö†Ô∏è Cannot link a node to itself!` });
            linkSourceNode = null;
            return;
          }

          // Check if edge already exists
          const edgeExists = edges.some(
            (e) =>
              (e.from === linkSourceNode && e.to === node) ||
              (e.from === node && e.to === linkSourceNode)
          );

          if (edgeExists) {
            logEvent("custom", {
              message: `‚ö†Ô∏è Nodes ${linkSourceNode.id} and ${node.id} are already connected!`,
            });
          } else {
            edges.push({
              from: linkSourceNode,
              to: node,
              natural: false,
              userCreated: true,
            });
            logEvent("custom", {
              message: `üîó Created link between node ${linkSourceNode.id} and node ${node.id}!`,
            });

            // Visual feedback
            createPopParticles(linkSourceNode.x, linkSourceNode.y, colors.blue);
            createPopParticles(node.x, node.y, colors.blue);
          }

          linkSourceNode = null;
        }
      }

      function pruneNode(node) {
        if (!node) return;

        // If central node, prune all branches (keep central node)
        if (node.parent === null) {
          // Identify all direct children
          const children = node.children ? [...node.children] : [];
          let count = 0;
          children.forEach((child) => {
            count += pruneBranch(child);
          });

          node.children = []; // Clear children of central node

          logEvent("custom", {
            message: `‚úÇÔ∏è Pruned all ${count} nodes from the central node!`,
          });
          createPopParticles(node.x, node.y, colors.red);
          return;
        }

        // If branch node, prune it and its subtree
        const count = pruneBranch(node);
        logEvent("custom", {
          message: `‚úÇÔ∏è Pruned branch starting at node ${node.id} (${count} nodes removed).`,
        });
      }

      // Helper to recursively remove a node and its descendants
      function pruneBranch(node) {
        // Collect all descendants
        const toRemove = [];
        const stack = [node];

        while (stack.length > 0) {
          const curr = stack.pop();
          toRemove.push(curr);
          if (curr.children) {
            for (const child of curr.children) {
              stack.push(child);
            }
          }
          // Also include satellites if this is a ground station
          if (curr.isGroundStation && curr.satelliteChain) {
            for (const sat of curr.satelliteChain) {
              stack.push(sat);
            }
          }
        }

        // Remove from parent's children list
        if (node.parent) {
          const idx = node.parent.children.indexOf(node);
          if (idx !== -1) {
            node.parent.children.splice(idx, 1);
          }
        }

        // Remove from global nodes and edges
        // Using a Set for faster lookup
        const toRemoveSet = new Set(toRemove);

        // Filter nodes in place (iterate backwards)
        let removedCount = 0;
        for (let i = nodes.length - 1; i >= 0; i--) {
          const n = nodes[i];
          if (toRemoveSet.has(n)) {
            // Add visual effect before removing
            createPopParticles(n.x, n.y, colors.line);

            // --- Robust Cleanup ---
            // Clear attached immunity packets
            if (
              n.attachedImmunityPackets &&
              n.attachedImmunityPackets.length > 0
            ) {
              n.attachedImmunityPackets.forEach((packet) => {
                packet.active = false;
                packet.isAttached = false;
                packet.attachedNode = null;
              });
              n.attachedImmunityPackets = [];
              n.isImmunityHealing = false;
            }

            // Clear targeting flags
            n.isTargeted = false;

            // Mark as dead so other systems (packets) know to stop tracking/targeting it
            n.state = "dead";

            nodes.splice(i, 1);
            removedCount++;
          }
        }

        // Filter edges
        for (let i = edges.length - 1; i >= 0; i--) {
          const edge = edges[i];
          if (toRemoveSet.has(edge.from) || toRemoveSet.has(edge.to)) {
            edges.splice(i, 1);
          }
        }

        // Filter pulses (DispatchPackets) that target removed nodes
        if (typeof pulses !== "undefined") {
          pulses = pulses.filter((p) => !toRemoveSet.has(p.target));
        }

        return removedCount;
      }

      // Get node at mouse position (mapped from screen to world coordinates)
      function getNodeAtPosition(screenX, screenY) {
        const panelOffset = viewState.isSidePanelOpen
          ? viewState.sidePanelWidth
          : 0;
        const visualCx = (canvas.width - panelOffset) / 2;
        const visualCy = canvas.height / 2;
        const worldCx = canvas.width / 2;
        const worldCy = canvas.height / 2;

        // Convert screen coordinates to world coordinates
        const worldX = (screenX - visualCx) / viewState.scale + worldCx;
        const worldY = (screenY - visualCy) / viewState.scale + worldCy;

        for (let i = nodes.length - 1; i >= 0; i--) {
          const node = nodes[i];
          if (node.state !== "alive") continue;

          const dx = worldX - node.x;
          const dy = worldY - node.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          // Hitbox also scales slightly to be easier to click when zoomed out, but not too huge
          // Base radius + margin, scaled inversely to zoom (so it feels constant size on screen)
          const hitMargin = 5 / Math.min(1, viewState.scale);
          if (distance < node.radius + hitMargin) {
            return node;
          }
        }
        return null;
      }

      // Apply the active tool to a clicked node
      function applyTool(node) {
        if (!activeTool || !node) return;

        switch (activeTool) {
          case "sprout":
            sproutNode(node);
            break;
          case "infect":
            infectNode(node);
            break;
          case "cure":
            cureNode(node);
            break;
          case "harden":
            hardenNode(node);
            break;
          case "link":
            linkNodes(node);
            break;
          case "prune":
            pruneNode(node);
            break;
          case "drag":
            // Drag is handled by mousedown/mousemove/mouseup listeners
            break;
          default:
            console.warn(`Unknown tool: ${activeTool}`);
        }
      }

      // Canvas click handler for tools
      canvas.addEventListener("click", (e) => {
        if (!activeTool || activeTool === "drag") return;

        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const clickedNode = getNodeAtPosition(x, y);
        if (clickedNode) {
          applyTool(clickedNode);
        }
      });

      // Drag Tool Event Listeners
      canvas.addEventListener("mousedown", (e) => {
        if (activeTool !== "drag") return;

        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const clickedNode = getNodeAtPosition(x, y);
        if (clickedNode) {
          isDragging = true;
          draggedNode = clickedNode;
          // Reset velocity to prevent fighting
          draggedNode.vx = 0;
          draggedNode.vy = 0;
        }
      });

      canvas.addEventListener("mousemove", (e) => {
        if (!isDragging || !draggedNode) return;

        const rect = canvas.getBoundingClientRect();
        const screenX = e.clientX - rect.left;
        const screenY = e.clientY - rect.top;

        // Convert screen coordinates to world coordinates
        const panelOffset = viewState.isSidePanelOpen
          ? viewState.sidePanelWidth
          : 0;
        const visualCx = (canvas.width - panelOffset) / 2;
        const visualCy = canvas.height / 2;
        const worldCx = canvas.width / 2;
        const worldCy = canvas.height / 2;

        const worldX = (screenX - visualCx) / viewState.scale + worldCx;
        const worldY = (screenY - visualCy) / viewState.scale + worldCy;

        // Update node position
        draggedNode.x = worldX;
        draggedNode.y = worldY;
        // Also update baseX/baseY to make the change "stick" better against some physics
        draggedNode.baseX = worldX;
        draggedNode.baseY = worldY;

        // Zero out velocity while dragging
        draggedNode.vx = 0;
        draggedNode.vy = 0;
      });

      canvas.addEventListener("mouseup", () => {
        if (isDragging) {
          isDragging = false;
          draggedNode = null;
        }
      });

      canvas.addEventListener("mouseleave", () => {
        if (isDragging) {
          isDragging = false;
          draggedNode = null;
        }
      });

      const STATUS_LOG_KEYS = {
        red: "statusDown",
        malware: "statusMalware",
        botnet: "statusBotnet",
        green: "statusRecovered",
        yellow: "statusWarning",
        commandControl: "statusCommandControl",
        blue: "statusBlue",
      };

      // --- Canvas and Node Setup ---
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }

      // --- Geometric utility for resolving crossed lines ---
      function linesIntersect(p1, q1, p2, q2) {
        // Helper to find orientation of ordered triplet (p, q, r)
        function orientation(p, q, r) {
          if (!p || !q || !r) return 0; // Prevent errors on missing nodes
          const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
          if (val === 0) return 0; // Collinear
          return val > 0 ? 1 : 2; // Clockwise or Counterclockwise
        }

        // Helper to check if point q lies on segment pr
        function onSegment(p, q, r) {
          if (!p || !q || !r) return false;
          return (
            q.x <= Math.max(p.x, r.x) &&
            q.x >= Math.min(p.x, r.x) &&
            q.y <= Math.max(p.y, r.y) &&
            q.y >= Math.min(p.y, r.y)
          );
        }

        const o1 = orientation(p1, q1, p2);
        const o2 = orientation(p1, q1, q2);
        const o3 = orientation(p2, q2, p1);
        const o4 = orientation(p2, q2, q1);

        // General case of intersection
        if (o1 !== o2 && o3 !== o4) return true;

        // Special Cases for collinear points on a segment
        if (o1 === 0 && onSegment(p1, p2, q1)) return true;
        if (o2 === 0 && onSegment(p1, q2, q1)) return true;
        if (o3 === 0 && onSegment(p2, p1, q2)) return true;
        if (o4 === 0 && onSegment(p2, q1, q2)) return true;

        return false;
      }

      function segmentCrossesExistingEdges(a, b) {
        const toPoint = (obj) => ({
          x: obj && obj.baseX !== undefined ? obj.baseX : obj.x,
          y: obj && obj.baseY !== undefined ? obj.baseY : obj.y,
        });
        const A = toPoint(a);
        const B = toPoint(b);
        for (const e of edges) {
          const p1n = e.from,
            p2n = e.to;
          if (!p1n || !p2n) continue;
          if (e.isWirelessLink || e.isGuardianVpnTunnel) continue;
          if (p1n === a || p2n === a) continue; // share endpoint with start
          if (p1n.state !== "alive" || p2n.state !== "alive") continue;
          const P1 = toPoint(p1n);
          const P2 = toPoint(p2n);
          if (linesIntersect(A, B, P1, P2)) return true;
        }
        return false;
      }

      function nudgeEndpointToAvoidCrossing(parent, endpoint) {
        const MAX_SHIFT = 80;
        const STEP = 6;
        const vx = endpoint.x - parent.x;
        const vy = endpoint.y - parent.y;
        const len = Math.max(1e-6, Math.sqrt(vx * vx + vy * vy));
        const nx = -vy / len; // perpendicular
        const ny = vx / len;
        for (let s = STEP; s <= MAX_SHIFT; s += STEP) {
          const candidates = [
            { x: endpoint.x + nx * s, y: endpoint.y + ny * s },
            { x: endpoint.x - nx * s, y: endpoint.y - ny * s },
          ];
          for (const c of candidates) {
            c.x = Math.max(padding, Math.min(canvas.width - padding, c.x));
            c.y = Math.max(padding, Math.min(canvas.height - padding, c.y));
            if (!segmentCrossesExistingEdges(parent, c)) return c;
          }
        }
        return null;
      }

      // --- NEW: Quadtree Implementation for Performance Optimization ---

      // Represents a circular area for querying the quadtree
      class Circle {
        constructor(x, y, r) {
          this.x = x;
          this.y = y;
          this.r = r;
          this.rSquared = this.r * this.r;
        }

        // Check if a node is inside this circle
        contains(node) {
          let d = Math.pow(node.x - this.x, 2) + Math.pow(node.y - this.y, 2);
          return d <= this.rSquared;
        }

        // Check if this circle intersects with a rectangular boundary
        intersects(range) {
          let xDist = Math.abs(range.x - this.x);
          let yDist = Math.abs(range.y - this.y);
          let r = this.r;
          let w = range.w;
          let h = range.h;

          if (xDist > w + r || yDist > h + r) return false;
          if (xDist <= w || yDist <= h) return true;

          let cornerDistSq = Math.pow(xDist - w, 2) + Math.pow(yDist - h, 2);
          return cornerDistSq <= this.rSquared;
        }
      }

      // Represents a rectangular boundary for a quadtree quadrant
      class Rectangle {
        constructor(x, y, w, h) {
          this.x = x; // center x
          this.y = y; // center y
          this.w = w; // half-width
          this.h = h; // half-height
        }

        // Check if a node is within this boundary
        contains(node) {
          return (
            node.x >= this.x - this.w &&
            node.x < this.x + this.w &&
            node.y >= this.y - this.h &&
            node.y < this.y + this.h
          );
        }

        // Check if another rectangular boundary intersects with this one
        intersects(range) {
          return !(
            range.x - range.w > this.x + this.w ||
            range.x + range.w < this.x - this.w ||
            range.y - range.h > this.y + this.h ||
            range.y + range.h < this.y - this.h
          );
        }
      }

      // The Quadtree class for spatial partitioning
      class Quadtree {
        constructor(boundary, capacity) {
          this.boundary = boundary;
          this.capacity = capacity; // Max number of nodes in a quadrant before it subdivides
          this.nodes = [];
          this.divided = false;
        }

        // Create four sub-quadrants
        subdivide() {
          let { x, y, w, h } = this.boundary;
          let hw = w / 2;
          let hh = h / 2;

          let nw = new Rectangle(x - hw, y - hh, hw, hh);
          this.northwest = new Quadtree(nw, this.capacity);
          let ne = new Rectangle(x + hw, y - hh, hw, hh);
          this.northeast = new Quadtree(ne, this.capacity);
          let sw = new Rectangle(x - hw, y + hh, hw, hh);
          this.southwest = new Quadtree(sw, this.capacity);
          let se = new Rectangle(x + hw, y + hh, hw, hh);
          this.southeast = new Quadtree(se, this.capacity);

          this.divided = true;
        }

        // Insert a node into the quadtree
        insert(node) {
          if (!this.boundary.contains(node)) {
            return false;
          }

          if (this.nodes.length < this.capacity) {
            this.nodes.push(node);
            return true;
          }

          if (!this.divided) {
            this.subdivide();
          }

          // Pass the node down to the correct sub-quadrant
          return (
            this.northeast.insert(node) ||
            this.northwest.insert(node) ||
            this.southeast.insert(node) ||
            this.southwest.insert(node)
          );
        }

        // Find all nodes within a given range (a Circle)
        query(range, found) {
          if (!found) {
            found = [];
          }

          if (!range.intersects(this.boundary)) {
            return found;
          }

          for (let n of this.nodes) {
            if (range.contains(n)) {
              found.push(n);
            }
          }

          if (this.divided) {
            this.northwest.query(range, found);
            this.northeast.query(range, found);
            this.southwest.query(range, found);
            this.southeast.query(range, found);
          }

          return found;
        }
      }

      class Node {
        constructor(id, x, y, parent = null) {
          this.id = id;
          this.x = parent ? parent.x : x;
          this.y = parent ? parent.y : y;
          this.baseX = x;
          this.baseY = y;
          this.baseRadius = Math.random() * 8 + 7;
          this.radius = 0;
          this.targetRadius = this.baseRadius;
          this.status = "green";
          this.parent = parent;
          this.children = [];
          this.fx = 0;
          this.fy = 0;
          this.time = Math.random() * 100;
          this.createdAt = Date.now();
          this.settlingUntil = 0; // Timestamp for post-spawn settling period
          this.isPositionLocked = false; // Lock position during settling to prevent bounce
          this.forceMultiplier = 0; // Gradually ramp up physics forces after unlock
          this.currentColor = { ...colors.green };
          this.state = "spawning";
          this.opacity = 0;
          this.spawnProgress = 0;
          this.infectedAt = null;
          this.dispatchDelay = 0;
          this.isTargeted = false;
          this.remediationState = "none";
          this.remediationStart = 0;
          this.spinnerAngle = 0;
          this.pulseEffect = 0;
          this.isHealing = false; // Flag to indicate a node is being healed
          this.statusChangedAt = 0; // Timestamp for status changes
          this.spreadingInfections = []; // Array of objects: { target, startTime }
          this.isBeingInfected = false;
          this.isDefending = false;
          this.defenseStartTime = 0;
          this.isSelfHealing = false;
          this.selfHealingStartTime = 0;
          this.heartbeatRate = 0.025; // Base heartbeat speed
          this.heartbeatIntensity = 0.4; // How much the node pulses
          this.breathingPhase = Math.random() * Math.PI * 2; // Random starting phase for organic feel
          this.spreadDelay = 0; // Delay before an infected node tries to spread
          this.canSpread = true; // Whether this node will attempt to spread (90% yes, 10% no)
          this.pendingDispatchPromotionCheck = false; // Flag to evaluate guardian promotion after remediation

          // Immunity system properties
          this.attachedImmunityPackets = []; // Array of immunity packets attached to this node
          this.immunityHealingStartTime = 0; // When immunity healing started
          this.isImmunityHealing = false; // Whether this node is being healed by immunity packets

          // Guardian properties
          this.isGuardian = false; // Threat-hunter designation
          this.guardianImmunityLastSpawn = 0; // Cooldown tracker for immunity streams
          this.guardianStreamCount = 0; // Counts emitted immunity packets for cadence control
          this.guardianDispatchLastSent = 0; // Tracks last guardian dispatch packet timing
          this.guardianVpnTunnels = []; // Active guardian VPN tunnels
          this.lastGuardianBridgeUpdate = 0; // Timestamp for VPN tunnel refresh cadence
          this.lastGuardianFirewallAttempt = 0; // Tracks last attempt to configure a firewall
          this.selfHealingDispatchAllowance = 0; // Extra dispatches allowed during self-healing
          this.selfHealingPacketsCreated = 0; // Tracks packets spawned during central self-healing
          this.selfHealingPacketCap = 0; // Maximum packets allowed per self-heal
          this.botDefenseBurstCounts = {}; // Track bot defense bursts per branch
          this.isGroundStation = false; // Tower nodes anchoring sparse branches
          this.groundStationEstablishedAt = 0; // Timestamp when promoted to ground station
          this.satelliteChain = [];
          this.satelliteEdges = [];

          // Satellite node properties
          this.isSatellite = false;
          this.satelliteHost = null;
          this.isTethered = false;
          this.isDrifting = false;
          this.driftVelocityX = 0;
          this.driftVelocityY = 0;
          this.lastSatelliteChainCheck = 0;

          // Shield properties
          this.hasFirewall = Math.random() < 0.25; // 25% of nodes have firewall capability (increased from 10%)
          this.shieldActive = false; // Whether shield is currently visible
          this.shieldOpacity = 0; // Current shield opacity (0-1)
          this.shieldStrength = 1.0; // Shield strength (0-1), affects size and opacity
          this.shieldFlashTimer = Math.random() * 10000; // Time until next shield flash
          this.shieldCracking = false; // Whether shield is cracking/shattering
          this.shieldCrackProgress = 0; // Progress of cracking animation (0-1)
          this.shieldFragments = []; // Fragments for shatter animation

          // Recovery shield (central node only)
          this.hasRecoveryShield = false; // Blue immunity shield after recovering from infection
          this.recoveryShieldStartTime = 0; // When the recovery shield was activated
          this.recoveryShieldDuration = 15000; // 15 seconds of protection

          // Command & Control (C&C) node properties
          this.isCommandControl = false; // Whether this is a C&C node
          this.ccRotation = 0; // Rotation angle for C&C visual effects
          this.activePingOfDeath = null; // Track active ping of death packet (one at a time)
          this.lastPingTime = 0; // Cooldown for ping of death
          // Bot Defense Mode state (central node only)
          this.botDefenseModeActive = false;
          this.botDefenseModeStart = 0;
          this.botDefenseCooldownUntil = 0;
          this.botDefenseTargets = []; // direct infected child branches
          this.botDefenseLastBurst = 0;

          // DDOS Attack state (C&C nodes only)
          this.ddosState = "idle"; // 'idle', 'charging', 'active'
          this.ddosChargeStart = 0;
          this.ddosActiveStart = 0;
          this.ddosTargetBranch = null; // The main branch node being attacked
          this.ddosBotnets = []; // Botnet nodes participating in the attack
          this.ddosCooldownUntil = 0;

          // DDOS victim state (branch nodes under attack)
          this.isUnderDDOS = false;
          this.ddosAttacker = null; // The C&C node coordinating the attack

          // Settling phase for organic physics (new nodes settle in gradually)
          this.settlingPhase = 2000; // 2 seconds to "settle in"
          this.physicsMultiplier = 0.3; // Start with 30% physics influence
          this.currentDamping = 0.5; // Start with high damping (less bounce)
        }

        draw() {
          if (this.opacity <= 0 && this.state !== "spawning") return;

          const mainColorRgba = `rgba(${Math.round(
            this.currentColor.r
          )}, ${Math.round(this.currentColor.g)}, ${Math.round(
            this.currentColor.b
          )}, ${this.opacity})`;

          // Performance: Disable shadows at high node counts
          const enableShadows = nodes.length <= 150;

          if (this.parent === null && !this.isSatellite) {
            // Central node drawing (not for free-floating satellites)
            ctx.save();
            ctx.translate(centralImpactShakeOffsetX, centralImpactShakeOffsetY);
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);

            // Use yellow color when in self-healing mode
            if (this.isSelfHealing) {
              const yellowColor = { r: 251, g: 191, b: 36 }; // amber-400
              const yellowRgba = `rgba(${yellowColor.r}, ${yellowColor.g}, ${yellowColor.b}, ${this.opacity})`;
              ctx.fillStyle = yellowRgba;
              if (enableShadows) {
                ctx.shadowColor = `rgba(${yellowColor.r}, ${yellowColor.g}, ${yellowColor.b}, 0.7)`;
                ctx.shadowBlur = 30;
              }
            } else {
              ctx.fillStyle = mainColorRgba;
              if (enableShadows) {
                ctx.shadowColor = `rgba(${Math.round(
                  this.currentColor.r
                )}, ${Math.round(this.currentColor.g)}, ${Math.round(
                  this.currentColor.b
                )}, 0.7)`;
                ctx.shadowBlur = 30;
              }
            }

            ctx.fill();
            ctx.shadowBlur = 0;

            // Self-healing takes priority over malware icon
            if (this.isSelfHealing) {
              this.drawWrenchIcon(); // Show wrench during self-healing
            } else if (this.status === "malware") {
              this.drawMalwareIcon();
            } else {
              this.drawGlobe(); // Also handles its own defense pulse
            }
            // Offensive security aura during Bot Defense Mode
            if (this.botDefenseModeActive) {
              this.drawBotDefenseMode();
            }
            if (this.isSelfHealing) {
              this.drawAntibodySpinner();
            }

            // Draw shields for central node
            if (this.shieldCracking) {
              this.drawCrackingShield();
            } else if (this.shieldActive && this.shieldOpacity > 0) {
              this.drawShield();
            }

            ctx.restore();
            return;
          }

          // Performance: Skip pulse effect at high node counts (barely visible in crowds)
          if (nodes.length <= 200) {
            const pulseRadius =
              this.radius * (1.8 + Math.sin(this.time * 0.1) * 0.4);
            const pulseAlpha =
              0.2 * (1 - (pulseRadius / (this.radius * 2.2) - 0.5));
            const pulseColorRgba = `rgba(${Math.round(
              this.currentColor.r
            )}, ${Math.round(this.currentColor.g)}, ${Math.round(
              this.currentColor.b
            )}, ${pulseAlpha * this.opacity})`;

            ctx.beginPath();
            ctx.arc(this.x, this.y, pulseRadius, 0, Math.PI * 2);
            ctx.fillStyle = pulseColorRgba;
            ctx.fill();
          }

          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fillStyle = mainColorRgba;

          if (enableShadows) {
            if (
              this.status === "red" ||
              this.status === "malware" ||
              this.status === "botnet" ||
              this.status === "commandControl"
            ) {
              const flashBlur = 15 + Math.sin(this.time * 0.3) * 10;
              let flashColor = this.currentColor;
              if (this.status === "malware" || this.status === "botnet") {
                flashColor = this.isGroundStation ? colors.malware : colors.red;
              }
              if (this.status === "commandControl")
                flashColor = colors.commandControl;
              ctx.shadowColor = `rgba(${flashColor.r}, ${flashColor.g}, ${flashColor.b}, ${this.opacity})`;
              ctx.shadowBlur = Math.max(0, flashBlur);
            } else {
              ctx.shadowColor = mainColorRgba;
              ctx.shadowBlur = 15;
            }
          }

          ctx.fill();
          ctx.shadowBlur = 0;

          // Performance: Skip icon drawing at high node counts, except for important nodes
          const drawIcons =
            nodes.length <= 200 ||
            this.isGuardian ||
            this.isGroundStation ||
            this.isSatellite ||
            this.status === "commandControl";

          if (drawIcons) {
            if (this.isGuardian) {
              this.drawGuardianIcon();
            } else if (this.isGroundStation) {
              this.drawGroundStationIcon();
            } else if (this.isSatellite) {
              this.drawSatelliteIcon();
            } else if (this.status === "commandControl") {
              this.drawSkullIcon();
            } else if (this.status === "malware" || this.status === "botnet") {
              this.drawMalwareIcon();
            } else if (this.status === "green") {
              this.drawCheckmarkIcon();
            } else if (this.status === "red") {
              this.drawStopIcon();
            } else if (this.status === "yellow") {
              this.drawTriangleIcon();
            }
          }

          if (this.remediationState === "spinning") {
            this.drawSpinner();
          }
          if (this.isBeingInfected) {
            this.drawInfectionSpinner();
          }

          // Draw countdown spinner for ground stations
          if (this.isGroundStation && this.groundStationCountdown > 0) {
            this.drawGroundStationCountdown();
          }

          // Draw shields
          if (this.shieldCracking) {
            this.drawCrackingShield();
          } else if (this.shieldActive && this.shieldOpacity > 0) {
            this.drawShield();
          }

          // Draw defense pulse for regular nodes
          if (this.isDefending) {
            const defenseDuration = 1000;
            const elapsed = Date.now() - this.defenseStartTime;
            if (elapsed < defenseDuration) {
              const progress = elapsed / defenseDuration;
              const pulseRadius = this.radius * (1 + progress * 2);
              const pulseOpacity = 1 - progress;
              ctx.beginPath();
              ctx.arc(this.x, this.y, pulseRadius, 0, Math.PI * 2);
              ctx.strokeStyle = `rgba(${colors.red.r}, ${colors.red.g}, ${colors.red.b}, ${pulseOpacity})`;
              ctx.lineWidth = 4 * (1 - progress);
              ctx.stroke();
            } else {
              this.isDefending = false;
            }
          }

          // Draw immunity healing progress
          if (
            this.isImmunityHealing &&
            this.attachedImmunityPackets.length > 0
          ) {
            const BASE_HEAL_TIME = 120000 / healSpeedMultiplier; // 120 seconds for 1 packet

            // Count regular and supercharged packets
            // Supercharged packets count as 2 regular packets
            let regularCount = 0;
            let superchargedCount = 0;
            this.attachedImmunityPackets.forEach((packet) => {
              if (packet.isSupercharged) {
                superchargedCount++;
              } else {
                regularCount++;
              }
            });

            // Calculate effective packet count (supercharged = 2x regular)
            // Reduced recovery modifier by half for slower healing (must match healing completion logic)
            const effectivePackets = (regularCount + superchargedCount * 2) / 2;
            const healTime = BASE_HEAL_TIME / effectivePackets;

            const elapsed = Date.now() - this.immunityHealingStartTime;
            const progress = Math.min(1, elapsed / healTime);

            ctx.save();
            ctx.translate(this.x, this.y);

            const progressBarRadius = this.radius + 12;
            const lineWidth = 3;

            // Draw background circle
            ctx.beginPath();
            ctx.arc(0, 0, progressBarRadius, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(255, 255, 255, ${this.opacity * 0.2})`;
            ctx.lineWidth = lineWidth;
            ctx.stroke();

            // Draw progress arc - gold if any supercharged packets, white otherwise
            ctx.beginPath();
            const startAngle = -Math.PI / 2; // Start from the top
            const endAngle = startAngle + progress * Math.PI * 2;
            ctx.arc(0, 0, progressBarRadius, startAngle, endAngle);

            if (superchargedCount > 0) {
              // Gold progress bar for supercharged healing
              ctx.strokeStyle = `rgba(${colors.gold.r}, ${colors.gold.g}, ${colors.gold.b}, ${this.opacity})`;
              ctx.shadowColor = `rgba(${colors.gold.r}, ${colors.gold.g}, ${colors.gold.b}, 1)`;
            } else {
              // White progress bar for normal healing
              ctx.strokeStyle = `rgba(255, 255, 255, ${this.opacity})`;
              ctx.shadowColor = "rgba(255, 255, 255, 1)";
            }

            ctx.lineWidth = lineWidth;
            ctx.lineCap = "round";
            ctx.shadowBlur = 8;
            ctx.stroke();

            ctx.restore();
          }
        }

        drawMalwareIcon() {
          const iconSize = this.radius * 1.2;
          if (iconSize < 4) return;

          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.font = `bold ${iconSize}px sans-serif`;
          // Show ü§ñ for botnet, üëæ for regular malware
          const icon = this.status === "botnet" ? "ü§ñ" : "üëæ";
          ctx.fillText(icon, 0, iconSize * 0.1);
          ctx.restore();
        }

        drawGuardianIcon() {
          const iconSize = this.radius * 1.3;
          if (iconSize < 4) return;

          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.fillStyle = "#000000";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.font = `bold ${iconSize}px sans-serif`;
          ctx.fillText("üï∂", 0, iconSize * 0.05);
          ctx.restore();
        }

        drawGroundStationIcon() {
          const iconSize = this.radius * 1.1;
          if (iconSize < 4) return;

          // If countdown is active, don't draw icon (number will be drawn by drawGroundStationCountdown)
          if (this.groundStationCountdown > 0) return;

          // Check if launching (within 6 seconds of last launch)
          const SATELLITE_LAUNCH_DURATION = 6000;
          const isLaunching =
            this.lastSatelliteLaunch &&
            Date.now() - this.lastSatelliteLaunch < SATELLITE_LAUNCH_DURATION;
          const icon = isLaunching ? "üöÄ" : "üì°";

          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.font = `bold ${iconSize}px sans-serif`;
          ctx.fillText(icon, 0, iconSize * 0.05);
          ctx.restore();
        }

        drawSatelliteIcon() {
          const iconSize = this.radius * 1.0;
          if (iconSize < 3) return;

          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.font = `bold ${iconSize}px sans-serif`;
          ctx.fillText("üõ∞Ô∏è", 0, 0);
          ctx.restore();
        }

        drawCheckmarkIcon() {
          const iconSize = this.radius * 1.2;
          if (iconSize < 4) return;

          ctx.save();
          ctx.translate(this.x, this.y);
          // Black shield for firewall nodes, white checkmark for regular nodes
          ctx.fillStyle = this.hasFirewall
            ? `rgba(0, 0, 0, ${this.opacity})`
            : `rgba(255, 255, 255, ${this.opacity})`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.font = `bold ${iconSize}px sans-serif`;
          const icon = this.hasFirewall ? "üõ°Ô∏è" : "‚úîÔ∏è";
          ctx.fillText(icon, 0, iconSize * 0.1);
          ctx.restore();
        }

        drawStopIcon() {
          const iconSize = this.radius * 1.2;
          if (iconSize < 4) return;

          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.fillStyle = `rgba(0, 0, 0, ${this.opacity})`; // Black X for down nodes
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.font = `bold ${iconSize}px sans-serif`;
          ctx.fillText("‚õî", 0, iconSize * 0.1);
          ctx.restore();
        }

        drawTriangleIcon() {
          const iconSize = this.radius * 1.2;
          if (iconSize < 4) return;

          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.fillStyle = `rgba(0, 0, 0, ${this.opacity})`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.font = `bold ${iconSize}px sans-serif`;
          ctx.fillText("‚ö†Ô∏è", 0, 0);
          ctx.restore();
        }

        drawWrenchIcon() {
          const iconSize = this.radius * 1.2; // Match other icon sizes
          if (iconSize < 4) return;

          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.fillStyle = `rgba(0, 0, 0, ${this.opacity})`; // Black wrench emoji
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.font = `${iconSize}px sans-serif`;
          ctx.fillText("üõ†Ô∏è", 0, iconSize * 0.05); // Slight vertical adjustment for centering
          ctx.restore();
        }

        drawSkullIcon() {
          const iconSize = this.radius * 1.2;
          if (iconSize < 4) return;

          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.font = `bold ${iconSize}px sans-serif`;
          ctx.fillText("‚ò†Ô∏è", 0, iconSize * 0.1);
          ctx.restore();

          // Draw rotating danger ring around C&C node
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.rotate(this.ccRotation);

          const ringRadius = this.radius * 1.8;
          const segments = 8;

          for (let i = 0; i < segments; i++) {
            const angle = (i / segments) * Math.PI * 2;
            const nextAngle = ((i + 1) / segments) * Math.PI * 2;

            // Alternate between solid and transparent segments
            if (i % 2 === 0) {
              ctx.beginPath();
              ctx.arc(0, 0, ringRadius, angle, nextAngle);
              ctx.strokeStyle = `rgba(${colors.commandControl.r}, ${
                colors.commandControl.g
              }, ${colors.commandControl.b}, ${this.opacity * 0.8})`;
              ctx.lineWidth = 3;
              ctx.stroke();
            }
          }

          ctx.restore();
        }

        drawSpinner() {
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.rotate(this.spinnerAngle);
          ctx.strokeStyle = `rgba(255, 255, 255, ${this.opacity * 0.9})`;
          ctx.lineWidth = Math.max(1.5, this.radius * 0.2);
          ctx.beginPath();
          ctx.arc(0, 0, this.radius + 4, 0, Math.PI * 1.5);
          ctx.stroke();
          ctx.restore();
        }

        drawAntibodySpinner() {
          ctx.save();
          ctx.translate(this.x, this.y);

          const elapsed = Date.now() - this.selfHealingStartTime;
          const duration = 5000;
          const progress = Math.min(1, elapsed / duration);
          const opacity = this.opacity;

          const progressBarRadius = this.radius + 10;
          const lineWidth = 4;

          // Draw the background of the progress circle
          ctx.beginPath();
          ctx.arc(0, 0, progressBarRadius, 0, Math.PI * 2);
          ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.2})`;
          ctx.lineWidth = lineWidth;
          ctx.stroke();

          // Draw the filling progress bar
          ctx.beginPath();
          const startAngle = -Math.PI / 2; // Start from the top
          const endAngle = startAngle + progress * Math.PI * 2;
          ctx.arc(0, 0, progressBarRadius, startAngle, endAngle);
          ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
          ctx.lineWidth = lineWidth;
          ctx.lineCap = "round";
          ctx.stroke();

          ctx.restore();
        }

        drawInfectionSpinner() {
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.rotate(-this.spinnerAngle); // Rotate counter-clockwise
          ctx.strokeStyle = `rgba(${colors.malware.r}, ${colors.malware.g}, ${
            colors.malware.b
          }, ${this.opacity * 0.9})`;
          ctx.lineWidth = Math.max(1.5, this.radius * 0.2);
          ctx.beginPath();
          ctx.arc(0, 0, this.radius + 5, 0, Math.PI * 0.8);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(0, 0, this.radius + 5, Math.PI, Math.PI * 1.8);
          ctx.stroke();
          ctx.restore();
        }

        drawGroundStationCountdown() {
          ctx.save();
          ctx.translate(this.x, this.y);

          const progress = 1 - this.groundStationCountdown / 10000; // 0 to 1 (smooth)
          const opacity = this.opacity;
          const spinnerRadius = this.radius + 8;
          const lineWidth = 3;

          // Background ring
          ctx.beginPath();
          ctx.arc(0, 0, spinnerRadius, 0, Math.PI * 2);
          ctx.strokeStyle = `rgba(57, 255, 180, ${opacity * 0.2})`; // Cyan space color
          ctx.lineWidth = lineWidth;
          ctx.stroke();

          // Progress ring (fills smoothly)
          ctx.beginPath();
          const startAngle = -Math.PI / 2;
          const endAngle = startAngle + progress * Math.PI * 2;
          ctx.arc(0, 0, spinnerRadius, startAngle, endAngle);
          ctx.strokeStyle = `rgba(57, 255, 180, ${opacity * 0.9})`;
          ctx.lineWidth = lineWidth;
          ctx.lineCap = "round";
          ctx.stroke();

          // Rotating orbital dots (3 dots)
          for (let i = 0; i < 3; i++) {
            const angle = this.spinnerAngle + (i * Math.PI * 2) / 3;
            const orbitRadius = spinnerRadius + 6;
            const dotX = Math.cos(angle) * orbitRadius;
            const dotY = Math.sin(angle) * orbitRadius;

            ctx.beginPath();
            ctx.arc(dotX, dotY, 2, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(100, 200, 255, ${opacity * 0.8})`;
            ctx.fill();
          }

          // Countdown number with smooth fade transitions
          const currentSecond = Math.ceil(this.groundStationCountdown / 1000);
          const millisInCurrentSecond = this.groundStationCountdown % 1000;

          // Always show the current second number
          if (currentSecond > 0) {
            ctx.save();
            // Shrinking animation: starts large (at 999ms) and shrinks to normal (at 0ms)
            // millis goes from 999 -> 0
            // Scale from 1.5x down to 1.0x
            const scale = 1.0 + (millisInCurrentSecond / 1000) * 0.5;
            ctx.scale(scale, scale);

            ctx.font = "bold 20px monospace";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = `rgba(0, 0, 0, ${opacity})`; // Black text
            ctx.fillText(currentSecond.toString(), 0, 2); // Nudge down slightly for better visual centering
            ctx.restore();
          }

          ctx.restore();
        }

        drawGlobe() {
          ctx.save();

          const rotation = this.time * 0.008; // Slower rotation for elegance
          const tilt = Math.PI / 6; // 30 degree tilt for 3D effect

          // Atmospheric glow (outer layer)
          const gradient = ctx.createRadialGradient(
            this.x,
            this.y,
            this.radius * 0.8,
            this.x,
            this.y,
            this.radius * 1.4
          );
          gradient.addColorStop(
            0,
            `rgba(${this.currentColor.r}, ${this.currentColor.g}, ${this.currentColor.b}, 0)`
          );
          gradient.addColorStop(
            0.5,
            `rgba(${this.currentColor.r}, ${this.currentColor.g}, ${
              this.currentColor.b
            }, ${0.15 * this.opacity})`
          );
          gradient.addColorStop(
            1,
            `rgba(${this.currentColor.r}, ${this.currentColor.g}, ${this.currentColor.b}, 0)`
          );

          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius * 1.4, 0, Math.PI * 2);
          ctx.fillStyle = gradient;
          ctx.fill();

          // Inner glow for depth
          const innerGlow = ctx.createRadialGradient(
            this.x,
            this.y,
            0,
            this.x,
            this.y,
            this.radius
          );
          innerGlow.addColorStop(
            0,
            `rgba(255, 255, 255, ${0.3 * this.opacity})`
          );
          innerGlow.addColorStop(
            0.5,
            `rgba(${this.currentColor.r}, ${this.currentColor.g}, ${
              this.currentColor.b
            }, ${0.1 * this.opacity})`
          );
          innerGlow.addColorStop(
            1,
            `rgba(${this.currentColor.r}, ${this.currentColor.g}, ${this.currentColor.b}, 0)`
          );

          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fillStyle = innerGlow;
          ctx.fill();

          // Draw latitude lines (horizontal circles)
          const latitudes = 7;
          for (let i = 1; i < latitudes; i++) {
            const lat = (i / latitudes) * Math.PI - Math.PI / 2;
            const y = Math.sin(lat);
            const radiusAtLat = Math.cos(lat);

            ctx.beginPath();
            ctx.ellipse(
              this.x,
              this.y + y * this.radius * Math.cos(tilt),
              radiusAtLat * this.radius,
              radiusAtLat * this.radius * Math.sin(tilt),
              0,
              0,
              Math.PI * 2
            );
            ctx.strokeStyle = `rgba(255, 255, 255, ${this.opacity * 0.15})`;
            ctx.lineWidth = 0.5;
            ctx.stroke();
          }

          // Equator (brighter)
          ctx.beginPath();
          ctx.ellipse(
            this.x,
            this.y,
            this.radius,
            this.radius * Math.sin(tilt),
            0,
            0,
            Math.PI * 2
          );
          ctx.strokeStyle = `rgba(255, 255, 255, ${this.opacity * 0.4})`;
          ctx.lineWidth = 1;
          ctx.stroke();

          // Draw longitude meridians (rotating vertical ellipses)
          const longitudes = 12;
          for (let i = 0; i < longitudes; i++) {
            const angle = (i / longitudes) * Math.PI + rotation;

            // Calculate visibility (fade lines on the back side)
            const visibility = Math.cos(angle);
            const opacity =
              visibility > 0
                ? this.opacity * 0.3 * visibility
                : this.opacity * 0.08 * Math.abs(visibility);

            ctx.beginPath();
            ctx.ellipse(
              this.x,
              this.y,
              this.radius * Math.abs(Math.sin(angle)),
              this.radius,
              0,
              0,
              Math.PI * 2
            );
            ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
            ctx.lineWidth = visibility > 0 ? 1 : 0.5;
            ctx.stroke();
          }

          // Prime meridian (highlighted, rotating)
          const primeMeridianAngle = rotation;
          const primeVisibility = Math.cos(primeMeridianAngle);
          if (primeVisibility > 0) {
            ctx.beginPath();
            ctx.ellipse(
              this.x,
              this.y,
              this.radius * Math.abs(Math.sin(primeMeridianAngle)),
              this.radius,
              0,
              0,
              Math.PI * 2
            );
            ctx.strokeStyle = `rgba(${this.currentColor.r}, ${
              this.currentColor.g
            }, ${this.currentColor.b}, ${
              this.opacity * 0.6 * primeVisibility
            })`;
            ctx.lineWidth = 1.5;
            ctx.stroke();
          }

          // Data nodes/continents (simplified dots rotating with globe)
          const dataPoints = [
            { lat: 0.3, lon: 0 },
            { lat: -0.2, lon: 0.8 },
            { lat: 0.5, lon: 1.5 },
            { lat: -0.4, lon: 2.2 },
            { lat: 0.1, lon: 3.0 },
            { lat: 0.6, lon: 4.0 },
          ];

          dataPoints.forEach((point) => {
            const lon = point.lon + rotation;
            const lat = point.lat;

            // 3D position calculation
            const x3d = Math.cos(lat) * Math.sin(lon);
            const y3d = Math.sin(lat);
            const z3d = Math.cos(lat) * Math.cos(lon);

            // Only draw points on the visible hemisphere
            if (z3d > 0) {
              const screenX = this.x + x3d * this.radius;
              const screenY = this.y + y3d * this.radius * Math.cos(tilt);
              const size = 2 + z3d * 2; // Larger when closer
              const pointOpacity = this.opacity * z3d * 0.8;

              ctx.beginPath();
              ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
              ctx.fillStyle = `rgba(${this.currentColor.r}, ${this.currentColor.g}, ${this.currentColor.b}, ${pointOpacity})`;
              ctx.fill();

              // Subtle glow for data points
              ctx.beginPath();
              ctx.arc(screenX, screenY, size * 2, 0, Math.PI * 2);
              ctx.fillStyle = `rgba(${this.currentColor.r}, ${
                this.currentColor.g
              }, ${this.currentColor.b}, ${pointOpacity * 0.2})`;
              ctx.fill();
            }
          });

          // Defense pulse effect
          if (this.isDefending) {
            const defenseDuration = 1000;
            const elapsed = Date.now() - this.defenseStartTime;
            if (elapsed < defenseDuration) {
              const progress = elapsed / defenseDuration;
              const pulseRadius = this.radius * (1 + progress * 2);
              const pulseOpacity = (1 - progress) * this.opacity;

              ctx.beginPath();
              ctx.arc(this.x, this.y, pulseRadius, 0, Math.PI * 2);
              const redPulse = colors.red;
              ctx.strokeStyle = `rgba(${redPulse.r}, ${redPulse.g}, ${redPulse.b}, ${pulseOpacity})`;
              ctx.lineWidth = 5 * (1 - progress);
              ctx.stroke();
            } else {
              this.isDefending = false;
            }
          }

          ctx.restore();
        }

        drawBotDefenseMode() {
          // Spinning dual-ring with spokes (offensive security vibe)
          const elapsed = Date.now() - this.botDefenseModeStart;
          const spin = elapsed * 0.003;
          const pulse = 0.5 + Math.sin(elapsed * 0.01) * 0.5;
          const outerRadius =
            this.radius * (1.9 + 0.2 * Math.sin(elapsed * 0.002));
          const innerRadius = outerRadius * 0.6;
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.rotate(spin);
          // Outer ring (gold)
          ctx.beginPath();
          ctx.arc(0, 0, outerRadius, 0, Math.PI * 2);
          ctx.strokeStyle = `rgba(${colors.gold.r}, ${colors.gold.g}, ${
            colors.gold.b
          }, ${0.4 + 0.4 * pulse})`;
          ctx.lineWidth = 3;
          ctx.stroke();
          // Inner ring (white)
          ctx.beginPath();
          ctx.arc(0, 0, innerRadius, 0, Math.PI * 2);
          ctx.strokeStyle = `rgba(${colors.white.r}, ${colors.white.g}, ${
            colors.white.b
          }, ${0.25 + 0.35 * pulse})`;
          ctx.lineWidth = 2;
          ctx.stroke();
          // Spokes (blue)
          const spokes = 8;
          for (let i = 0; i < spokes; i++) {
            const a = (i / spokes) * Math.PI * 2;
            const len =
              innerRadius +
              (outerRadius - innerRadius) *
                (0.55 + 0.15 * Math.sin(elapsed * 0.004 + i));
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(Math.cos(a) * len, Math.sin(a) * len);
            ctx.strokeStyle = `rgba(${colors.blue.r}, ${colors.blue.g}, ${
              colors.blue.b
            }, ${0.3 + 0.3 * pulse})`;
            ctx.lineWidth = 1.5;
            ctx.stroke();
          }
          ctx.restore();
        }

        drawShield() {
          if (this.shieldOpacity <= 0 && !this.shieldCracking) return;

          ctx.save();
          ctx.translate(this.x, this.y);

          // Recovery shield for central node has enhanced appearance
          const isRecoveryShield =
            this.parent === null && this.hasRecoveryShield;

          // Base shield size scales with node size and strength
          let shieldRadius = this.radius * (1.8 + this.shieldStrength * 0.4);
          let shieldOpacity =
            this.shieldOpacity * this.shieldStrength * this.opacity;

          // Recovery shield is larger and more visible
          if (isRecoveryShield) {
            shieldRadius = this.radius * 2.2;
            shieldOpacity = Math.min(1.0, shieldOpacity * 1.5);
          }

          // Hexagonal shield pattern
          const sides = 6;
          const angleStep = (Math.PI * 2) / sides;
          const rotation = this.time * 0.01; // Slow rotation

          // Outer hexagon (main shield)
          ctx.beginPath();
          for (let i = 0; i <= sides; i++) {
            const angle = i * angleStep + rotation;
            const x = Math.cos(angle) * shieldRadius;
            const y = Math.sin(angle) * shieldRadius;
            if (i === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          }
          ctx.closePath();

          // Shield color - blue for recovery shield, otherwise based on status
          const shieldColor = isRecoveryShield
            ? colors.blue
            : this.status === "green"
            ? colors.green
            : colors.blue;
          const lineWidth = isRecoveryShield ? 3 : 2;
          const shadowBlur = isRecoveryShield ? 20 : 10;

          ctx.strokeStyle = `rgba(${shieldColor.r}, ${shieldColor.g}, ${
            shieldColor.b
          }, ${shieldOpacity * 0.8})`;
          ctx.lineWidth = lineWidth;
          ctx.shadowColor = `rgba(${shieldColor.r}, ${shieldColor.g}, ${shieldColor.b}, ${shieldOpacity})`;
          ctx.shadowBlur = shadowBlur;
          ctx.stroke();

          // Inner hexagon (detail)
          const innerRadius = shieldRadius * 0.7;
          ctx.beginPath();
          for (let i = 0; i <= sides; i++) {
            const angle = i * angleStep - rotation * 0.5; // Counter-rotate
            const x = Math.cos(angle) * innerRadius;
            const y = Math.sin(angle) * innerRadius;
            if (i === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          }
          ctx.closePath();
          ctx.strokeStyle = `rgba(${shieldColor.r}, ${shieldColor.g}, ${
            shieldColor.b
          }, ${shieldOpacity * 0.5})`;
          ctx.lineWidth = isRecoveryShield ? 2 : 1;
          ctx.shadowBlur = isRecoveryShield ? 10 : 5;
          ctx.stroke();

          // Connecting lines between hexagons
          ctx.shadowBlur = 0;
          for (let i = 0; i < sides; i++) {
            const angle = i * angleStep + rotation;
            const outerX = Math.cos(angle) * shieldRadius;
            const outerY = Math.sin(angle) * shieldRadius;
            const innerX = Math.cos(angle - rotation * 0.5) * innerRadius;
            const innerY = Math.sin(angle - rotation * 0.5) * innerRadius;

            ctx.beginPath();
            ctx.moveTo(innerX, innerY);
            ctx.lineTo(outerX, outerY);
            ctx.strokeStyle = `rgba(${shieldColor.r}, ${shieldColor.g}, ${
              shieldColor.b
            }, ${shieldOpacity * 0.3})`;
            ctx.lineWidth = isRecoveryShield ? 1.5 : 1;
            ctx.stroke();
          }

          // Recovery shield gets extra energy pulses
          if (isRecoveryShield) {
            const pulseProgress = (Date.now() % 2000) / 2000;
            const pulseRadius = shieldRadius * (1 + pulseProgress * 0.3);
            const pulseOpacity = (1 - pulseProgress) * shieldOpacity * 0.5;

            ctx.beginPath();
            for (let i = 0; i <= sides; i++) {
              const angle = i * angleStep + rotation;
              const x = Math.cos(angle) * pulseRadius;
              const y = Math.sin(angle) * pulseRadius;
              if (i === 0) {
                ctx.moveTo(x, y);
              } else {
                ctx.lineTo(x, y);
              }
            }
            ctx.closePath();
            ctx.strokeStyle = `rgba(${shieldColor.r}, ${shieldColor.g}, ${shieldColor.b}, ${pulseOpacity})`;
            ctx.lineWidth = 2;
            ctx.stroke();
          }

          ctx.restore();
        }

        drawCrackingShield() {
          if (this.shieldCrackProgress <= 0) return;

          ctx.save();
          ctx.translate(this.x, this.y);

          const shieldRadius = this.radius * (1.8 + this.shieldStrength * 0.4);
          const crackedOpacity = (1 - this.shieldCrackProgress) * this.opacity;
          const shieldColor =
            this.status === "green" ? colors.green : colors.blue;

          // Draw cracks
          const numCracks = 6;
          for (let i = 0; i < numCracks; i++) {
            const angle = (i / numCracks) * Math.PI * 2 + this.time * 0.01;
            const crackLength = shieldRadius * this.shieldCrackProgress * 1.5;

            ctx.beginPath();
            ctx.moveTo(0, 0);

            // Jagged crack line
            const segments = 5;
            for (let j = 1; j <= segments; j++) {
              const t = j / segments;
              const distance = crackLength * t;
              const jitter =
                (Math.random() - 0.5) * 10 * this.shieldCrackProgress;
              const x = Math.cos(angle) * distance + jitter;
              const y = Math.sin(angle) * distance + jitter;
              ctx.lineTo(x, y);
            }

            ctx.strokeStyle = `rgba(255, 100, 100, ${crackedOpacity * 0.8})`;
            ctx.lineWidth = 2;
            ctx.shadowColor = `rgba(255, 100, 100, ${crackedOpacity})`;
            ctx.shadowBlur = 8;
            ctx.stroke();
          }

          // Draw fragmenting shield pieces
          if (this.shieldFragments.length > 0) {
            this.shieldFragments.forEach((fragment) => {
              ctx.save();
              ctx.translate(fragment.x, fragment.y);
              ctx.rotate(fragment.rotation);

              ctx.beginPath();
              ctx.moveTo(fragment.points[0].x, fragment.points[0].y);
              fragment.points.slice(1).forEach((point) => {
                ctx.lineTo(point.x, point.y);
              });
              ctx.closePath();

              const fragOpacity =
                (1 - this.shieldCrackProgress) * this.opacity * 0.6;
              ctx.fillStyle = `rgba(${shieldColor.r}, ${shieldColor.g}, ${
                shieldColor.b
              }, ${fragOpacity * 0.3})`;
              ctx.fill();
              ctx.strokeStyle = `rgba(${shieldColor.r}, ${shieldColor.g}, ${shieldColor.b}, ${fragOpacity})`;
              ctx.lineWidth = 1;
              ctx.stroke();

              ctx.restore();

              // Update fragment position
              fragment.x += fragment.vx;
              fragment.y += fragment.vy;
              fragment.rotation += fragment.vr;
              fragment.vy += 0.2; // Gravity
            });
          }

          ctx.restore();
        }

        createShieldFragments() {
          this.shieldFragments = [];
          const shieldRadius = this.radius * 1.8;
          const numFragments = 8;

          for (let i = 0; i < numFragments; i++) {
            const angle = (i / numFragments) * Math.PI * 2;
            const distance = shieldRadius * 0.7;

            this.shieldFragments.push({
              x: Math.cos(angle) * distance,
              y: Math.sin(angle) * distance,
              vx: Math.cos(angle) * (1 + Math.random() * 2),
              vy: Math.sin(angle) * (1 + Math.random() * 2) - 1,
              vr: (Math.random() - 0.5) * 0.2,
              rotation: angle,
              points: [
                { x: 0, y: 0 },
                { x: Math.random() * 10 + 5, y: (Math.random() - 0.5) * 10 },
                { x: Math.random() * 5, y: Math.random() * 10 + 5 },
                { x: -(Math.random() * 5), y: Math.random() * 5 },
              ],
            });
          }
        }

        updateShield() {
          const deltaTime = 16.67; // Approximate time per frame (60fps)

          // Check if recovery shield for central node should expire
          if (this.parent === null && this.hasRecoveryShield) {
            const elapsed = Date.now() - this.recoveryShieldStartTime;
            if (elapsed >= this.recoveryShieldDuration) {
              // Shield duration complete - mark as expired and start fade
              logEvent("recoveryShieldExpired", { node: this });
              this.hasRecoveryShield = false;
            } else {
              // Recovery shield stays active and visible
              this.shieldActive = true;
              this.shieldStrength = 1.0;
              // Maintain full opacity
              if (this.shieldOpacity < 1) {
                this.shieldOpacity += 0.1;
                if (this.shieldOpacity > 1) this.shieldOpacity = 1;
              }
              return;
            }
          }

          // Handle shield fade-out after recovery shield expires
          if (
            this.parent === null &&
            !this.hasRecoveryShield &&
            this.shieldOpacity > 0
          ) {
            this.shieldOpacity -= 0.05;
            if (this.shieldOpacity <= 0) {
              this.shieldOpacity = 0;
              this.shieldActive = false;
            }
            return;
          }

          // Shield behavior based on node status
          if (
            this.status === "green" ||
            (this.parent === null &&
              this.status !== "malware" &&
              this.status !== "botnet" &&
              this.status !== "commandControl")
          ) {
            // Central node should NOT show regular shield flashes, only recovery shield
            if (this.parent === null) {
              // Central node without recovery shield has no shields
              return;
            }

            // Only regular nodes with firewall capability can show shields
            if (!this.hasFirewall) {
              // Node doesn't have firewall capability
              return;
            }

            // Healthy nodes have occasional shield flashes

            if (this.shieldCracking) {
              // Complete any cracking animation
              this.shieldCrackProgress += 0.05;
              if (this.shieldCrackProgress >= 1) {
                this.shieldCracking = false;
                this.shieldCrackProgress = 0;
                this.shieldFragments = [];
                this.shieldActive = false;
                this.shieldOpacity = 0;
              }
            } else {
              // Decrement flash timer
              this.shieldFlashTimer -= deltaTime;

              if (this.shieldFlashTimer <= 0) {
                // Start shield flash
                this.shieldActive = true;
                this.shieldStrength = 0.8 + Math.random() * 0.2; // Random strength 80-100%
                this.shieldFlashTimer = 8000 + Math.random() * 7000; // Next flash in 8-15 seconds
              }

              // Shield opacity fade in/out
              if (this.shieldActive) {
                if (this.shieldOpacity < 1) {
                  this.shieldOpacity += 0.08; // Fade in
                  if (this.shieldOpacity >= 1) {
                    this.shieldOpacity = 1;
                  }
                } else {
                  // Hold at full opacity briefly, then fade out
                  this.shieldFlashTimer -= deltaTime;
                  if (this.shieldFlashTimer < -500) {
                    // Hold for 0.5 seconds
                    this.shieldOpacity -= 0.04; // Fade out slower
                    if (this.shieldOpacity <= 0) {
                      this.shieldOpacity = 0;
                      this.shieldActive = false;
                    }
                  }
                }
              }
            }

            // If node is being infected, trigger shield crack
            if (
              this.isBeingInfected &&
              this.shieldActive &&
              !this.shieldCracking
            ) {
              this.shieldCracking = true;
              this.shieldCrackProgress = 0;
              this.createShieldFragments();
            }
          } else if (
            this.status === "malware" ||
            this.status === "botnet" ||
            this.status === "red" ||
            this.status === "yellow"
          ) {
            // Infected or compromised nodes have no shields
            if (this.shieldActive || this.shieldOpacity > 0) {
              // Immediately shatter shield if it was active
              if (!this.shieldCracking && this.shieldOpacity > 0.5) {
                this.shieldCracking = true;
                this.shieldCrackProgress = 0;
                this.createShieldFragments();
              }

              // Fast fade/crack
              if (this.shieldCracking) {
                this.shieldCrackProgress += 0.08;
                if (this.shieldCrackProgress >= 1) {
                  this.shieldCracking = false;
                  this.shieldCrackProgress = 0;
                  this.shieldFragments = [];
                  this.shieldActive = false;
                  this.shieldOpacity = 0;
                }
              } else {
                this.shieldOpacity -= 0.1;
                if (this.shieldOpacity <= 0) {
                  this.shieldOpacity = 0;
                  this.shieldActive = false;
                }
              }
            }
          }

          // During remediation, shields gradually rebuild
          if (this.remediationState === "spinning") {
            this.shieldStrength = Math.min(1.0, this.shieldStrength + 0.01);
          }
        }

        updateHeartbeat() {
          // Adjust heartbeat rate and intensity based on node status and activity
          let targetRate = 0.025; // Base rate
          let targetIntensity = 0.4; // Base intensity

          if (this.parent === null) {
            // Central node has slower, deeper breathing
            targetRate = 0.015;
            targetIntensity = 0.3;

            if (
              this.status === "malware" ||
              this.status === "botnet" ||
              this.status === "commandControl"
            ) {
              // Infected central node has erratic heartbeat
              targetRate = 0.06 + Math.sin(this.time * 0.02) * 0.03;
              targetIntensity = 0.5;
            } else if (this.isSelfHealing) {
              // Faster heartbeat during healing
              targetRate = 0.035;
              targetIntensity = 0.4;
            }
          } else {
            // Regular nodes
            switch (this.status) {
              case "green":
                targetRate = 0.025;
                targetIntensity = 0.4;
                break;
              case "yellow":
                // Stressed/warning nodes breathe faster but shallower
                targetRate = 0.04;
                targetIntensity = 0.3;
                break;
              case "red":
                // Down nodes have weak, slow pulse
                targetRate = 0.015;
                targetIntensity = 0.2;
                break;
              case "malware":
                // Infected nodes have rapid, intense pulse
                targetRate = 0.08 + Math.sin(this.time * 0.08) * 0.02;
                targetIntensity = 0.6;
                break;
            }

            // Activity modifiers
            if (this.isBeingInfected) {
              // Under attack - elevated heartbeat
              targetRate *= 1.5;
              targetIntensity *= 1.2;
            }

            if (this.isDefending) {
              // Defense response - sharp, fast pulse
              targetRate *= 1.8;
              targetIntensity *= 1.3;
            }

            if (this.remediationState === "spinning") {
              // Being healed - calming down
              targetRate *= 0.7;
              targetIntensity *= 0.8;
            }
          }

          // Smooth transition to target values
          this.heartbeatRate += (targetRate - this.heartbeatRate) * 0.1;
          this.heartbeatIntensity +=
            (targetIntensity - this.heartbeatIntensity) * 0.1;
        }

        update() {
          const colorTransitionSpeed = 0.05;
          const spawnSpeed = 0.015;

          if (this.state === "spawning") {
            this.spawnProgress += spawnSpeed;
            this.opacity = this.spawnProgress;

            if (this.spawnProgress >= 1) {
              this.spawnProgress = 1;
              // Don't snap to baseX/baseY - let physics take over smoothly from current position
              this.opacity = 1;
              this.state = "alive";
              // No position lock - forces were ramping up during spawn, continue smoothly
              this.isPositionLocked = false;
            } else if (this.parent) {
              // SMOOTH SPAWN: Interpolate from parent toward target, influenced by physics
              const t = this.spawnProgress;
              // Use cubic ease-out for smooth deceleration: 1 - (1-t)¬≥
              const eased = 1 - Math.pow(1 - t, 3);

              // Blend between spawn animation and physics-driven position
              const spawnInfluence = 1 - eased; // Decreases as spawn progresses
              const physicsInfluence = eased; // Increases as spawn progresses

              const spawnX =
                this.parent.x + (this.baseX - this.parent.x) * eased;
              const spawnY =
                this.parent.y + (this.baseY - this.parent.y) * eased;

              // Let physics forces accumulate and influence position during spawn
              // This creates smooth transition from spawn animation to physics-driven positioning
              this.x = spawnX + this.fx * physicsInfluence * 3; // Amplify physics influence during spawn
              this.y = spawnY + this.fy * physicsInfluence * 3;

              // Don't zero forces - let them ramp up during spawn
            }
          } else if (this.isSatellite && this.state === "alive") {
            // DYNAMIC SATELLITE ORBITING
            // Satellites automatically adjust their orbit to stay above the network
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;

            // Calculate target orbit radius based on network size
            // Ensure a minimum radius so they don't collapse if network is empty
            const baseNetworkRadius = Math.max(
              250,
              viewState.maxNetworkRadius || 0
            );
            const targetOrbitRadius =
              baseNetworkRadius * (this.orbitScale || 1.3);

            // Current position data
            const dx = this.x - cx;
            const dy = this.y - cy;
            const currentDist = Math.sqrt(dx * dx + dy * dy);
            const currentAngle = Math.atan2(dy, dx);

            // Smoothly adjust radius to target
            const newDist =
              currentDist + (targetOrbitRadius - currentDist) * 0.05;

            // Update angle (orbital speed)
            // Slower orbit for further out satellites to feel massive
            const orbitalSpeed =
              (this.orbitalSpeed || 0.002) * (this.orbitalDirection || 1);
            const newAngle = currentAngle + orbitalSpeed;

            // Apply new position
            this.x = cx + Math.cos(newAngle) * newDist;
            this.y = cy + Math.sin(newAngle) * newDist;

            // Update visual rotation
            this.rotation = newAngle;

            // Override physics forces
            this.fx = 0;
            this.fy = 0;
          } else if (this.state === "retracting" && this.parent) {
            if (this.children.length === 0) {
              const retractionSpeed = 0.1;
              this.x += (this.parent.x - this.x) * retractionSpeed;
              this.y += (this.parent.y - this.y) * retractionSpeed;

              this.radius *= 0.95;
              const dist = Math.sqrt(
                (this.parent.x - this.x) ** 2 + (this.parent.y - this.y) ** 2
              );
              if (dist < 5 || this.radius < 0.5) {
                this.opacity = 0;
              }
            }
          }

          // FREE-FLOATING SATELLITES: No host/parent validation needed
          // Satellites are independent orbital units - they only despawn via:
          // 1. 30-second unlinked timeout (handled in orbital mechanics)
          // 2. Going off-screen while fading

          if (this.state === "drifting") {
            if (this.isSatellite) {
              const heartbeat =
                Math.sin(this.breathingPhase) * (this.heartbeatIntensity * 0.3);
              this.baseRadius = 9;
              this.targetRadius = this.baseRadius * (1 + heartbeat);
              const targetColor = colors.satellite;
              this.currentColor.r +=
                (targetColor.r - this.currentColor.r) * colorTransitionSpeed;
              this.currentColor.g +=
                (targetColor.g - this.currentColor.g) * colorTransitionSpeed;
              this.currentColor.b +=
                (targetColor.b - this.currentColor.b) * colorTransitionSpeed;
            }

            this.x += this.driftVelocityX;
            this.y += this.driftVelocityY;
            this.driftVelocityX *= 0.995;
            this.driftVelocityY =
              (this.driftVelocityY + SATELLITE_DRIFT_GRAVITY) * 0.995;

            this.opacity = Math.max(
              0,
              this.opacity - SATELLITE_DRIFT_FADE_RATE
            );
            this.radius += (this.targetRadius - this.radius) * 0.08;

            // Off-screen despawn for drifting satellites
            if (this.isSatellite) {
              const offscreenX =
                this.x < -OFFSCREEN_MARGIN ||
                this.x > canvas.width + OFFSCREEN_MARGIN;
              const offscreenY =
                this.y < -OFFSCREEN_MARGIN ||
                this.y > canvas.height + OFFSCREEN_MARGIN;
              if (offscreenX || offscreenY) {
                this.opacity = 0; // Instant despawn when off-screen
              }
            }

            this.time += 1;
            this.spinnerAngle += 0.04;
            this.ccRotation += 0.02;
            this.breathingPhase += this.heartbeatRate * 0.5;
            return;
          }

          // FADING STATE: Satellites fading out after losing all connections
          if (this.state === "fading") {
            this.opacity = Math.max(
              0,
              this.opacity - SATELLITE_DRIFT_FADE_RATE
            );
            this.radius *= 0.98; // Shrink slightly

            // Continue orbital motion while fading
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const satToCenterX = this.x - centerX;
            const satToCenterY = this.y - centerY;
            const satDistToCenter = Math.sqrt(
              satToCenterX * satToCenterX + satToCenterY * satToCenterY
            );
            if (satDistToCenter > 10 && this.orbitalSpeed) {
              const radialX = satToCenterX / satDistToCenter;
              const radialY = satToCenterY / satDistToCenter;
              const tangentX = -radialY * (this.orbitalDirection || 1);
              const tangentY = radialX * (this.orbitalDirection || 1);
              this.x += tangentX * this.orbitalSpeed * 0.5;
              this.y += tangentY * this.orbitalSpeed * 0.5;
            }

            this.time += 1;
            this.breathingPhase += this.heartbeatRate * 0.3;
            return;
          }

          if (this.state !== "retracting") {
            // Update settling phase for gradual physics integration
            if (this.settlingPhase > 0) {
              this.settlingPhase -= 16; // Assume ~60fps (16ms per frame)
              this.physicsMultiplier =
                0.3 + 0.7 * (1 - Math.max(0, this.settlingPhase) / 2000);
            } else {
              this.physicsMultiplier = 1.0; // Fully settled
            }

            // Update heartbeat before calculating radius
            this.updateHeartbeat();

            if (this.parent === null) {
              // Central node grows with connections like other nodes, but with larger minimum
              const descendantCount = countDescendants(this);
              this.baseRadius = 15 + Math.min(descendantCount * 1.5, 10);

              // Add organic breathing effect to central node
              const heartbeat =
                Math.sin(this.breathingPhase) * this.heartbeatIntensity;
              this.targetRadius = this.baseRadius * (1 + heartbeat);

              // Add pulse effect on top
              this.targetRadius += this.pulseEffect * 28;
              this.pulseEffect *= 0.92;
              if (this.pulseEffect < 0.01) this.pulseEffect = 0;

              let targetColor = colors.blue;
              if (this.status === "malware") {
                targetColor = colors.malware;
              } else if (this.status === "botnet") {
                targetColor = colors.botnet;
              } else if (this.status === "commandControl") {
                targetColor = colors.commandControl;
              }
              this.currentColor.r +=
                (targetColor.r - this.currentColor.r) * colorTransitionSpeed;
              this.currentColor.g +=
                (targetColor.g - this.currentColor.g) * colorTransitionSpeed;
              this.currentColor.b +=
                (targetColor.b - this.currentColor.b) * colorTransitionSpeed;
            } else {
              if (this.isGroundStation) {
                this.baseRadius = 22; // Fixed larger footprint for ground stations
                const heartbeat =
                  Math.sin(this.breathingPhase) *
                  (this.heartbeatIntensity * 0.6);
                this.targetRadius = this.baseRadius * (1 + heartbeat);

                let targetColor = colors.groundStation;
                switch (this.status) {
                  case "red":
                    targetColor = colors.red;
                    break;
                  case "yellow":
                    targetColor = colors.yellow;
                    break;
                  case "malware":
                    targetColor = colors.malware;
                    break;
                  case "botnet":
                    targetColor = colors.botnet;
                    break;
                  case "commandControl":
                    targetColor = colors.commandControl;
                    break;
                  case "green":
                  default:
                    targetColor = colors.groundStation;
                    break;
                }

                this.currentColor.r +=
                  (targetColor.r - this.currentColor.r) * colorTransitionSpeed;
                this.currentColor.g +=
                  (targetColor.g - this.currentColor.g) * colorTransitionSpeed;
                this.currentColor.b +=
                  (targetColor.b - this.currentColor.b) * colorTransitionSpeed;
              } else if (this.isSatellite) {
                this.baseRadius = 10;
                const heartbeat =
                  Math.sin(this.breathingPhase) *
                  (this.heartbeatIntensity * 0.4);
                this.targetRadius = this.baseRadius * (1 + heartbeat);
                const targetColor = colors.satellite;
                this.currentColor.r +=
                  (targetColor.r - this.currentColor.r) * colorTransitionSpeed;
                this.currentColor.g +=
                  (targetColor.g - this.currentColor.g) * colorTransitionSpeed;
                this.currentColor.b +=
                  (targetColor.b - this.currentColor.b) * colorTransitionSpeed;
              } else {
                const descendantCount = countDescendants(this);
                this.baseRadius = 7 + Math.min(descendantCount * 1.5, 8);

                // Dynamic heartbeat-based pulsing based on current state
                const heartbeat =
                  Math.sin(this.breathingPhase) * this.heartbeatIntensity;

                // Malware, botnet, and C&C nodes pulse larger, not smaller
                if (
                  this.status === "malware" ||
                  this.status === "botnet" ||
                  this.status === "commandControl"
                ) {
                  this.targetRadius = this.baseRadius * (1.5 + heartbeat * 0.5); // Pulse between 1.2x and 1.8x
                } else {
                  this.targetRadius = this.baseRadius * (1 + heartbeat);
                }

                let targetColor = colors.green;
                switch (this.status) {
                  case "red":
                    targetColor = colors.red;
                    break;
                  case "yellow":
                    targetColor = colors.yellow;
                    break;
                  case "malware":
                    targetColor = colors.malware;
                    break;
                  case "botnet":
                    targetColor = colors.botnet;
                    break;
                  case "commandControl":
                    targetColor = colors.commandControl;
                    break;
                  case "green":
                    // Use neon green for firewall nodes
                    targetColor = this.hasFirewall
                      ? colors.neonGreen
                      : colors.green;
                    break;
                }
                if (this.isGuardian) {
                  targetColor = colors.white;
                }
                this.currentColor.r +=
                  (targetColor.r - this.currentColor.r) * colorTransitionSpeed;
                this.currentColor.g +=
                  (targetColor.g - this.currentColor.g) * colorTransitionSpeed;
                this.currentColor.b +=
                  (targetColor.b - this.currentColor.b) * colorTransitionSpeed;
              }
            }
          }

          this.radius += (this.targetRadius - this.radius) * 0.05;

          // Gradually ramp up force multiplier during and after spawn (0 ‚Üí 1 over spawn duration)
          if (this.state === "spawning" || this.state === "alive") {
            if (this.forceMultiplier < 1.0) {
              // Ramp up throughout spawn animation for single smooth phase
              this.forceMultiplier = Math.min(
                1.0,
                this.forceMultiplier + 0.012
              ); // Faster ramp during spawn
            }
          }

          if (this.state === "alive" && this !== draggedNode) {
            const damping = 0.85;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            if (this.parent === null && !this.isSatellite) {
              // Central node: Strong anchor to center
              this.fx += (centerX - this.x) * 0.05;
              this.fy += (centerY - this.y) * 0.05;
            } else if (this.isSatellite) {
              // FREE-FLOATING SATELLITES: No parent physics
              // Orbital mechanics are handled separately below
            } else {
              // === BETWEENNESS CENTRALITY PHYSICS ===
              // Nodes are positioned by forces, not anchored to base positions

              // 1. EDGE SPRING: Maintain ideal distance from parent
              // First generation nodes (direct children of center) have 2x distance
              const isFirstGen = this.parent.parent === null;
              const idealEdgeLength = isFirstGen ? 160 : 80; // 2x for first gen
              const springStrength = 0.02;
              const dx = this.x - this.parent.x;
              const dy = this.y - this.parent.y;
              const distToParent = Math.sqrt(dx * dx + dy * dy);

              if (distToParent > 0.1) {
                // IMPROVED: Apply forceMultiplier to spring force for smooth ramp-up
                const springForce =
                  (distToParent - idealEdgeLength) *
                  springStrength *
                  this.forceMultiplier;
                this.fx -= (dx / distToParent) * springForce;
                this.fy -= (dy / distToParent) * springForce;
              }

              // 2. SIBLING ANGULAR SEPARATION: Spread evenly around parent
              if (this.parent.children) {
                const siblings = this.parent.children.filter(
                  (s) => s !== this && s.state === "alive" && !s.isSatellite
                );
                const idealAngleSep = (Math.PI * 2) / (siblings.length + 1);
                const minAngularDist = Math.min(
                  idealAngleSep * 0.8,
                  Math.PI / 3
                );

                const myAngle = Math.atan2(
                  this.y - this.parent.y,
                  this.x - this.parent.x
                );

                for (const sibling of siblings) {
                  const sibAngle = Math.atan2(
                    sibling.y - this.parent.y,
                    sibling.x - this.parent.x
                  );
                  let angleDiff = myAngle - sibAngle;
                  // Normalize to [-PI, PI]
                  while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                  while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                  if (Math.abs(angleDiff) < minAngularDist) {
                    // Push apart angularly (perpendicular to radial direction)
                    const pushDir = angleDiff > 0 ? 1 : -1;
                    const perpX = -dy / distToParent; // Perpendicular to parent direction
                    const perpY = dx / distToParent;
                    const angularForce =
                      (minAngularDist - Math.abs(angleDiff)) *
                      0.8 *
                      this.forceMultiplier;
                    this.fx += perpX * angularForce * pushDir;
                    this.fy += perpY * angularForce * pushDir;
                  }

                  // Also push apart by distance
                  const sdx = this.x - sibling.x;
                  const sdy = this.y - sibling.y;
                  const sibDist = Math.sqrt(sdx * sdx + sdy * sdy);
                  const minSibDist = 60;

                  if (sibDist < minSibDist && sibDist > 0.1) {
                    const repelForce =
                      (minSibDist - sibDist) * 0.015 * this.forceMultiplier;
                    this.fx += (sdx / sibDist) * repelForce;
                    this.fy += (sdy / sibDist) * repelForce;
                  }
                }
              }

              // 3. OUTWARD EXPANSION FORCE: Push branches away from center toward edges
              // Counteracts compression and spreads branches for better spacing
              if (!this.isSatellite && !this.isGroundStation) {
                const toCenterX = this.x - centerX;
                const toCenterY = this.y - centerY;
                const distToCenter = Math.sqrt(
                  toCenterX * toCenterX + toCenterY * toCenterY
                );

                if (distToCenter > 0.1) {
                  // Strong outward push that increases with distance from center
                  // This prevents collapse and stretches branches toward edges
                  // Applies to ALL nodes including botnet/malware to prevent clustering
                  const expansionStrength = 0.025 * this.forceMultiplier; // Increased from 0.006
                  const distanceScale = distToCenter * 0.002; // Increased from 0.001
                  this.fx +=
                    (toCenterX / distToCenter) *
                    expansionStrength *
                    distanceScale;
                  this.fy +=
                    (toCenterY / distToCenter) *
                    expansionStrength *
                    distanceScale;
                }
              }

              // 4. CENTRALITY-BASED RADIAL POSITIONING: Organize nodes by importance
              // Use degree centrality (connection count) to determine radial distance
              if (!this.isSatellite) {
                const toCenterX = this.x - centerX;
                const toCenterY = this.y - centerY;
                const distToCenter = Math.sqrt(
                  toCenterX * toCenterX + toCenterY * toCenterY
                );

                if (distToCenter > 0.1) {
                  // Calculate degree centrality (number of connections)
                  const degree =
                    (this.children ? this.children.length : 0) +
                    (this.parent ? 1 : 0);

                  // Calculate betweenness centrality (depth in tree)
                  const depth = this.parent
                    ? this.parent.parent
                      ? this.parent.parent.parent
                        ? 3
                        : 2
                      : 1
                    : 0;

                  // Target radius based on centrality:
                  // - Higher degree (more connections) = closer to center (important hub nodes)
                  // - Higher depth = further from center (leaf nodes on periphery)
                  const baseRadius =
                    Math.min(canvas.width / 2, canvas.height / 2) -
                    padding -
                    50;
                  const centralityFactor = Math.max(0.6, 1.0 - degree * 0.08); // More connections = slight pull inward (reduced from 0.15)
                  const depthFactor = 0.4 + depth * 0.2; // Deeper = push outward (40%, 60%, 80%, 100%)
                  const targetRadius =
                    baseRadius * centralityFactor * depthFactor;

                  // Very gentle radial force (reduced from 0.003 to minimize inward pull)
                  const radialForce =
                    (targetRadius - distToCenter) *
                    0.0015 *
                    this.forceMultiplier;
                  this.fx += (toCenterX / distToCenter) * radialForce;
                  this.fy += (toCenterY / distToCenter) * radialForce;
                }
              }

              // 5. GLOBAL REPULSION: Push away from all nearby non-family nodes
              // Skip for satellites - they pass through other nodes and edges
              if (!this.isSatellite) {
                for (const other of nodes) {
                  if (
                    other === this ||
                    other === this.parent ||
                    other.state !== "alive"
                  )
                    continue;
                  if (this.children && this.children.includes(other)) continue;
                  if (other.isSatellite) continue; // Satellites pass through

                  const ox = this.x - other.x;
                  const oy = this.y - other.y;
                  const oDist = Math.sqrt(ox * ox + oy * oy);
                  const minDist = 50;

                  if (oDist < minDist && oDist > 0.1) {
                    const repelForce =
                      (minDist - oDist) * 0.008 * this.forceMultiplier;
                    this.fx += (ox / oDist) * repelForce;
                    this.fy += (oy / oDist) * repelForce;
                  }
                }
              }

              // 5. BOTNET MESH CLUSTERING: Orbital ring formation around C&C
              const isInfected =
                this.status === "malware" ||
                this.status === "botnet" ||
                this.status === "commandControl";
              if (isInfected && this.status !== "commandControl") {
                // Find C&C node this botnet is connected to
                const ccConnection = edges.find(
                  (e) =>
                    e.isBotnetMesh &&
                    ((e.from === this && e.to.status === "commandControl") ||
                      (e.to === this && e.from.status === "commandControl"))
                );

                if (ccConnection) {
                  const ccNode =
                    ccConnection.from === this
                      ? ccConnection.to
                      : ccConnection.from;

                  // Check if in migration period (5 seconds after formation)
                  const MIGRATION_DURATION = 5000;
                  const timeSinceFormation =
                    Date.now() - (this.botnetFormationTime || 0);
                  const inMigration = timeSinceFormation < MIGRATION_DURATION;
                  const migrationStrength = inMigration
                    ? Math.max(0.3, 1 - timeSinceFormation / MIGRATION_DURATION)
                    : 0.15;

                  // Find all botnets connected to this C&C
                  const allBotnets = edges
                    .filter(
                      (e) =>
                        e.isBotnetMesh && (e.from === ccNode || e.to === ccNode)
                    )
                    .map((e) => (e.from === ccNode ? e.to : e.from))
                    .filter((n) => n && n.state === "alive" && n !== this);

                  // Determine ring assignment based on mesh connection count
                  // More connections = inner ring (closer to C&C)
                  const myMeshCount = edges.filter(
                    (e) => e.isBotnetMesh && (e.from === this || e.to === this)
                  ).length;

                  // Ring radii: inner ring at 60px, outer ring at 100px
                  const INNER_RING = 55;
                  const OUTER_RING = 90;
                  const targetRadius =
                    myMeshCount >= 3 ? INNER_RING : OUTER_RING;

                  // Calculate current distance and angle from C&C
                  const dxCC = this.x - ccNode.x;
                  const dyCC = this.y - ccNode.y;
                  const distCC = Math.sqrt(dxCC * dxCC + dyCC * dyCC);

                  if (distCC > 0.1) {
                    // ORBITAL FORCE: Pull toward target ring radius
                    const radialDisplacement = distCC - targetRadius;
                    const radialForce =
                      radialDisplacement * 0.04 * migrationStrength;
                    this.fx -= (dxCC / distCC) * radialForce;
                    this.fy -= (dyCC / distCC) * radialForce;

                    // ANGULAR SEPARATION: Spread evenly around the ring
                    const myAngle = Math.atan2(dyCC, dxCC);
                    const sameRingNodes = allBotnets.filter((n) => {
                      const nMesh = edges.filter(
                        (e) => e.isBotnetMesh && (e.from === n || e.to === n)
                      ).length;
                      const nRing = nMesh >= 3 ? INNER_RING : OUTER_RING;
                      return Math.abs(nRing - targetRadius) < 20; // Same ring
                    });

                    const idealAngleSep =
                      (Math.PI * 2) / Math.max(1, sameRingNodes.length + 1);
                    const minAngularDist = Math.min(
                      idealAngleSep * 0.6,
                      Math.PI / 3
                    );

                    sameRingNodes.forEach((sibling) => {
                      const sdxCC = sibling.x - ccNode.x;
                      const sdyCC = sibling.y - ccNode.y;
                      const sibAngle = Math.atan2(sdyCC, sdxCC);

                      let angleDiff = myAngle - sibAngle;
                      while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                      while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                      if (Math.abs(angleDiff) < minAngularDist) {
                        // Push apart tangentially
                        const pushDir = angleDiff > 0 ? 1 : -1;
                        const perpX = -dyCC / distCC;
                        const perpY = dxCC / distCC;
                        const angularForce =
                          (minAngularDist - Math.abs(angleDiff)) *
                          2.0 *
                          migrationStrength;
                        this.fx += perpX * angularForce * pushDir;
                        this.fy += perpY * angularForce * pushDir;
                      }
                    });

                    // SIBLING REPULSION: Prevent overlap
                    allBotnets.forEach((sibling) => {
                      const sdx = this.x - sibling.x;
                      const sdy = this.y - sibling.y;
                      const sibDist = Math.sqrt(sdx * sdx + sdy * sdy);
                      const minSibDist = 40;

                      if (sibDist < minSibDist && sibDist > 0.1) {
                        const repelForce =
                          (minSibDist - sibDist) * 0.03 * migrationStrength;
                        this.fx += (sdx / sibDist) * repelForce;
                        this.fy += (sdy / sibDist) * repelForce;
                      }
                    });
                  }

                  // During migration, weaken tree edge constraint
                  if (inMigration && this.parent) {
                    // Counteract some of the tree spring force
                    const tdx = this.x - this.parent.x;
                    const tdy = this.y - this.parent.y;
                    const tDist = Math.sqrt(tdx * tdx + tdy * tdy);
                    if (tDist > 0.1) {
                      // Apply counter-force to tree spring (reduces its effect)
                      const counterForce = 0.015 * migrationStrength;
                      this.fx += (tdx / tDist) * counterForce * (tDist - 80);
                      this.fy += (tdy / tDist) * counterForce * (tDist - 80);
                    }
                  }
                }
              }
            }

            // BOUNDARY REPULSION (skip for satellites - they wrap around)
            if (!this.isSatellite) {
              const boundaryBuffer = 60;
              const boundaryStrength = 0.04;

              if (this.x < padding + boundaryBuffer) {
                this.fx +=
                  (padding + boundaryBuffer - this.x) * boundaryStrength;
              }
              if (this.x > canvas.width - padding - boundaryBuffer) {
                this.fx -=
                  (this.x - (canvas.width - padding - boundaryBuffer)) *
                  boundaryStrength;
              }
              if (this.y < padding + boundaryBuffer) {
                this.fy +=
                  (padding + boundaryBuffer - this.y) * boundaryStrength;
              }
              if (this.y > canvas.height - padding - boundaryBuffer) {
                this.fy -=
                  (this.y - (canvas.height - padding - boundaryBuffer)) *
                  boundaryStrength;
              }
            }

            // ORBITAL TRAJECTORY MECHANICS
            // Satellites follow circular paths and pass through all nodes effortlessly
            if (
              this.isSatellite &&
              (this.state === "alive" || this.state === "spawning")
            ) {
              // Check if in launch phase
              if (this.launchStartTime) {
                const launchElapsed = Date.now() - this.launchStartTime;
                const launchProgress = Math.min(
                  1,
                  launchElapsed / SATELLITE_LAUNCH_DURATION
                );

                if (launchProgress < 1) {
                  // LAUNCH PHASE: Curve from ground station to orbit
                  // Use cubic ease-out for smooth deceleration
                  const eased = 1 - Math.pow(1 - launchProgress, 3);

                  // Interpolate from launch position to target orbital position (elliptical)
                  const targetX =
                    centerX + Math.cos(this.orbitalAngle) * this.orbitalRadiusX;
                  const targetY =
                    centerY + Math.sin(this.orbitalAngle) * this.orbitalRadiusY;

                  const launchX = this.launchedFrom.x;
                  const launchY = this.launchedFrom.y;

                  // Curved path (add perpendicular offset for arc)
                  const midX = (launchX + targetX) / 2;
                  const midY = (launchY + targetY) / 2;
                  const perpX = -(targetY - launchY) * 0.15; // Perpendicular offset
                  const perpY = (targetX - launchX) * 0.15;

                  // Bezier-like curve: launch -> arc peak -> orbit
                  const t = eased;
                  const curveX =
                    (1 - t) * (1 - t) * launchX +
                    2 * (1 - t) * t * (midX + perpX) +
                    t * t * targetX;
                  const curveY =
                    (1 - t) * (1 - t) * launchY +
                    2 * (1 - t) * t * (midY + perpY) +
                    t * t * targetY;

                  // Set position directly during launch (no interpolation)
                  this.x = curveX;
                  this.y = curveY;
                  this.fx = 0;
                  this.fy = 0;
                } else {
                  // Launch complete, enter orbital phase
                  this.launchStartTime = null;
                }
              } else {
                // ORBITAL PHASE: Follow elliptical path matching screen shape
                // Initialize orbital parameters if not set
                if (this.orbitalAngle === undefined) {
                  this.orbitalAngle = Math.atan2(
                    this.y - centerY,
                    this.x - centerX
                  );
                }

                // Update orbital angle
                this.orbitalAngle += this.orbitalSpeed * this.orbitalDirection;

                // Calculate target position on elliptical orbit (wider east/west, narrower north/south)
                const targetX =
                  centerX + Math.cos(this.orbitalAngle) * this.orbitalRadiusX;
                const targetY =
                  centerY + Math.sin(this.orbitalAngle) * this.orbitalRadiusY;

                // Gently drift toward target position (no obstacle avoidance - pass through everything)
                this.fx += (targetX - this.x) * ORBITAL_SMOOTHING;
                this.fy += (targetY - this.y) * ORBITAL_SMOOTHING;
              }

              // Check if satellite can reach a ground station through the mesh
              const canReachGroundStation = (startSat) => {
                const visited = new Set();
                const queue = [startSat];
                while (queue.length > 0) {
                  const current = queue.shift();
                  if (visited.has(current)) continue;
                  visited.add(current);

                  // Find all wireless links for this node
                  const links = edges.filter(
                    (e) =>
                      e.isWirelessLink &&
                      (e.from === current || e.to === current)
                  );

                  for (const link of links) {
                    const neighbor =
                      link.from === current ? link.to : link.from;
                    if (!neighbor || neighbor.state !== "alive") continue;

                    // Found a ground station - mesh is connected!
                    if (neighbor.isGroundStation) return true;

                    // Add satellite neighbors to search
                    if (neighbor.isSatellite && !visited.has(neighbor)) {
                      queue.push(neighbor);
                    }
                  }
                }
                return false;
              };

              const hasGroundStationUplink = canReachGroundStation(this);

              if (!hasGroundStationUplink) {
                if (!this.unlinkTime) {
                  this.unlinkTime = Date.now();
                }
                // Gradually fade during unlink period
                const unlinkDuration = Date.now() - this.unlinkTime;
                const fadeProgress = Math.min(
                  1,
                  unlinkDuration / SATELLITE_UNLINKED_TIMEOUT
                );
                this.opacity = 1 - fadeProgress * 0.9; // Fade to 10% opacity

                if (unlinkDuration > SATELLITE_UNLINKED_TIMEOUT) {
                  // Despawn - no ground station connection for 30 seconds
                  this.state = "fading";
                  logEvent("custom", {
                    message: `üõ∞Ô∏è Satellite lost ground station uplink - despawning...`,
                  });
                }
              } else {
                this.unlinkTime = null; // Reset timer when connected to ground station
                this.opacity = 1; // Restore full opacity when uplink established
              }
            }

            // ANGULAR DAMPING: Reduce rotational momentum around center
            // Skip for satellites - they maintain lateral momentum
            if (!this.isSatellite) {
              const toCenterX = this.x - centerX;
              const toCenterY = this.y - centerY;
              const distFromCenter = Math.sqrt(
                toCenterX * toCenterX + toCenterY * toCenterY
              );

              if (distFromCenter > 10) {
                // Normalize radial direction
                const radialX = toCenterX / distFromCenter;
                const radialY = toCenterY / distFromCenter;

                // Tangential direction (perpendicular to radial)
                const tangentX = -radialY;
                const tangentY = radialX;

                // Project current force onto tangential direction
                const tangentialForce = this.fx * tangentX + this.fy * tangentY;

                // Apply gentle counter-force to reduce rotation (20% damping)
                const angularDamping = 0.2;
                this.fx -= tangentX * tangentialForce * angularDamping;
                this.fy -= tangentY * tangentialForce * angularDamping;
              }
            }

            // Apply physics forces smoothly
            this.x += this.fx;
            this.y += this.fy;

            // IMPROVED: Dynamic damping
            if (this.currentDamping < 0.85) {
              this.currentDamping += 0.005;
            }

            const effectiveDamping = this.isSatellite
              ? 0.98
              : this.currentDamping || 0.85;
            this.fx *= effectiveDamping;
            this.fy *= effectiveDamping;

            // Update base position to follow actual position (for drawing/reference)
            this.baseX = this.x;
            this.baseY = this.y;

            // Hard clamp as safety net (skip for satellites - they can orbit off-screen)
            if (!this.isSatellite) {
              const hardPadding = padding + 15;
              this.x = Math.max(
                hardPadding,
                Math.min(canvas.width - hardPadding, this.x)
              );
              this.y = Math.max(
                hardPadding,
                Math.min(canvas.height - hardPadding, this.y)
              );
            }
          }

          this.time += 1;
          this.spinnerAngle += 0.05;
          this.ccRotation += 0.02; // Rotate C&C danger ring
          this.breathingPhase += this.heartbeatRate;

          // Update shield logic
          this.updateShield();

          const SPIN_DURATION = 1200 / healSpeedMultiplier;
          const POP_DURATION = 300 / healSpeedMultiplier;

          if (this.remediationState === "spinning") {
            if (Date.now() - this.remediationStart > SPIN_DURATION) {
              this.remediationState = "popping";
              this.remediationStart = Date.now();
              createPopParticles(this.x, this.y, this.currentColor);
            }
          } else if (this.remediationState === "popping") {
            const elapsed = Date.now() - this.remediationStart;
            const progress = Math.min(1, elapsed / POP_DURATION);

            this.opacity = 1 - progress;
            this.radius = this.baseRadius * (1 - progress);

            if (progress >= 1) {
              this.remediationState = "none";
              updateNodeStatus(this, "green");
              this.opacity = 1;
              if (this.pendingDispatchPromotionCheck) {
                this.pendingDispatchPromotionCheck = false;
                if (
                  !this.isGuardian &&
                  this.state === "alive" &&
                  this.status === "green" &&
                  Math.random() < 0.1
                ) {
                  promoteToGuardian(this, "guardianPromotionDispatch");
                }
              }
            }
          }

          if (this.isSelfHealing) {
            const SELF_HEAL_DURATION = 5000;
            if (Date.now() > this.selfHealingStartTime + SELF_HEAL_DURATION) {
              this.isSelfHealing = false;
              this.selfHealingDispatchAllowance = 0;
              this.selfHealingPacketsCreated = 0;
              updateNodeStatus(this, "blue");

              // Activate recovery shield for central node
              if (this.parent === null) {
                this.hasRecoveryShield = true;
                this.recoveryShieldStartTime = Date.now();
                this.shieldActive = true;
                this.shieldOpacity = 0; // Will fade in via updateShield
                this.shieldStrength = 1.0;
                logEvent("recoveryShieldActivated", { node: this });
              }
            }
          }

          // Handle immunity healing
          if (
            this.isImmunityHealing &&
            (this.status === "malware" ||
              this.status === "botnet" ||
              this.status === "commandControl")
          ) {
            const numPackets = this.attachedImmunityPackets.length;
            if (numPackets > 0) {
              // Base healing time: 180 seconds for 1 packet (was 120s)
              // More packets = faster healing (direct division)
              // Supercharged packets count as 2 regular packets
              const BASE_HEAL_TIME = 180000 / healSpeedMultiplier; // 180 seconds

              // Count regular and supercharged packets
              let regularCount = 0;
              let superchargedCount = 0;
              this.attachedImmunityPackets.forEach((packet) => {
                if (packet.isSupercharged) {
                  superchargedCount++;
                } else {
                  regularCount++;
                }
              });

              // Calculate effective packet count (supercharged = 2x regular)
              // Reduced recovery modifier by half for slower healing
              const effectivePackets =
                (regularCount + superchargedCount * 2) / 2;
              const healTime = BASE_HEAL_TIME / effectivePackets;

              const elapsed = Date.now() - this.immunityHealingStartTime;
              if (elapsed >= healTime) {
                // Healing complete!
                // Pop all attached immunity packets
                this.attachedImmunityPackets.forEach((packet) => {
                  if (packet.active) {
                    packet.active = false;
                    createPopParticles(packet.x, packet.y, colors.white);
                  }
                });
                this.attachedImmunityPackets = [];

                // Pop the node itself with white particles
                createPopParticles(this.x, this.y, colors.white);

                // Heal the node
                this.isImmunityHealing = false;
                this.immunityHealingStartTime = 0;
                logEvent("immunityHealingCompleted", { node: this });
                // Central node heals to 'blue', other nodes to 'green'
                const healedStatus = this.parent === null ? "blue" : "green";
                updateNodeStatus(this, healedStatus);
              }
            } else {
              // No packets attached anymore, stop healing
              this.isImmunityHealing = false;
              this.immunityHealingStartTime = 0;
            }
          }

          // Handle infection logic
          this.spreadingInfections = this.spreadingInfections.filter(
            (infection) => {
              const target = infection.target;

              // An attack is cancelled if the attacker is remediated, or the target becomes invalid.
              if (
                (this.status !== "malware" &&
                  this.status !== "botnet" &&
                  this.status !== "commandControl") ||
                !target ||
                target.state !== "alive" ||
                target.status === "malware" ||
                target.status === "botnet" ||
                target.status === "commandControl"
              ) {
                if (target) target.isBeingInfected = false;
                return false; // remove this infection
              }

              const elapsed = Date.now() - infection.startTime;

              if (target.parent === null) {
                const ATTACK_DURATION = 1500;
                const DEFENSE_DELAY = 1500;
                // FIX: Check if defense has been attempted for this specific attack instance to prevent double-hits
                if (
                  elapsed > DEFENSE_DELAY &&
                  !infection.defenseTriggered &&
                  target.status !== "malware"
                ) {
                  // Mark this attack instance as having triggered a defense, preventing re-triggers.
                  infection.defenseTriggered = true;

                  // Trigger the defense pulse animation regardless of success or failure.
                  target.isDefending = true;
                  target.defenseStartTime = Date.now();

                  // Check if central node has supercharged immunity packets (requires 2 to buffer)
                  const superchargedPackets =
                    target.attachedImmunityPackets.filter(
                      (p) => p && p.isSupercharged
                    );
                  const hasDefenseResources = superchargedPackets.length >= 2;

                  // Now, determine the outcome.
                  // Recovery shield provides 99% resistance (1% failure), otherwise 10% failure
                  // Normal defense chance is NOT affected by packet availability
                  const failureChance = target.hasRecoveryShield ? 0.01 : 0.1;

                  if (target.hasRecoveryShield) {
                    logEvent("recoveryShieldAttack", { target });
                  }

                  const attackSucceeds = Math.random() < failureChance;

                  if (attackSucceeds) {
                    // Attack succeeded - check if we have packets to buffer the infection
                    if (hasDefenseResources) {
                      // Consume 2 packets to prevent infection (last-ditch buffer)
                      for (
                        let i = 0;
                        i < 2 && superchargedPackets.length > 0;
                        i++
                      ) {
                        const consumedPacket = superchargedPackets[i];
                        consumedPacket.active = false;
                        target.attachedImmunityPackets =
                          target.attachedImmunityPackets.filter(
                            (p) => p !== consumedPacket
                          );
                      }
                      logEvent("custom", {
                        message:
                          "üõ°Ô∏è Central node consumed 2 supercharged packets to buffer incoming attack!",
                      });
                    } else {
                      // No packets to buffer - infection succeeds
                      updateNodeStatus(target, "malware");
                      logEvent("centralUnderAttack"); // Warning that defense resources depleted
                      // If recovery shield was active but failed, it shatters
                      if (target.hasRecoveryShield) {
                        target.hasRecoveryShield = false;
                        target.shieldCracking = true;
                        target.shieldCrackProgress = 0;
                        target.createShieldFragments();
                      }
                    }
                  } else {
                    // Defense successful! Consume 2 supercharged immunity packets if available
                    if (hasDefenseResources) {
                      for (
                        let i = 0;
                        i < 2 && superchargedPackets.length > 0;
                        i++
                      ) {
                        const consumedPacket = superchargedPackets[i];
                        consumedPacket.active = false;
                        target.attachedImmunityPackets =
                          target.attachedImmunityPackets.filter(
                            (p) => p !== consumedPacket
                          );
                      }
                    }

                    // Spawn immunity packets if in bot defense mode
                    if (target.botDefenseModeActive) {
                      spawnCentralImmunityPackets(target);
                    }
                  }
                }
                // The infection object is removed after the attack animation (advance + retreat) is complete
                if (elapsed > ATTACK_DURATION + 1000) {
                  return false; // remove this infection
                }
              } else {
                // Regular infection timing
                const INFECTION_DURATION = 4000;
                const BASE_DEFENSE_CHANCE = 0.25;

                // Apply size-based defense bonus
                const defenseBonus = getNodeDefenseBonus(target);
                const defenseCap = target.isGuardian ? 0.95 : 0.75;
                const DEFENSE_CHANCE = Math.min(
                  BASE_DEFENSE_CHANCE + defenseBonus,
                  defenseCap
                );

                if (elapsed > INFECTION_DURATION) {
                  if (Math.random() < DEFENSE_CHANCE) {
                    target.isDefending = true;
                    target.defenseStartTime = Date.now();
                    logEvent("nodeDefended", { node: target });
                    incrementStat("totalDefenses");
                  } else {
                    updateNodeStatus(target, "malware");
                    logEvent("nodeInfected", { node: target });
                    incrementStat("totalInfections");
                  }
                  target.isBeingInfected = false;
                  return false; // remove this infection
                }
              }
              return true; // keep this infection
            }
          );
        }
      }

      class Particle {
        constructor(x, y, color) {
          this.x = x;
          this.y = y;
          const angle = Math.random() * Math.PI * 2;
          const speed = Math.random() * 3 + 1;
          this.vx = Math.cos(angle) * speed;
          this.vy = Math.sin(angle) * speed;
          this.radius = Math.random() * 2 + 1;
          this.life = 30 + Math.random() * 30; // Reduced from 50-100 to 30-60 for better performance
          this.initialLife = this.life;
          this.color = color;
        }

        update() {
          this.x += this.vx;
          this.y += this.vy;
          this.vx *= 0.98;
          this.vy *= 0.98;
          this.life -= 1;
        }

        draw() {
          if (this.life <= 0) return;
          const opacity = this.life / this.initialLife;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${opacity})`;
          ctx.fill();
        }
      }

      class DataPacket {
        constructor(edge, direction = 1) {
          this.edge = edge;
          this.direction = direction; // 1 = from->to, -1 = to->from
          this.progress = direction === 1 ? 0 : 1;
          this.active = true;

          // Calculate initial position immediately to avoid (0,0) spawn
          const fromNode = edge.from;
          const toNode = edge.to;
          if (fromNode && toNode) {
            const dx = toNode.x - fromNode.x;
            const dy = toNode.y - fromNode.y;
            const length = Math.sqrt(dx * dx + dy * dy);

            if (length > 0) {
              const baseX = fromNode.x + dx * this.progress;
              const baseY = fromNode.y + dy * this.progress;
              const perpX = -dy / length;
              const perpY = dx / length;
              const lateralOffset = direction === 1 ? 3 : -3;

              this.x = baseX + perpX * lateralOffset;
              this.y = baseY + perpY * lateralOffset;
            } else {
              // Fallback to node position if edge has zero length
              this.x = fromNode.x;
              this.y = fromNode.y;
            }
          } else {
            // Fallback if nodes are invalid
            this.x = 0;
            this.y = 0;
          }

          // Check if this is infected traffic between malware/botnet nodes
          const fromMalware =
            edge.from &&
            (edge.from.status === "malware" ||
              edge.from.status === "botnet" ||
              edge.from.status === "commandControl");
          const toMalware =
            edge.to &&
            (edge.to.status === "malware" ||
              edge.to.status === "botnet" ||
              edge.to.status === "commandControl");

          if (fromMalware && toMalware) {
            // Infected packet traveling between malware nodes
            this.type = "infected";
            this.color = { r: 168, g: 85, b: 247 }; // Purple (malware color)
            this.radius = 2;
          } else {
            // Normal packet types: 'data', 'control', 'security'
            const rand = Math.random();
            if (rand < 0.6) {
              this.type = "data";
              this.color = { r: 100, g: 200, b: 255 }; // Light blue
              this.radius = 2;
            } else if (rand < 0.85) {
              this.type = "control";
              this.color = { r: 150, g: 255, b: 150 }; // Light green
              this.radius = 2;
            } else {
              this.type = "security";
              this.color = { r: 255, g: 200, b: 100 }; // Golden
              this.radius = 2;
            }
          }

          // Calculate edge length for speed normalization using base positions
          // Use baseX/baseY since nodes might still be animating to their final positions
          const dx = edge.to.baseX - edge.from.baseX;
          const dy = edge.to.baseY - edge.from.baseY;
          const edgeLength = Math.sqrt(dx * dx + dy * dy);

          // Normalize speed: longer edges = faster progress
          // Target: ~1.0 pixel per frame at 60fps for consistent visual velocity
          const PIXELS_PER_FRAME = 1.0;

          // Base speed gives us the progress per frame
          // For consistent visual speed, adjust based on edge length
          this.baseSpeed =
            edgeLength > 0 ? PIXELS_PER_FRAME / edgeLength : 0.003;
          this.speed = this.baseSpeed * packetSpeedMultiplier;
          this.opacity = 0.8;

          // Offset to side of line for bidirectional flow
          this.lateralOffset = direction === 1 ? 3 : -3;

          // Drifting state for when edge is removed
          this.isDrifting = false;
          this.driftVelocityX = 0;
          this.driftVelocityY = 0;

          // Jitter state for unstable links
          this.jitterX = 0;
          this.jitterY = 0;

          // Drop check - only perform once per packet
          this.dropCheckPerformed = false;
        }

        update() {
          // Check if edge or nodes are invalid/removed
          const edgeExists = edges.includes(this.edge);
          const fromNodeValid =
            this.edge.from &&
            (this.edge.from.state === "alive" ||
              this.edge.from.state === "spawning");
          const toNodeValid =
            this.edge.to &&
            (this.edge.to.state === "alive" ||
              this.edge.to.state === "spawning");

          // Drop packet if edge removed or either node is retracting/drifting/dead
          if (!edgeExists || !fromNodeValid || !toNodeValid) {
            // Instantly despawn for: mesh edges, infected traffic, or migrating botnet nodes
            const isMeshEdge = this.edge.isBotnetMesh;
            const isInfectedTraffic = this.type === "infected";
            const fromMigrating =
              this.edge.from &&
              this.edge.from.botnetFormationTime &&
              Date.now() - this.edge.from.botnetFormationTime < 5000;
            const toMigrating =
              this.edge.to &&
              this.edge.to.botnetFormationTime &&
              Date.now() - this.edge.to.botnetFormationTime < 5000;

            if (
              isMeshEdge ||
              isInfectedTraffic ||
              fromMigrating ||
              toMigrating
            ) {
              this.active = false;
              return;
            }

            // Enter drifting mode with visual "packet drop" effect
            if (!this.isDrifting) {
              this.isDrifting = true;
              // Scatter in a random direction with gravity effect
              const randomAngle = Math.random() * Math.PI * 2;
              const driftSpeed = 2 + Math.random() * 3; // Faster drift for visibility
              this.driftVelocityX = Math.cos(randomAngle) * driftSpeed;
              this.driftVelocityY = Math.sin(randomAngle) * driftSpeed + 1; // Slight downward bias

              // Visual feedback: create small particle burst
              createPopParticles(this.x, this.y, this.color, 3);

              // Count as dropped packet
              if (!this.dropCheckPerformed) {
                incrementStat("packetsDropped");
                this.dropCheckPerformed = true;
              }
            }

            // Continue drifting with fade out
            if (this.isDrifting) {
              this.x += this.driftVelocityX;
              this.y += this.driftVelocityY;
              this.driftVelocityY += 0.1; // Gravity acceleration
              this.opacity -= 0.06; // Faster fade out for dropped packets

              if (this.opacity <= 0) {
                this.active = false;
              }
            } else {
              this.active = false;
            }
            return;
          }

          // Adjust speed based on link status and packet type
          const fromNode = this.edge.from;
          const toNode = this.direction === 1 ? this.edge.to : this.edge.from;

          // Don't adjust speed/opacity for drifting packets - they're fading out
          if (!this.isDrifting) {
            // Immunity packets glow bright and move fast
            if (this.type === "immunity") {
              this.speed = this.baseSpeed * 1.5 * packetSpeedMultiplier; // Faster for infected traffic
              this.opacity = 0.8; // 80% opacity
            } else if (
              toNode.status === "red" ||
              toNode.status === "malware" ||
              toNode.status === "botnet" ||
              toNode.status === "commandControl"
            ) {
              this.speed = this.baseSpeed * 0.4 * packetSpeedMultiplier; // Slow when link is compromised
              this.opacity = 0.8; // 80% opacity
            } else if (toNode.status === "yellow") {
              this.speed = this.baseSpeed * 0.7 * packetSpeedMultiplier; // Moderate when stressed
              this.opacity = 0.8; // 80% opacity
            } else {
              this.speed = this.baseSpeed * packetSpeedMultiplier; // Normal speed when healthy
              this.opacity = 0.8; // 80% opacity
            }

            // Apply DDOS slowdown to packets in affected branches
            // Helper to check if node is in a branch under DDOS (fallback if isNodeInDDOSBranch misses it)
            const checkDDOS = (n) => {
              if (isNodeInDDOSBranch(n)) return true;
              let curr = n;
              while (curr) {
                if (curr.isUnderDDOS) return true;
                curr = curr.parent;
              }
              return false;
            };

            if (checkDDOS(toNode) || checkDDOS(fromNode)) {
              // Data packets are severely slowed during DDOS
              this.speed *= 0.15; // 85% slower
              this.opacity = 0.4; // Dim to show degraded service
            }
          }

          // Calculate drop chance and jitter based on link status (only once per packet)
          if (!this.dropCheckPerformed) {
            this.dropCheckPerformed = true;

            let dropChance = 0;
            const isMalwarePacket = this.type === "infected";

            // Check link conditions
            const isDDOS =
              isNodeInDDOSBranch(toNode) || isNodeInDDOSBranch(fromNode);
            const isBotnetLink =
              toNode.status === "botnet" || fromNode.status === "botnet";
            const isMalwareLink =
              toNode.status === "malware" || fromNode.status === "malware";

            if (isDDOS && !isMalwarePacket) {
              dropChance = 0.75; // 75% drop chance during DDOS
            } else if (isBotnetLink && !isMalwarePacket) {
              dropChance = 0.5; // 50% drop chance on botnet links
            } else if (isMalwareLink && !isMalwarePacket) {
              dropChance = 0.25; // 25% drop chance on infected links
            }

            // Check for packet drop (one-time check)
            if (dropChance > 0 && Math.random() < dropChance) {
              // Packet dropped - enter drift mode
              this.isDrifting = true;
              const randomAngle = Math.random() * Math.PI * 2;
              const driftSpeed = 0.5 + Math.random() * 1;
              this.driftVelocityX = Math.cos(randomAngle) * driftSpeed;
              this.driftVelocityY = Math.sin(randomAngle) * driftSpeed;
              incrementStat("packetsDropped");
              return;
            }
          }

          // If already drifting, continue drifting
          if (this.isDrifting) {
            this.x += this.driftVelocityX;
            this.y += this.driftVelocityY;
            this.opacity -= 0.04;
            if (this.opacity <= 0) {
              this.active = false;
            }
            return;
          }

          // Apply jitter for unstable links
          let hasJitter = false;
          const isMalwarePacket = this.type === "infected";
          const isDDOS =
            isNodeInDDOSBranch(toNode) || isNodeInDDOSBranch(fromNode);
          const isBotnetLink =
            toNode.status === "botnet" || fromNode.status === "botnet";
          const isMalwareLink =
            toNode.status === "malware" || fromNode.status === "malware";

          if (!isMalwarePacket && (isDDOS || isBotnetLink || isMalwareLink)) {
            hasJitter = true;
          }

          // Apply jitter if link is unstable
          if (hasJitter) {
            // Random jitter movement perpendicular to travel direction
            const jitterAmount = 2 + Math.random() * 3; // 2-5 pixels
            this.jitterX = (Math.random() - 0.5) * jitterAmount;
            this.jitterY = (Math.random() - 0.5) * jitterAmount;
          } else {
            this.jitterX = 0;
            this.jitterY = 0;
          }

          // Only update progress if not drifting
          if (!this.isDrifting) {
            // Update progress
            if (this.direction === 1) {
              this.progress += this.speed;
              if (this.progress >= 1) {
                this.active = false;
                // Count as successfully received
                incrementStat("packetsReceived");
              }
            } else {
              this.progress -= this.speed;
              if (this.progress <= 0) {
                this.active = false;
                // Count as successfully received
                incrementStat("packetsReceived");
              }
            }
          }

          // Calculate position along the edge (reuse fromNode from above)
          // Skip if drifting - position is updated by drift velocity
          if (!this.isDrifting) {
            const toNodeDest = this.edge.to;
            const dx = toNodeDest.x - fromNode.x;
            const dy = toNodeDest.y - fromNode.y;
            const length = Math.sqrt(dx * dx + dy * dy);

            if (length > 0) {
              // Position along the line
              const baseX = fromNode.x + dx * this.progress;
              const baseY = fromNode.y + dy * this.progress;

              // Calculate perpendicular offset
              const perpX = -dy / length;
              const perpY = dx / length;

              // Apply lateral offset and jitter
              this.x = baseX + perpX * this.lateralOffset + this.jitterX;
              this.y = baseY + perpY * this.lateralOffset + this.jitterY;
            }
          }
        }

        draw() {
          if (!this.active) return;

          ctx.save();

          // Infected packets get stronger glow for visibility
          if (this.type === "infected") {
            ctx.shadowColor = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 1)`;
            ctx.shadowBlur = 8;
          } else {
            // Subtle glow for normal packets
            ctx.shadowColor = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.opacity})`;
            ctx.shadowBlur = 4;
          }

          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.opacity})`;
          ctx.fill();

          ctx.restore();
        }
      }

      Node.prototype.startRemediation = function () {
        if (this.remediationState !== "none") return;
        this.remediationState = "spinning";
        this.remediationStart = Date.now();
        logEvent("remediationStarted", { node: this });
      };

      class ImmunityPacket {
        constructor(edge, direction = 1) {
          this.edge = edge;
          this.direction = direction; // 1 = from->to, -1 = to->from
          this.progress = direction === 1 ? 0 : 1;
          this.x = 0;
          this.y = 0;
          this.active = true;
          this.color = { ...colors.white };
          this.radius = 1.5;
          this.baseSpeed = 0.003; // Standardized immunity packet speed
          this.speed = this.baseSpeed * packetSpeedMultiplier;
          this.opacity = 0.9;
          this.lateralOffset = direction === 1 ? 5 : -5;

          // Attachment state
          this.isAttached = false;
          this.attachedNode = null;
          this.attachmentAngle = 0; // Angle around the node
          this.attachmentDistance = 0; // Distance from node center

          // Smooth attachment transition
          this.isAttaching = false; // Transitioning to attached state
          this.attachTransitionProgress = 0; // 0 to 1 during attachment
          this.attachStartX = 0; // Starting position for smooth transition
          this.attachStartY = 0;

          // Seeking behavior
          this.targetNode = null; // Infected node to seek
          this.isSeeking = false;

          // Supercharged property (for burst packets from central node)
          this.isSupercharged = false;
          this.pulsePhase = Math.random() * Math.PI * 2; // Random starting phase for pulse

          // Emergency lights effect (red/white alternating like fire truck/ambulance)
          this.flashPhase = Math.random() * Math.PI * 2; // Random starting phase for variety
        }

        update() {
          // Handle smooth attachment transition
          if (this.isAttaching && this.attachedNode) {
            const isCentralNode = this.attachedNode.parent === null;
            const isInfected =
              this.attachedNode.status === "malware" ||
              this.attachedNode.status === "botnet" ||
              this.attachedNode.status === "commandControl";

            // Check if node can still hold packets
            if (!isInfected && !isCentralNode) {
              this.active = false;
              createPopParticles(this.x, this.y, this.color);
              return;
            }

            // Smoothly transition to attached position
            this.attachTransitionProgress += 0.08; // Smooth transition speed

            if (this.attachTransitionProgress >= 1) {
              // Transition complete
              this.isAttaching = false;
              this.isAttached = true;
              this.attachTransitionProgress = 1;
            }

            // Calculate target position
            const packetIndex =
              this.attachedNode.attachedImmunityPackets.indexOf(this);
            let baseAngle = 0;
            if (packetIndex !== -1) {
              const totalPackets =
                this.attachedNode.attachedImmunityPackets.length;
              baseAngle = (packetIndex / totalPackets) * Math.PI * 2;
            }

            const rotationSpeed = 0.01;
            const rotationOffset = this.attachedNode.time * rotationSpeed;
            this.attachmentAngle = baseAngle + rotationOffset;

            const distance = this.attachedNode.radius + 5;
            const targetX =
              this.attachedNode.x + Math.cos(this.attachmentAngle) * distance;
            const targetY =
              this.attachedNode.y + Math.sin(this.attachmentAngle) * distance;

            // Ease-out interpolation for smooth deceleration
            const easeProgress =
              1 - Math.pow(1 - this.attachTransitionProgress, 3);
            this.x =
              this.attachStartX + (targetX - this.attachStartX) * easeProgress;
            this.y =
              this.attachStartY + (targetY - this.attachStartY) * easeProgress;
            return;
          }

          // If attached to a node, cling to its perimeter
          if (this.isAttached && this.attachedNode) {
            const isCentralNode = this.attachedNode.parent === null;
            const isInfected =
              this.attachedNode.status === "malware" ||
              this.attachedNode.status === "botnet" ||
              this.attachedNode.status === "commandControl";

            // Check if node can still hold packets
            if (!isInfected && !isCentralNode) {
              // Node is healed (regular node) or no longer valid, packet should pop
              this.active = false;
              createPopParticles(this.x, this.y, this.color);
              return;
            }

            // Calculate base angle based on current position in the array (for even distribution)
            const packetIndex =
              this.attachedNode.attachedImmunityPackets.indexOf(this);
            let baseAngle = 0;
            if (packetIndex !== -1) {
              const totalPackets =
                this.attachedNode.attachedImmunityPackets.length;
              baseAngle = (packetIndex / totalPackets) * Math.PI * 2;
            }

            // Add slow clockwise rotation (0.01 radians per frame)
            // Use node's time for synchronized rotation
            const rotationSpeed = 0.01;
            const rotationOffset = this.attachedNode.time * rotationSpeed;
            this.attachmentAngle = baseAngle + rotationOffset;

            // Cling to the current radius of the node (which pulses)
            const distance = this.attachedNode.radius + 5;
            this.x =
              this.attachedNode.x + Math.cos(this.attachmentAngle) * distance;
            this.y =
              this.attachedNode.y + Math.sin(this.attachmentAngle) * distance;
            return;
          }

          // Check if edge or nodes are invalid/removed
          const edgeExists = edges.includes(this.edge);
          const fromNodeValid =
            this.edge.from &&
            (this.edge.from.state === "alive" ||
              this.edge.from.state === "spawning");
          const toNodeValid =
            this.edge.to &&
            (this.edge.to.state === "alive" ||
              this.edge.to.state === "spawning");

          if (!edgeExists || !fromNodeValid || !toNodeValid) {
            // Visual feedback for dropped immunity packet
            createPopParticles(this.x, this.y, this.color, 3);
            this.active = false;
            return;
          }

          // Check for nearby infected nodes to attach to
          const fromNode = this.edge.from;
          const toNode = this.edge.to;

          // Calculate current position first
          const dx = toNode.x - fromNode.x;
          const dy = toNode.y - fromNode.y;
          const length = Math.sqrt(dx * dx + dy * dy);

          if (length > 0) {
            const baseX = fromNode.x + dx * this.progress;
            const baseY = fromNode.y + dy * this.progress;
            const perpX = -dy / length;
            const perpY = dx / length;
            const offset = this.isSupercharged ? 0 : this.lateralOffset;
            this.x = baseX + perpX * offset;
            this.y = baseY + perpY * offset;
          }

          // Check if we're near a node that can collect immunity packets
          const checkNode = (node) => {
            if (node.isGuardian) {
              return false; // Guardians let immunity packets pass through
            }
            const isCentralNode = node.parent === null;
            const isInfected =
              node.status === "malware" ||
              node.status === "botnet" ||
              node.status === "commandControl";

            // If seeking a specific target, only attach to that target
            if (this.isSeeking && this.targetNode) {
              if (node !== this.targetNode) {
                // Supercharged packets no longer roam - they must hit their target
                // If they encounter a firewall node, it absorbs them
                if (
                  this.isSupercharged &&
                  node.hasFirewall &&
                  node.status === "green" &&
                  node.state === "alive"
                ) {
                  // Firewall absorbs the missed supercharged packet
                  return true; // Attach to firewall and stop
                }
                return false; // Not our target, skip
              } else {
                // Target must be infected to attach
                if (!isInfected || node.state !== "alive") {
                  // Target is no longer valid
                  // Supercharged packets are absorbed by first firewall they encounter
                  if (this.isSupercharged) {
                    // Find first firewall node to absorb
                    const firewallNode = nodes.find(
                      (n) =>
                        n.hasFirewall &&
                        n.status === "green" &&
                        n.state === "alive" &&
                        Math.sqrt((this.x - n.x) ** 2 + (this.y - n.y) ** 2) <
                          200
                    );
                    if (firewallNode) {
                      this.targetNode = firewallNode;
                      return false; // Continue seeking firewall
                    }
                  }
                  this.isSeeking = false;
                  this.targetNode = null;
                  return false;
                }
              }
            } else {
              // Normal collection logic
              // Central node can collect when healthy (blue) or infected
              // Regular nodes can only collect when infected
              const canCollect =
                node.state === "alive" &&
                ((isCentralNode && (node.status === "blue" || isInfected)) ||
                  (!isCentralNode && isInfected));

              if (!canCollect) {
                return false;
              }
            }

            // Check if node already has maximum packets (20 for central node, 20 for infected nodes, 10 for healthy nodes)
            const maxPackets = isCentralNode || isInfected ? 20 : 10;
            if (node.attachedImmunityPackets.length >= maxPackets) {
              return false; // Node is full, can't attach
            }

            const distToNode = Math.sqrt(
              (this.x - node.x) ** 2 + (this.y - node.y) ** 2
            );
            if (distToNode < node.radius + 15) {
              // Start smooth attachment transition
              this.isAttaching = true;
              this.isAttached = false; // Will become true after transition
              this.attachedNode = node;
              this.isSeeking = false; // Clear seeking state
              this.targetNode = null;
              this.attachTransitionProgress = 0;
              this.attachStartX = this.x;
              this.attachStartY = this.y;

              // Add to node's attached packets
              if (!node.attachedImmunityPackets.includes(this)) {
                node.attachedImmunityPackets.push(this);

                // Calculate initial angle based on position in array
                const packetIndex = node.attachedImmunityPackets.length - 1;
                this.attachmentAngle =
                  (packetIndex / node.attachedImmunityPackets.length) *
                  Math.PI *
                  2;

                if (isCentralNode) {
                  this.isSupercharged = true;
                  this.radius = Math.max(this.radius, 3);
                }

                // Compounding logic for infected nodes (not central node)
                if (!isCentralNode && isInfected) {
                  const currentCount = node.attachedImmunityPackets.length;

                  // Once we have more than 10 packets, convert a regular packet to supercharged
                  if (currentCount > 10 && currentCount <= 20) {
                    // Find the first regular (non-supercharged) packet to upgrade
                    const regularPacket = node.attachedImmunityPackets.find(
                      (p) => !p.isSupercharged
                    );
                    if (regularPacket) {
                      regularPacket.isSupercharged = true;
                      regularPacket.radius = Math.max(regularPacket.radius, 3);
                      logEvent("immunityPacketUpgraded", {
                        node,
                        totalPackets: currentCount,
                        superchargedCount: node.attachedImmunityPackets.filter(
                          (p) => p.isSupercharged
                        ).length,
                      });
                    }
                  }
                }

                // Start healing if infected and not already healing
                if (isInfected && !node.isImmunityHealing) {
                  node.isImmunityHealing = true;
                  node.immunityHealingStartTime = Date.now();
                  logEvent("immunityHealingStarted", {
                    node,
                    packetCount: node.attachedImmunityPackets.length,
                  });
                }
              }
              return true;
            }
            return false;
          };

          // If seeking, check target node first
          if (this.isSeeking && this.targetNode && checkNode(this.targetNode)) {
            return;
          }

          // Otherwise check nearby nodes
          if (checkNode(fromNode) || checkNode(toNode)) {
            return;
          }

          // Apply DDOS slowdown to immunity packets in affected branches
          const currentFromNode = this.edge.from;
          const currentToNode = this.edge.to;
          let effectiveSpeed = this.speed;
          if (
            isNodeInDDOSBranch(currentToNode) ||
            isNodeInDDOSBranch(currentFromNode)
          ) {
            effectiveSpeed *= 0.15; // Severely slowed during DDOS
          }

          // Normal movement along edge
          if (this.direction === 1) {
            this.progress += effectiveSpeed;
            if (this.progress >= 1) {
              const endNode = this.edge.to;

              // Check if node is dead/invalid
              if (!endNode || endNode.state !== "alive") {
                this.active = false;
                return;
              }

              // All packets try to continue forward on random routes
              // Central node consumes all packets (don't bounce back)
              if (endNode.parent === null) {
                // Packet reached central node, let it be consumed
                // It will be collected via the checkNode logic above
                this.active = false;
              } else {
                // Try to find available edges to continue (children or siblings)
                const availableEdges = edges.filter(
                  (edge) =>
                    edge.from === endNode &&
                    edge.to.state === "alive" &&
                    edge.to !== this.edge.from // Don't go back immediately
                );

                if (availableEdges.length > 0) {
                  // Pick a random edge and continue
                  const randomEdge =
                    availableEdges[
                      Math.floor(Math.random() * availableEdges.length)
                    ];
                  this.edge = randomEdge;
                  this.progress = 0;
                  this.direction = 1;
                  // Keep same lateral offset direction
                } else {
                  // No available paths forward, drop the packet
                  this.active = false;
                }
              }
            }
          } else {
            this.progress -= effectiveSpeed;
            if (this.progress <= 0) {
              const startNode = this.edge.from;

              // Check if node is dead/invalid
              if (!startNode || startNode.state !== "alive") {
                this.active = false;
                return;
              }

              // At central node, consume the packet (don't bounce back)
              if (startNode.parent === null) {
                // Packet reached central node, let it be consumed
                this.active = false;
              } else {
                // Try to find available edges (parent or siblings)
                const availableEdges = edges.filter(
                  (edge) =>
                    edge.from === startNode &&
                    edge.to.state === "alive" &&
                    edge.to !== this.edge.to // Don't go back immediately
                );

                if (availableEdges.length > 0) {
                  // Pick a random edge and continue
                  const randomEdge =
                    availableEdges[
                      Math.floor(Math.random() * availableEdges.length)
                    ];
                  this.edge = randomEdge;
                  this.progress = 0;
                  this.direction = 1;
                } else {
                  // No available paths, drop the packet
                  this.active = false;
                }
              }
            }
          }
        }

        draw() {
          if (!this.active) return;

          // Hide packet during early attachment transition to prevent flash at center
          if (this.isAttaching && this.attachTransitionProgress < 0.2) {
            return; // Don't draw until 20% through transition
          }

          ctx.save();

          // Calculate fade-in opacity during attachment transition
          let fadeMultiplier = 1.0;
          if (this.isAttaching && this.attachTransitionProgress < 0.5) {
            // Fade in from 20% to 50% of transition
            fadeMultiplier = (this.attachTransitionProgress - 0.2) / 0.3;
            fadeMultiplier = Math.max(0, Math.min(1, fadeMultiplier));
          }

          // Check if attached to central node
          const isAttachedToCentral =
            (this.isAttached || this.isAttaching) &&
            this.attachedNode &&
            this.attachedNode.parent === null;

          // Supercharged packets OR packets attached to central node pulse with neon yellow
          if (this.isSupercharged || isAttachedToCentral) {
            // Always update pulse phase for smooth animation
            if (!this.pulsePhase) this.pulsePhase = Math.random() * Math.PI * 2;
            this.pulsePhase += 0.15; // Faster pulsing
            const pulseFactor = 0.5 + Math.sin(this.pulsePhase) * 0.5; // Oscillates 0-1

            // Pulsing bright neon yellow for high visibility
            const brightYellow = { r: 255, g: 255, b: 0 }; // Pure bright yellow
            const neonYellow = { r: 255, g: 255, b: 100 }; // Slightly greenish yellow for variety
            const r =
              brightYellow.r + (neonYellow.r - brightYellow.r) * pulseFactor;
            const g =
              brightYellow.g + (neonYellow.g - brightYellow.g) * pulseFactor;
            const b =
              brightYellow.b + (neonYellow.b - brightYellow.b) * pulseFactor;

            // Intense neon glow for supercharged packets (with fade-in)
            ctx.shadowColor = `rgba(${r}, ${g}, ${b}, ${fadeMultiplier})`;
            ctx.shadowBlur = (25 + pulseFactor * 20) * fadeMultiplier; // Much brighter glow

            // Draw with pulsing neon yellow (with fade-in)
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${
              this.opacity * fadeMultiplier
            })`;
            ctx.fill();
          } else {
            // Emergency lights effect - alternate between bright red and white smoothly
            this.flashPhase += 0.15; // Fast flashing speed

            // Use sine wave to create smooth red-white-red transitions
            // Sine oscillates between -1 and 1, we map to 0-1
            const flashValue = (Math.sin(this.flashPhase) + 1) / 2; // 0 = red, 1 = white

            // Interpolate between bright pure red and white for high visibility
            const brightRed = { r: 255, g: 0, b: 0 }; // Pure bright red
            const brightWhite = { r: 255, g: 255, b: 255 }; // Pure white
            const r = brightRed.r + (brightWhite.r - brightRed.r) * flashValue;
            const g = brightRed.g + (brightWhite.g - brightRed.g) * flashValue;
            const b = brightRed.b + (brightWhite.b - brightRed.b) * flashValue;

            // Enhanced glow that pulses with the color - brighter and more intense (with fade-in)
            ctx.shadowColor = `rgba(${r}, ${g}, ${b}, ${fadeMultiplier})`;
            ctx.shadowBlur = (18 + flashValue * 12) * fadeMultiplier;

            // Draw emergency light packet (with fade-in)
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${
              this.opacity * fadeMultiplier
            })`;
            ctx.fill();
          }

          ctx.restore();
        }
      }

      function buildNodePath(origin, target) {
        const actualOrigin = origin || nodes[0];
        if (!actualOrigin || !target) return [];

        const ancestorSet = new Set();
        let current = actualOrigin;
        while (current) {
          ancestorSet.add(current);
          current = current.parent;
        }

        const downwardPath = [];
        current = target;
        while (current && !ancestorSet.has(current)) {
          downwardPath.push(current);
          current = current.parent;
        }

        if (!current) {
          return [];
        }

        const lca = current;
        const path = [];
        current = actualOrigin;
        while (current && current !== lca) {
          path.push(current);
          current = current.parent;
        }

        if (!current) {
          return [];
        }

        path.push(current); // include LCA once

        for (let i = downwardPath.length - 1; i >= 0; i--) {
          path.push(downwardPath[i]);
        }

        return path;
      }

      class DispatchPacket {
        constructor(targetNode, originNode = null) {
          this.origin = originNode || nodes[0];
          this.target = targetNode;
          this.path = buildNodePath(this.origin, targetNode);
          if (!this.path.length) {
            this.state = "finished";
            return;
          }
          this.progress = 0;
          // Standardized dispatch packet speed
          const baseSpeed = 0.006; // Consistent speed for all dispatch packets
          const pathLength = Math.max(1, this.path.length - 1); // Number of segments
          this.speed = (baseSpeed / pathLength) * packetSpeedMultiplier; // Longer paths = slower progress per frame
          this.radius = 2.5; // Dispatch packet size (reduced by 50%)
          this.x = this.path[0].x;
          this.y = this.path[0].y;
          this.state = "active";
        }

        update() {
          if (this.state !== "active") return;

          // Apply DDOS slowdown if target node is in affected branch
          let effectiveSpeed = this.speed;
          if (this.target && isNodeInDDOSBranch(this.target)) {
            effectiveSpeed *= 0.15; // Dispatch packets severely slowed during DDOS
          }

          this.progress += effectiveSpeed;

          // First, check for successful arrival
          if (this.progress >= 1) {
            this.progress = 1;
            this.state = "finished";
            this.x = this.target.x;
            this.y = this.target.y;

            if (
              this.target.remediationState === "none" &&
              this.target.state === "alive" &&
              (this.target.status === "malware" ||
                this.target.status === "botnet" ||
                this.target.status === "commandControl")
            ) {
              // C&C nodes are hardest to remediate (40%), botnet (25%), regular malware (10%)
              let baseDefenseChance = 0.1;
              if (this.target.status === "botnet") baseDefenseChance = 0.25;
              if (this.target.status === "commandControl")
                baseDefenseChance = 0.4;

              // Apply size-based defense bonus
              const defenseBonus = getNodeDefenseBonus(this.target);
              const defenseCap = this.target.isGuardian ? 0.95 : 0.75;
              const defenseChance = Math.min(
                baseDefenseChance + defenseBonus,
                defenseCap
              );

              if (Math.random() < defenseChance) {
                this.target.isDefending = true;
                this.target.defenseStartTime = Date.now();
              } else {
                this.target.startRemediation();
                // Flag for post-remediation guardian promotion check
                this.target.pendingDispatchPromotionCheck = true;
                logEvent("dispatchSuccessful", { target: this.target });
              }
            }
            return;
          }

          // For packets still in transit, calculate position and check for abort conditions
          const totalLength = this.path.length - 1;
          if (totalLength <= 0) {
            this.state = "finished";
            return;
          }

          const clampedProgress = this.progress;
          const currentSegmentIndex = Math.floor(clampedProgress * totalLength);
          const segmentProgress =
            clampedProgress * totalLength - currentSegmentIndex;
          const fromNode = this.path[currentSegmentIndex];
          const toNode = this.path[currentSegmentIndex + 1];

          // Update position before checking for failures to ensure pop happens at the right spot
          if (fromNode && toNode) {
            this.x = fromNode.x + (toNode.x - fromNode.x) * segmentProgress;
            this.y = fromNode.y + (toNode.y - fromNode.y) * segmentProgress;
          } else {
            // Fallback pop if path is somehow invalid
            createPopParticles(this.x, this.y, colors.gold);
            this.state = "finished";
            this.target.isTargeted = false;
            return;
          }

          // Check for abort conditions
          const isPhysicallyBroken = this.path.some(
            (node) => node.state === "retracting"
          );
          const remainingPath = this.path.slice(currentSegmentIndex + 1);
          const isLogicallyBlocked = remainingPath.some(
            (node) => node.status === "red" || node.status === "yellow"
          );

          // NEW: Check if any node in the path has become infected (excluding root and target)
          // Only the first infected node in a chain should be targeted, so if any upstream
          // or intermediate node becomes infected, cancel this dispatch packet
          const intermediateNodes = this.path.slice(1, -1); // All nodes except root and target
          const hasUpstreamInfection = intermediateNodes.some(
            (node) =>
              node.status === "malware" ||
              node.status === "botnet" ||
              node.status === "commandControl"
          );

          if (
            isPhysicallyBroken ||
            isLogicallyBlocked ||
            hasUpstreamInfection
          ) {
            // Only create particles if path is blocked by infection or status, not retraction
            // Retraction happens during cleanup, so we silently remove the pulse
            if (!isPhysicallyBroken) {
              createPopParticles(this.x, this.y, colors.gold);
              // Log dispatch blocked if it's due to infected nodes
              if (isLogicallyBlocked || hasUpstreamInfection) {
                logEvent("dispatchBlocked", { target: this.target });
              }
            }
            this.state = "finished";
            this.target.isTargeted = false; // Allow a new pulse to be sent
            return;
          }
        }

        draw() {
          if (this.state === "finished") return;

          // Orb color
          const goldColor = `rgba(${colors.gold.r}, ${colors.gold.g}, ${colors.gold.b}, 1)`;

          // Pulsing light effect
          const now = Date.now();
          const cycle = 1000; // Time in ms for a full red-blue pulse cycle
          const progress = (now % cycle) / cycle;

          let pulseColor, pulseRadius;

          const basePulseRadius = this.radius * 2.5;
          const pulseRange = this.radius * 2;

          if (progress < 0.5) {
            // First half: Red pulse expands and fades
            const redProgress = progress * 2;
            pulseColor = `rgba(${colors.red.r}, ${colors.red.g}, ${
              colors.red.b
            }, ${0.7 * (1 - redProgress)})`;
            pulseRadius = basePulseRadius + pulseRange * redProgress;
          } else {
            // Second half: Blue pulse expands and fades
            const blueProgress = (progress - 0.5) * 2;
            pulseColor = `rgba(${colors.blue.r}, ${colors.blue.g}, ${
              colors.blue.b
            }, ${0.7 * (1 - blueProgress)})`;
            pulseRadius = basePulseRadius + pulseRange * blueProgress;
          }

          ctx.save();

          // Draw the expanding pulse
          ctx.beginPath();
          ctx.arc(this.x, this.y, pulseRadius, 0, Math.PI * 2);
          ctx.fillStyle = pulseColor;
          ctx.fill();

          // Draw the central dispatch packet
          ctx.shadowColor = `rgba(${colors.gold.r}, ${colors.gold.g}, ${colors.gold.b}, 0.7)`;
          ctx.shadowBlur = 15;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fillStyle = goldColor;
          ctx.fill();

          ctx.restore();
        }
      }

      class PingOfDeath {
        constructor(sourceNode, targetNode) {
          this.source = sourceNode;
          this.target = targetNode;
          this.path = this.findPath(sourceNode, targetNode);
          this.progress = 0;
          // Standardized attack packet speed (Ping of Death)
          this.speed = 0.008 * packetSpeedMultiplier;
          this.radius = 6;
          this.x = sourceNode.x;
          this.y = sourceNode.y;
          this.state = "active";
          this.spikes = 8; // Number of spikes around the packet
          this.spikeRotation = 0;
          this.electricArcs = []; // Electric arc effects
          this.trail = []; // Trail to show path taken
          this.maxTrailLength = 15; // Maximum trail points
          this.lastSegmentIndex = -1; // Track which segment we're on for path recalculation
          this.checkedFirewallNodes = new Set(); // Track which firewall nodes we've already checked

          // Initialize electric arcs
          for (let i = 0; i < 3; i++) {
            this.electricArcs.push({
              angle: Math.random() * Math.PI * 2,
              length: 0,
              maxLength: this.radius * 2,
              speed: 0.3 + Math.random() * 0.3,
            });
          }
        }

        // BFS pathfinding that can traverse through any node
        findPath(start, target) {
          if (start === target) return [start];

          const queue = [[start]];
          const visited = new Set([start.id]);

          while (queue.length > 0) {
            const path = queue.shift();
            const current = path[path.length - 1];

            // Get all connected nodes (parent, children, mesh connections)
            const neighbors = [...current.children];
            if (current.parent) neighbors.push(current.parent);

            // Add mesh-connected nodes
            edges.forEach((edge) => {
              if (edge.isBotnetMesh) {
                if (edge.from === current && !neighbors.includes(edge.to)) {
                  neighbors.push(edge.to);
                } else if (
                  edge.to === current &&
                  !neighbors.includes(edge.from)
                ) {
                  neighbors.push(edge.from);
                }
              }
            });

            for (const neighbor of neighbors) {
              if (!neighbor || neighbor.state !== "alive") continue;
              if (visited.has(neighbor.id)) continue;

              visited.add(neighbor.id);
              const newPath = [...path, neighbor];

              if (neighbor === target) {
                return newPath;
              }

              queue.push(newPath);
            }
          }

          // No path found
          return null;
        }

        update() {
          // Validate source and target nodes still exist and are valid
          if (
            !this.source ||
            !this.target ||
            this.source.state === "retracting" ||
            this.source.state === "drifting" ||
            this.target.state === "retracting" ||
            this.target.state === "drifting"
          ) {
            // Path no longer valid - drop packet with visual feedback
            createPopParticles(this.x, this.y, { r: 220, g: 38, b: 38 }, 5);
            this.state = "finished";
            if (this.source && this.source.activePingOfDeath === this) {
              this.source.activePingOfDeath = null;
            }
            return;
          }

          // Update spike rotation
          this.spikeRotation += 0.1;

          // Update electric arcs
          this.electricArcs.forEach((arc) => {
            arc.length += arc.speed;
            if (arc.length > arc.maxLength) {
              arc.length = 0;
              arc.angle = Math.random() * Math.PI * 2;
            }
          });

          if (!this.path || this.path.length === 0) {
            this.state = "finished";
            if (this.source.activePingOfDeath === this) {
              this.source.activePingOfDeath = null;
            }
            return;
          }

          this.progress += this.speed;

          // Check for arrival
          if (this.progress >= 1) {
            this.progress = 1;
            this.state = "finished";
            this.x = this.target.x;
            this.y = this.target.y;

            // Clear source's active ping
            if (this.source.activePingOfDeath === this) {
              this.source.activePingOfDeath = null;
            }

            // Apply ping of death effect
            if (this.target.state === "alive" && this.target.parent !== null) {
              const targetType = this.target.isGuardian
                ? "Guardian"
                : this.target.hasFirewall
                ? "Firewall node"
                : "node";
              logEvent("pingOfDeathHit", { target: this.target, targetType });
              incrementStat("pingDeaths");

              // Put in red (down) state (ping of death bypasses grace period)
              updateNodeStatus(this.target, "red");

              // Mark node as hit by ping of death (increases malware conversion chance)
              this.target.hitByPingOfDeath = true;
              this.target.pingOfDeathTime = Date.now();

              // Visual effect with red particles (matching ping animation color)
              createPopParticles(this.target.x, this.target.y, {
                r: 220,
                g: 38,
                b: 38,
              });
            }
            return;
          }

          // Calculate position along path
          const totalLength = this.path.length - 1;
          if (totalLength <= 0) {
            this.state = "finished";
            if (this.source.activePingOfDeath === this) {
              this.source.activePingOfDeath = null;
            }
            return;
          }

          const clampedProgress = this.progress;
          const currentSegmentIndex = Math.floor(clampedProgress * totalLength);
          const segmentProgress =
            clampedProgress * totalLength - currentSegmentIndex;
          const fromNode = this.path[currentSegmentIndex];
          const toNode = this.path[currentSegmentIndex + 1];

          // Validate current segment nodes are still valid
          if (
            !fromNode ||
            !toNode ||
            fromNode.state === "retracting" ||
            fromNode.state === "drifting" ||
            toNode.state === "retracting" ||
            toNode.state === "drifting"
          ) {
            // Current segment invalid - try to recalculate path
            const newPath = this.findPath(this.source, this.target);
            if (!newPath || newPath.length === 0) {
              // No valid path - drop packet
              createPopParticles(this.x, this.y, { r: 220, g: 38, b: 38 }, 5);
              this.state = "finished";
              if (this.source.activePingOfDeath === this) {
                this.source.activePingOfDeath = null;
              }
              return;
            }
            // Use new path and restart from beginning
            this.path = newPath;
            this.progress = 0;
            this.lastSegmentIndex = -1;
            return;
          }

          // Recalculate path when transitioning to a new segment to handle topology changes
          // Only recalculate if we've moved significantly (at least crossed into next segment)
          if (
            this.lastSegmentIndex !== undefined &&
            this.lastSegmentIndex !== currentSegmentIndex
          ) {
            // We've moved to a new segment - recalculate from current node
            if (
              fromNode &&
              fromNode !== this.target &&
              fromNode.state === "alive"
            ) {
              const newPath = this.findPath(fromNode, this.target);
              if (newPath && newPath.length > 1) {
                // Update to use the new path from current position
                this.path = newPath;
                // Adjust progress to continue smoothly from current position
                // Start at beginning of new path (fromNode to next node)
                this.progress = segmentProgress / (newPath.length - 1);
                this.lastSegmentIndex = 0; // Reset to start of new path
                return; // Restart update with recalculated values
              }
            }
          }

          // Track current segment for next frame
          this.lastSegmentIndex = currentSegmentIndex;

          // Check for firewall blocking (50%, 90% if guardian)
          if (
            fromNode &&
            fromNode.hasFirewall &&
            fromNode.status === "green" &&
            !this.checkedFirewallNodes.has(fromNode.id) &&
            fromNode !== this.source
          ) {
            // Mark this firewall node as checked
            this.checkedFirewallNodes.add(fromNode.id);

            // Guardians are elite defenders with a higher block probability
            const pingBlockChance = fromNode.isGuardian ? 0.9 : 0.5;

            if (Math.random() < pingBlockChance) {
              logEvent("firewallBlockedPing", { firewallNode: fromNode });
              incrementStat("totalDefenses");

              // Trigger defense pulse on the firewall node
              fromNode.isDefending = true;
              fromNode.defenseStartTime = Date.now();

              // Create visual effect at firewall node
              createPopParticles(fromNode.x, fromNode.y, colors.neonGreen);

              // Guardian Counter-Strike: 50% chance to traceback
              if (fromNode.isGuardian && Math.random() < 0.5) {
                const counterStrike = new CounterStrikePacket(
                  fromNode,
                  this.source,
                  this.path
                );
                counterStrikePackets.push(counterStrike);
                logEvent("custom", {
                  message: `‚ö° Guardian ${fromNode.id} launched counter-strike traceback!`,
                });
              }

              // Block the packet
              this.state = "finished";
              if (this.source.activePingOfDeath === this) {
                this.source.activePingOfDeath = null;
              }
              return;
            }
          }

          if (fromNode && toNode) {
            this.x = fromNode.x + (toNode.x - fromNode.x) * segmentProgress;
            this.y = fromNode.y + (toNode.y - fromNode.y) * segmentProgress;

            // Add current position to trail
            this.trail.push({ x: this.x, y: this.y, age: 0 });

            // Limit trail length
            if (this.trail.length > this.maxTrailLength) {
              this.trail.shift();
            }
          }

          // Age the trail points
          this.trail.forEach((point) => point.age++);

          // Check for abort conditions (similar to dispatch packet)
          // Target decayed or no longer exists
          const targetInvalid =
            !this.target ||
            this.target.state !== "alive" ||
            this.target.state === "retracting";

          // Path is physically broken (any node is retracting or not alive)
          const isPathBroken = this.path.some(
            (node) => node.state === "retracting" || node.state !== "alive"
          );

          if (targetInvalid || isPathBroken) {
            // Pop with red particles (same red as the ping animation)
            createPopParticles(this.x, this.y, { r: 220, g: 38, b: 38 });
            this.state = "finished";
            if (this.source.activePingOfDeath === this) {
              this.source.activePingOfDeath = null;
            }
          }
        }

        draw() {
          if (this.state === "finished") return;

          ctx.save();

          // Draw trail first (behind the packet)
          if (this.trail.length > 1) {
            for (let i = 0; i < this.trail.length - 1; i++) {
              const point = this.trail[i];
              const nextPoint = this.trail[i + 1];

              // Calculate opacity based on age (older = more faded)
              const maxAge = this.maxTrailLength;
              const opacity = Math.max(0, 1 - point.age / maxAge) * 0.6;

              // Draw line segment
              ctx.strokeStyle = `rgba(220, 38, 38, ${opacity})`; // Red trail
              ctx.lineWidth = 3;
              ctx.lineCap = "round";
              ctx.beginPath();
              ctx.moveTo(point.x, point.y);
              ctx.lineTo(nextPoint.x, nextPoint.y);
              ctx.stroke();
            }
          }

          ctx.translate(this.x, this.y);

          // Draw expanding red shockwave
          const shockwaveRadius = this.radius * 3;
          const shockwaveGradient = ctx.createRadialGradient(
            0,
            0,
            0,
            0,
            0,
            shockwaveRadius
          );
          shockwaveGradient.addColorStop(0, "rgba(220, 38, 38, 0.4)"); // Brighter red
          shockwaveGradient.addColorStop(0.5, "rgba(139, 0, 0, 0.3)");
          shockwaveGradient.addColorStop(1, "rgba(0, 0, 0, 0)");
          ctx.fillStyle = shockwaveGradient;
          ctx.beginPath();
          ctx.arc(0, 0, shockwaveRadius, 0, Math.PI * 2);
          ctx.fill();

          // Draw electric arcs (red)
          this.electricArcs.forEach((arc) => {
            const arcProgress = arc.length / arc.maxLength;
            const arcOpacity = Math.sin(arcProgress * Math.PI) * 0.9;
            const endX = Math.cos(arc.angle) * arc.length;
            const endY = Math.sin(arc.angle) * arc.length;

            ctx.strokeStyle = `rgba(220, 38, 38, ${arcOpacity})`; // Brighter red arcs
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(endX, endY);
            ctx.stroke();
          });

          // Draw red spiked core
          ctx.rotate(this.spikeRotation);
          ctx.fillStyle = "rgba(139, 0, 0, 0.95)"; // Dark red instead of black
          ctx.shadowColor = "rgba(220, 38, 38, 1)"; // Bright red glow
          ctx.shadowBlur = 20;

          // Draw spiky polygon
          ctx.beginPath();
          for (let i = 0; i < this.spikes; i++) {
            const angle = (i / this.spikes) * Math.PI * 2;
            const nextAngle = ((i + 1) / this.spikes) * Math.PI * 2;

            // Inner point
            const innerRadius = this.radius * 0.6;
            const innerX = Math.cos(angle) * innerRadius;
            const innerY = Math.sin(angle) * innerRadius;

            // Outer spike point
            const midAngle = (angle + nextAngle) / 2;
            const outerX = Math.cos(midAngle) * this.radius * 1.5;
            const outerY = Math.sin(midAngle) * this.radius * 1.5;

            if (i === 0) {
              ctx.moveTo(innerX, innerY);
            } else {
              ctx.lineTo(innerX, innerY);
            }
            ctx.lineTo(outerX, outerY);
          }
          ctx.closePath();
          ctx.fill();

          // Draw bright red inner core
          const innerGlow = ctx.createRadialGradient(
            0,
            0,
            0,
            0,
            0,
            this.radius * 0.5
          );
          innerGlow.addColorStop(0, "rgba(255, 70, 70, 1)"); // Bright red center
          innerGlow.addColorStop(1, "rgba(220, 38, 38, 0.8)");
          ctx.shadowBlur = 0;
          ctx.fillStyle = innerGlow;
          ctx.beginPath();
          ctx.arc(0, 0, this.radius * 0.5, 0, Math.PI * 2);
          ctx.fill();

          ctx.restore();
        }
      }

      class PhishPacket {
        constructor(sourceNode, targetNode) {
          this.source = sourceNode;
          this.target = targetNode;
          this.path = this.findPath(sourceNode, targetNode);
          this.progress = 0;
          this.speed = 0.008 * packetSpeedMultiplier; // Standardized phishing packet speed
          this.radius = 6;
          this.x = sourceNode.x;
          this.y = sourceNode.y;
          this.state = "active";
          this.spikes = 8;
          this.spikeRotation = 0;
          this.electricArcs = [];
          this.trail = [];
          this.maxTrailLength = 15;
          this.lastSegmentIndex = -1;

          // Initialize electric arcs
          for (let i = 0; i < 3; i++) {
            this.electricArcs.push({
              angle: Math.random() * Math.PI * 2,
              length: 0,
              maxLength: this.radius * 2,
              speed: 0.3 + Math.random() * 0.3,
            });
          }
        }

        // BFS pathfinding (same as PingOfDeath)
        findPath(start, target) {
          if (start === target) return [start];

          const queue = [[start]];
          const visited = new Set([start.id]);

          while (queue.length > 0) {
            const path = queue.shift();
            const current = path[path.length - 1];

            const neighbors = [...current.children];
            if (current.parent) neighbors.push(current.parent);

            edges.forEach((edge) => {
              if (edge.isBotnetMesh) {
                if (edge.from === current && !neighbors.includes(edge.to)) {
                  neighbors.push(edge.to);
                } else if (
                  edge.to === current &&
                  !neighbors.includes(edge.from)
                ) {
                  neighbors.push(edge.from);
                }
              }
            });

            for (const neighbor of neighbors) {
              if (!neighbor || neighbor.state !== "alive") continue;
              if (visited.has(neighbor.id)) continue;

              visited.add(neighbor.id);
              const newPath = [...path, neighbor];

              if (neighbor === target) {
                return newPath;
              }

              queue.push(newPath);
            }
          }

          return null;
        }

        update() {
          if (this.state !== "active") return;

          // Validate source and target nodes still exist and are valid
          if (
            !this.source ||
            !this.target ||
            this.source.state === "retracting" ||
            this.source.state === "drifting" ||
            this.target.state === "retracting" ||
            this.target.state === "drifting"
          ) {
            // Path no longer valid - drop packet with visual feedback
            createPopParticles(this.x, this.y, colors.malware, 5);
            this.state = "finished";
            return;
          }

          this.spikeRotation += 0.1;

          this.electricArcs.forEach((arc) => {
            arc.length += arc.speed;
            if (arc.length > arc.maxLength) {
              arc.length = 0;
              arc.angle = Math.random() * Math.PI * 2;
            }
          });

          if (!this.path || this.path.length === 0) {
            this.state = "finished";
            return;
          }

          this.progress += this.speed;

          // Check for arrival
          if (this.progress >= 1) {
            this.progress = 1;
            this.state = "finished";
            this.x = this.target.x;
            this.y = this.target.y;

            // Apply phishing infection attempt
            if (
              this.target.state === "alive" &&
              this.target.parent !== null &&
              this.target.status === "green"
            ) {
              // Special block chances for defenders
              let blocked = false;
              let defenderType = "";
              if (this.target.isGuardian) {
                blocked = Math.random() < 0.5;
                defenderType = "Guardian";
              } else if (
                this.target.hasFirewall &&
                this.target.shieldStrength > 0
              ) {
                blocked = Math.random() < 0.25;
                defenderType = "Firewall";
              }

              if (blocked) {
                // Phishing blocked by Guardian or Firewall
                logEvent("phishingBlocked", {
                  node: this.target,
                  defender: defenderType,
                });
                incrementStat("totalDefenses");
                createPopParticles(
                  this.target.x,
                  this.target.y,
                  colors.malware
                ); // Purple particles

                // Guardian Counter-Strike: 50% chance to traceback
                if (this.target.isGuardian && Math.random() < 0.5) {
                  const counterStrike = new CounterStrikePacket(
                    this.target,
                    this.source,
                    this.path
                  );
                  counterStrikePackets.push(counterStrike);
                  logEvent("custom", {
                    message: `‚ö° Guardian ${this.target.id} launched counter-strike traceback!`,
                  });
                }
              } else {
                // Node defended against phishing
                this.target.isDefending = true;
                this.target.defenseStartTime = Date.now();
                createPopParticles(
                  this.target.x,
                  this.target.y,
                  colors.malware
                ); // Purple particles
                logEvent("phishingDefended", { node: this.target });

                trySpawnGuardian(this.target);

                // Phishing successful - infect node
                updateNodeStatus(this.target, "malware");
                logEvent("phishingSuccess", { target: this.target });
                incrementStat("phishSuccess");
                incrementStat("totalInfections");
              }
            }
            return;
          }

          // Calculate position along path
          const totalLength = this.path.length - 1;
          if (totalLength <= 0) {
            this.state = "finished";
            return;
          }

          const clampedProgress = this.progress;
          const currentSegmentIndex = Math.floor(clampedProgress * totalLength);
          const segmentProgress =
            clampedProgress * totalLength - currentSegmentIndex;
          const fromNode = this.path[currentSegmentIndex];
          const toNode = this.path[currentSegmentIndex + 1];

          // Validate current segment nodes are still valid
          if (
            !fromNode ||
            !toNode ||
            fromNode.state === "retracting" ||
            fromNode.state === "drifting" ||
            toNode.state === "retracting" ||
            toNode.state === "drifting"
          ) {
            // Current segment invalid - try to recalculate path
            const newPath = this.findPath(this.source, this.target);
            if (!newPath || newPath.length === 0) {
              // No valid path - drop packet
              createPopParticles(this.x, this.y, colors.malware, 5);
              this.state = "finished";
              return;
            }
            // Use new path and restart from beginning
            this.path = newPath;
            this.progress = 0;
            this.lastSegmentIndex = -1;
            return;
          }

          // Recalculate path when transitioning to a new segment
          if (
            this.lastSegmentIndex !== undefined &&
            this.lastSegmentIndex !== currentSegmentIndex
          ) {
            // We've moved to a new segment - recalculate from current node
            if (
              fromNode &&
              fromNode !== this.target &&
              fromNode.state === "alive"
            ) {
              const newPath = this.findPath(fromNode, this.target);
              if (newPath && newPath.length > 1) {
                // Update to use the new path from current position
                this.path = newPath;
                // Adjust progress to continue smoothly from current position
                // Start at beginning of new path (fromNode to next node)
                this.progress = segmentProgress / (newPath.length - 1);
                this.lastSegmentIndex = 0; // Reset to start of new path
                return; // Restart update with recalculated values
              }
            }
          }

          this.lastSegmentIndex = currentSegmentIndex;

          if (fromNode && toNode) {
            this.x = fromNode.x + (toNode.x - fromNode.x) * segmentProgress;
            this.y = fromNode.y + (toNode.y - fromNode.y) * segmentProgress;

            this.trail.push({ x: this.x, y: this.y, age: 0 });

            if (this.trail.length > this.maxTrailLength) {
              this.trail.shift();
            }
          }

          this.trail.forEach((point) => point.age++);

          // Check for abort conditions
          const targetInvalid =
            !this.target ||
            this.target.state !== "alive" ||
            this.target.state === "retracting";
          const isPathBroken = this.path.some(
            (node) => node.state === "retracting" || node.state !== "alive"
          );

          if (targetInvalid || isPathBroken) {
            createPopParticles(this.x, this.y, colors.malware); // Purple particles
            this.state = "finished";
          }
        }

        draw() {
          if (this.state === "finished") return;

          ctx.save();

          // Draw purple trail
          if (this.trail.length > 1) {
            for (let i = 0; i < this.trail.length - 1; i++) {
              const point = this.trail[i];
              const nextPoint = this.trail[i + 1];

              const maxAge = this.maxTrailLength;
              const opacity = Math.max(0, 1 - point.age / maxAge) * 0.6;

              ctx.strokeStyle = `rgba(168, 85, 247, ${opacity})`; // Purple trail
              ctx.lineWidth = 3;
              ctx.lineCap = "round";
              ctx.beginPath();
              ctx.moveTo(point.x, point.y);
              ctx.lineTo(nextPoint.x, nextPoint.y);
              ctx.stroke();
            }
          }

          ctx.translate(this.x, this.y);

          // Draw purple shockwave
          const shockwaveRadius = this.radius * 3;
          const shockwaveGradient = ctx.createRadialGradient(
            0,
            0,
            0,
            0,
            0,
            shockwaveRadius
          );
          shockwaveGradient.addColorStop(0, "rgba(168, 85, 247, 0.4)");
          shockwaveGradient.addColorStop(0.5, "rgba(124, 58, 237, 0.3)");
          shockwaveGradient.addColorStop(1, "rgba(0, 0, 0, 0)");
          ctx.fillStyle = shockwaveGradient;
          ctx.beginPath();
          ctx.arc(0, 0, shockwaveRadius, 0, Math.PI * 2);
          ctx.fill();

          // Draw purple electric arcs
          this.electricArcs.forEach((arc) => {
            const arcProgress = arc.length / arc.maxLength;
            const arcOpacity = Math.sin(arcProgress * Math.PI) * 0.9;
            const endX = Math.cos(arc.angle) * arc.length;
            const endY = Math.sin(arc.angle) * arc.length;

            ctx.strokeStyle = `rgba(168, 85, 247, ${arcOpacity})`;
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(endX, endY);
            ctx.stroke();
          });

          // Draw purple spiked core
          ctx.rotate(this.spikeRotation);
          ctx.fillStyle = "rgba(124, 58, 237, 0.95)";
          ctx.shadowColor = "rgba(168, 85, 247, 1)";
          ctx.shadowBlur = 20;

          ctx.beginPath();
          for (let i = 0; i < this.spikes; i++) {
            const angle = (i / this.spikes) * Math.PI * 2;
            const nextAngle = ((i + 1) / this.spikes) * Math.PI * 2;

            const innerRadius = this.radius * 0.6;
            const innerX = Math.cos(angle) * innerRadius;
            const innerY = Math.sin(angle) * innerRadius;

            const midAngle = (angle + nextAngle) / 2;
            const outerX = Math.cos(midAngle) * this.radius * 1.5;
            const outerY = Math.sin(midAngle) * this.radius * 1.5;

            if (i === 0) {
              ctx.moveTo(innerX, innerY);
            } else {
              ctx.lineTo(innerX, innerY);
            }
            ctx.lineTo(outerX, outerY);
          }
          ctx.closePath();
          ctx.fill();

          // Draw bright purple inner core
          const innerGlow = ctx.createRadialGradient(
            0,
            0,
            0,
            0,
            0,
            this.radius * 0.5
          );
          innerGlow.addColorStop(0, "rgba(192, 132, 252, 1)");
          innerGlow.addColorStop(1, "rgba(168, 85, 247, 0.8)");
          ctx.shadowBlur = 0;
          ctx.fillStyle = innerGlow;
          ctx.beginPath();
          ctx.arc(0, 0, this.radius * 0.5, 0, Math.PI * 2);
          ctx.fill();

          ctx.restore();
        }
      }

      // Counter-Strike Packet - Guardian traceback attack
      class CounterStrikePacket {
        constructor(guardianNode, targetNode, attackPath) {
          this.guardian = guardianNode;
          this.target = targetNode;
          // Reverse the attack path for traceback
          this.path = attackPath ? [...attackPath].reverse() : null;
          this.progress = 0;
          this.speed = 0.012 * packetSpeedMultiplier; // Standardized counter-strike speed (faster than attacks)
          this.radius = 5;
          this.x = guardianNode.x;
          this.y = guardianNode.y;
          this.state = "active";
          this.color = { r: 96, g: 165, b: 250 }; // Bright blue
          this.trail = [];
          this.maxTrailLength = 20;
          this.lightning = [];
          this.lightningUpdateCounter = 0;
        }

        update() {
          if (this.state !== "active") return;

          if (!this.path || this.path.length === 0) {
            this.state = "finished";
            return;
          }

          this.progress += this.speed;

          // Check for arrival at target
          if (this.progress >= 1) {
            this.progress = 1;
            this.state = "finished";
            this.x = this.target.x;
            this.y = this.target.y;

            // Apply counter-strike effect on arrival
            if (this.target.state === "alive") {
              const previousStatus = this.target.status;

              // Downgrade the infected node
              if (this.target.status === "commandControl") {
                this.target.status = "botnet";
                logEvent("custom", {
                  message: `‚ö° Counter-strike downgraded C&C node ${this.target.id} to botnet!`,
                });
              } else if (this.target.status === "botnet") {
                this.target.status = "malware";
                logEvent("custom", {
                  message: `‚ö° Counter-strike downgraded botnet ${this.target.id} to malware!`,
                });
              } else if (this.target.status === "malware") {
                this.target.status = "green";
                this.target.isImmunityHealing = false;
                this.target.attachedImmunityPackets = [];
                incrementStat("totalRecoveries");
                logEvent("custom", {
                  message: `‚ö° Counter-strike cleansed node ${this.target.id}!`,
                });
              }

              this.target.statusChangeTime = Date.now();

              // Visual feedback
              createPopParticles(this.target.x, this.target.y, this.color);
            }
            return;
          }

          // Calculate position along path
          const totalLength = this.path.length - 1;
          if (totalLength <= 0) {
            this.state = "finished";
            return;
          }

          const currentSegmentIndex = Math.floor(this.progress * totalLength);
          const segmentProgress =
            this.progress * totalLength - currentSegmentIndex;
          const fromNode = this.path[currentSegmentIndex];
          const toNode = this.path[currentSegmentIndex + 1];

          if (fromNode && toNode) {
            this.x = fromNode.x + (toNode.x - fromNode.x) * segmentProgress;
            this.y = fromNode.y + (toNode.y - fromNode.y) * segmentProgress;

            // Add to trail
            this.trail.unshift({ x: this.x, y: this.y });
            if (this.trail.length > this.maxTrailLength) {
              this.trail.pop();
            }

            // Generate lightning effect periodically
            this.lightningUpdateCounter++;
            if (this.lightningUpdateCounter % 3 === 0) {
              this.lightning = [];
              for (let i = 0; i < 4; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = this.radius + Math.random() * 15;
                this.lightning.push({
                  x: this.x + Math.cos(angle) * dist,
                  y: this.y + Math.sin(angle) * dist,
                });
              }
            }
          }
        }

        draw() {
          if (this.state !== "active") return;

          ctx.save();

          // Draw lightning arcs
          ctx.strokeStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0.4)`;
          ctx.lineWidth = 1.5;
          this.lightning.forEach((bolt) => {
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(bolt.x, bolt.y);
            ctx.stroke();
          });

          // Draw trail
          for (let i = 0; i < this.trail.length; i++) {
            const opacity = (1 - i / this.trail.length) * 0.6;
            const size = this.radius * (1 - i / this.trail.length);
            ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${opacity})`;
            ctx.beginPath();
            ctx.arc(this.trail[i].x, this.trail[i].y, size, 0, Math.PI * 2);
            ctx.fill();
          }

          // Draw main packet with glow
          ctx.shadowColor = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 1)`;
          ctx.shadowBlur = 15;
          ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 1)`;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fill();

          // Draw inner white core
          ctx.shadowBlur = 0;
          ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius * 0.5, 0, Math.PI * 2);
          ctx.fill();

          ctx.restore();
        }
      }

      function randomRange(min, max) {
        return Math.random() * (max - min) + min;
      }

      function initializeGalaxy() {
        galaxyStars.length = 0;
        const starPalette = [
          { r: 255, g: 255, b: 255 },
          { r: 176, g: 196, b: 255 },
          { r: 255, g: 244, b: 214 },
          { r: 167, g: 210, b: 255 },
        ];
        for (let i = 0; i < GALAXY_STAR_COUNT; i++) {
          const depth = Math.random();
          const base =
            starPalette[Math.floor(Math.random() * starPalette.length)];
          galaxyStars.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            radius: 0.25 + depth * 1.6,
            speed: 10 + depth * 40,
            twinkleSpeed: 0.5 + Math.random() * 1.5,
            twinkleOffset: Math.random() * Math.PI * 2,
            color: base,
          });
        }

        galaxyNebulae.length = 0;
        const nebulaPalette = [
          { r: 99, g: 102, b: 241 },
          { r: 14, g: 165, b: 233 },
          { r: 236, g: 72, b: 153 },
          { r: 74, g: 222, b: 128 },
        ];
        const maxDimension = Math.max(canvas.width, canvas.height) || 1;
        for (let i = 0; i < GALAXY_NEBULA_COUNT; i++) {
          const color =
            nebulaPalette[Math.floor(Math.random() * nebulaPalette.length)];
          const baseRadius = randomRange(
            maxDimension * 0.2,
            maxDimension * 0.35
          );
          const driftAngle = Math.random() * Math.PI * 2;
          const driftSpeed = randomRange(4, 12);

          // Create multiple cloud clusters for irregular nebula structure
          const numClouds = Math.floor(randomRange(3, 7)); // 3-6 overlapping clouds
          const clouds = [];
          for (let j = 0; j < numClouds; j++) {
            clouds.push({
              // Offset from nebula center
              offsetX: randomRange(-baseRadius * 0.4, baseRadius * 0.4),
              offsetY: randomRange(-baseRadius * 0.4, baseRadius * 0.4),
              // Size variation
              sizeScale: randomRange(0.3, 1.0),
              // Opacity variation for depth
              opacityScale: randomRange(0.6, 1.0),
              // Individual morphing
              morphPhase: Math.random() * Math.PI * 2,
              morphSpeed: randomRange(0.0002, 0.0006),
            });
          }

          galaxyNebulae.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            baseRadius,
            color,
            pulseSpeed: randomRange(0.25, 0.6),
            pulsePhase: Math.random() * Math.PI * 2,
            vx: Math.cos(driftAngle) * driftSpeed,
            vy: Math.sin(driftAngle) * driftSpeed,
            clouds: clouds, // Array of cloud clusters
            // Overall morphing parameters
            morphSpeed1: randomRange(0.0003, 0.0008),
            morphSpeed2: randomRange(0.0004, 0.0009),
            morphSpeed3: randomRange(0.0002, 0.0006),
            morphPhase1: Math.random() * Math.PI * 2,
            morphPhase2: Math.random() * Math.PI * 2,
            morphPhase3: Math.random() * Math.PI * 2,
          });
        }

        galaxyComets.length = 0;
        galaxyNovas.length = 0;
        galaxyCometExplosions.length = 0;
        lastBackgroundTime = Date.now();
        lastNovaSpawn = lastBackgroundTime;
      }

      function spawnComet() {
        const startX = -randomRange(40, 160);
        const startY = randomRange(-80, canvas.height * 0.7);
        const speed = randomRange(150, 260);
        const angle = randomRange(0.12, 0.35);
        const color = { r: 173, g: 216, b: 255 };
        galaxyComets.push({
          x: startX,
          y: startY,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          radius: randomRange(2.2, 3.6),
          life: randomRange(12, 18),
          tailDistance: randomRange(140, 220),
          color,
        });
      }

      function spawnNova(now) {
        lastNovaSpawn = now;
        const novaPalette = [
          { r: 255, g: 255, b: 255 },
          { r: 255, g: 214, b: 102 },
          { r: 147, g: 197, b: 253 },
          { r: 244, g: 114, b: 182 },
        ];
        const novaX = randomRange(0, canvas.width);
        const novaY = randomRange(0, canvas.height);
        const novaColor =
          novaPalette[Math.floor(Math.random() * novaPalette.length)];

        const flareDuration = 8000;
        galaxyNovas.push({
          x: novaX,
          y: novaY,
          start: now,
          duration: flareDuration, // Match lens flare duration so nova doesn't get removed early
          maxRadius: randomRange(
            Math.max(canvas.width, canvas.height) * 0.08,
            Math.max(canvas.width, canvas.height) * 0.14
          ),
          color: novaColor,
          // Lens flare effect
          lensFlare: {
            rotation: Math.random() * Math.PI * 2,
            rotationSpeed: 0.001, // Slow rotation
            pulsePhase: Math.random() * Math.PI * 2,
            pulseSpeed: 0.015, // Slower pulse (about 1 pulse per 7 seconds at 60fps)
            lingerDuration: flareDuration, // Lens flare lasts 8 seconds
            rayLength: randomRange(40, 80),
            haloSize: randomRange(25, 45),
          },
        });
      }

      function drawGalaxyBackground(now) {
        if (canvas.width === 0 || canvas.height === 0) {
          return;
        }

        if (galaxyStars.length === 0) {
          initializeGalaxy();
        }

        const deltaSeconds =
          Math.min(0.05, (now - lastBackgroundTime) / 1000) || 0;
        lastBackgroundTime = now;

        ctx.save();
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Nebulae
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        galaxyNebulae.forEach((nebula) => {
          nebula.x += nebula.vx * deltaSeconds;
          nebula.y += nebula.vy * deltaSeconds;
          nebula.pulsePhase += nebula.pulseSpeed * deltaSeconds;
          const pulse = 0.82 + Math.cos(nebula.pulsePhase) * -0.18;
          const maxRadius = nebula.baseRadius;
          if (nebula.x < -maxRadius) nebula.x = canvas.width + maxRadius;
          if (nebula.x > canvas.width + maxRadius) nebula.x = -maxRadius;
          if (nebula.y < -maxRadius) nebula.y = canvas.height + maxRadius;
          if (nebula.y > canvas.height + maxRadius) nebula.y = -maxRadius;
          const baseRadius = nebula.baseRadius * pulse;

          // Update overall morph phases
          nebula.morphPhase1 += nebula.morphSpeed1;
          nebula.morphPhase2 += nebula.morphSpeed2;
          nebula.morphPhase3 += nebula.morphSpeed3;

          // Calculate overall wobble
          const morph1 = Math.sin(nebula.morphPhase1);
          const morph2 = Math.sin(nebula.morphPhase2);
          const globalOffsetX = morph1 * baseRadius * 0.05;
          const globalOffsetY = morph2 * baseRadius * 0.05;

          // Draw each cloud cluster to create irregular nebula structure
          nebula.clouds.forEach((cloud) => {
            // Update individual cloud morph
            cloud.morphPhase += cloud.morphSpeed;

            // Individual cloud wobble and breathing
            const cloudMorph = Math.sin(cloud.morphPhase);
            const cloudWobbleX = cloudMorph * baseRadius * 0.03;
            const cloudWobbleY =
              Math.cos(cloud.morphPhase * 1.3) * baseRadius * 0.03;
            const cloudBreathing = 1 + cloudMorph * 0.08;

            // Calculate cloud position and size
            const cloudX =
              nebula.x + globalOffsetX + cloud.offsetX + cloudWobbleX;
            const cloudY =
              nebula.y + globalOffsetY + cloud.offsetY + cloudWobbleY;
            const cloudRadius = baseRadius * cloud.sizeScale * cloudBreathing;

            // Draw cloud with radial gradient
            const gradient = ctx.createRadialGradient(
              cloudX,
              cloudY,
              0,
              cloudX,
              cloudY,
              cloudRadius
            );
            const baseOpacity = 0.28 * cloud.opacityScale;
            const midOpacity = 0.14 * cloud.opacityScale;

            gradient.addColorStop(
              0,
              `rgba(${nebula.color.r}, ${nebula.color.g}, ${nebula.color.b}, ${baseOpacity})`
            );
            gradient.addColorStop(
              0.5,
              `rgba(${nebula.color.r}, ${nebula.color.g}, ${nebula.color.b}, ${midOpacity})`
            );
            gradient.addColorStop(1, "rgba(0, 0, 0, 0)");

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(cloudX, cloudY, cloudRadius, 0, Math.PI * 2);
            ctx.fill();
          });
        });
        ctx.restore();

        // Stars
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        galaxyStars.forEach((star) => {
          star.x -= star.speed * deltaSeconds;
          if (star.x < -star.radius) {
            star.x = canvas.width + star.radius;
            star.y = Math.random() * canvas.height;
          }
          const twinkle =
            Math.sin(now * 0.002 * star.twinkleSpeed + star.twinkleOffset) *
              0.5 +
            0.5;
          const alpha = 0.25 + twinkle * 0.75;
          ctx.globalAlpha = alpha;
          ctx.fillStyle = `rgba(${star.color.r}, ${star.color.g}, ${star.color.b}, 1)`;
          ctx.beginPath();
          ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
          ctx.fill();
        });
        ctx.restore();

        // Spawn new comets and novas
        if (
          galaxyComets.length < GALAXY_COMET_CAP &&
          Math.random() < deltaSeconds * 0.05
        ) {
          spawnComet();
        }
        if (now - lastNovaSpawn > 6000 && Math.random() < deltaSeconds * 0.18) {
          spawnNova(now);
        }

        // Comets
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        const rootX = canvas.width / 2;
        const rootY = canvas.height / 2;
        const maxCenterDistance = Math.hypot(rootX, rootY) || 1;
        const centralNode = nodes[0];
        const centralRadius = centralNode ? centralNode.radius : 0;
        for (let i = galaxyComets.length - 1; i >= 0; i--) {
          const comet = galaxyComets[i];
          comet.x += comet.vx * deltaSeconds;
          comet.y += comet.vy * deltaSeconds;
          comet.life -= deltaSeconds;

          if (
            comet.life <= 0 ||
            comet.x < -200 ||
            comet.x > canvas.width + 200 ||
            comet.y < -200 ||
            comet.y > canvas.height + 200
          ) {
            galaxyComets.splice(i, 1);
            continue;
          }

          const dirX = comet.x - rootX;
          const dirY = comet.y - rootY;
          const dirMag = Math.sqrt(dirX * dirX + dirY * dirY) || 1;
          const distanceFromCenter = Math.min(maxCenterDistance, dirMag);
          const centerFactor = 1 - distanceFromCenter / maxCenterDistance;

          if (centralNode && centralRadius > 0) {
            if (dirMag <= centralRadius + comet.radius * 0.75) {
              galaxyComets.splice(i, 1);
              galaxyCometExplosions.push({
                x: comet.x,
                y: comet.y,
                start: now,
                duration: 950,
                maxRadius: Math.max(centralRadius * 1.6, 60),
                color: { ...comet.color },
              });
              createPopParticles(centralNode.x, centralNode.y, {
                r: Math.min(255, comet.color.r + 40),
                g: Math.min(255, comet.color.g + 40),
                b: Math.min(255, comet.color.b + 40),
              });
              centralImpactShake = Math.min(centralImpactShake + 8, 24);
              centralImpactShakePhase = Math.random() * Math.PI * 2;
              centralImpactShakeOffsetX = 0;
              centralImpactShakeOffsetY = 0;
              continue;
            }
          }

          const influenceRadius = maxCenterDistance * 0.65;
          if (dirMag < influenceRadius) {
            const normDirX = dirX / dirMag;
            const normDirY = dirY / dirMag;
            const proximity = 1 - dirMag / influenceRadius;
            const radialAccel = 110 * Math.pow(proximity, 1.4);
            const tangentialAccel = 22 * proximity ** 2;

            // Pull toward the center to curve the path inward
            comet.vx += -normDirX * radialAccel * deltaSeconds;
            comet.vy += -normDirY * radialAccel * deltaSeconds;

            // Add a slight tangential component to simulate gravitational bending
            const normalX = -normDirY;
            const normalY = normDirX;
            comet.vx += normalX * tangentialAccel * deltaSeconds;
            comet.vy += normalY * tangentialAccel * deltaSeconds;
          }

          // Calculate tail properties based on distance to center
          const normX = dirX / dirMag;
          const normY = dirY / dirMag;

          // Tail grows as comet approaches center (50% longer when near center)
          const tailLength = comet.tailDistance * (1 + centerFactor * 0.5);

          // Brightness increases dramatically as comet approaches center
          // Nearly transparent at edges (0.05), bright at center (0.8)
          const baseBrightness = 0.05 + centerFactor * 0.75;

          // Color tints toward white as it approaches center
          const tintAmount = centerFactor * 0.8;
          const tintedColor = {
            r: Math.round(comet.color.r + (255 - comet.color.r) * tintAmount),
            g: Math.round(comet.color.g + (255 - comet.color.g) * tintAmount),
            b: Math.round(comet.color.b + (255 - comet.color.b) * tintAmount),
          };

          // Draw tail as stream of tiny fading particles with animation
          // Fixed particle count to prevent stutter - elongate particles instead
          const FIXED_PARTICLE_COUNT = 15;
          const baseParticleSize = 0.8; // Base particle size (constant)

          // Animation offset using time for flowing effect
          const animationSpeed = 0.0001; // Speed of particle flow animation (slower)
          const animationOffset = (now * animationSpeed) % 1; // 0-1 cycling value

          for (let i = 0; i < FIXED_PARTICLE_COUNT; i++) {
            // Distribute particles evenly with animation offset
            // Add small offset per particle to prevent all particles from wrapping at once
            const particlePhaseOffset = i / FIXED_PARTICLE_COUNT;
            const t = (particlePhaseOffset + animationOffset) % 1; // 0 at head, 1 at tail end

            // Use smooth position without additional modulo to prevent stutter
            const animatedT = t;
            const particleX = comet.x + normX * tailLength * animatedT;
            const particleY = comet.y + normY * tailLength * animatedT;

            // Fade out along tail length (bright at head, transparent at end)
            const tailFade = 1 - Math.pow(animatedT, 1.5);
            const particleAlpha = baseBrightness * tailFade;

            // Elongate particles based on centerFactor (1.0x to 2.5x)
            // Particles stretch more as comet approaches center
            const elongationFactor = 1.0 + centerFactor * 1.5;

            // Particles also get larger near head
            const sizeMultiplier = 1 - Math.pow(animatedT, 0.8); // 1.0 at head, ~0 at tail
            const particleSize =
              baseParticleSize *
              (0.3 + sizeMultiplier * 1.2) *
              elongationFactor;

            // Draw elongated particle (ellipse stretched along tail direction)
            ctx.save();
            ctx.translate(particleX, particleY);

            // Calculate angle of tail direction
            const angle = Math.atan2(normY, normX);
            ctx.rotate(angle);

            // Draw stretched ellipse
            ctx.fillStyle = `rgba(${tintedColor.r}, ${tintedColor.g}, ${tintedColor.b}, ${particleAlpha})`;
            ctx.beginPath();
            ctx.ellipse(
              0,
              0,
              particleSize * elongationFactor,
              particleSize,
              0,
              0,
              Math.PI * 2
            );
            ctx.fill();
            ctx.restore();
          }

          // Draw comet head (brighter than tail)
          const headAlpha = baseBrightness * 1.5; // Head is 50% brighter than tail start
          ctx.fillStyle = `rgba(${tintedColor.r}, ${tintedColor.g}, ${tintedColor.b}, ${headAlpha})`;
          ctx.beginPath();
          ctx.arc(
            comet.x,
            comet.y,
            comet.radius * (0.7 + centerFactor * 0.5),
            0,
            Math.PI * 2
          );
          ctx.fill();
        }
        ctx.restore();

        // Comet explosions
        if (galaxyCometExplosions.length > 0) {
          ctx.save();
          ctx.globalCompositeOperation = "lighter";
          for (let i = galaxyCometExplosions.length - 1; i >= 0; i--) {
            const boom = galaxyCometExplosions[i];
            const progress = (now - boom.start) / boom.duration;
            if (progress >= 1) {
              galaxyCometExplosions.splice(i, 1);
              continue;
            }
            const eased = Math.pow(progress, 0.55);
            const radius = boom.maxRadius * eased;
            const alpha = 0.75 * (1 - progress);
            const gradient = ctx.createRadialGradient(
              boom.x,
              boom.y,
              0,
              boom.x,
              boom.y,
              radius
            );
            gradient.addColorStop(
              0,
              `rgba(${boom.color.r}, ${boom.color.g}, ${boom.color.b}, ${alpha})`
            );
            gradient.addColorStop(
              0.45,
              `rgba(${boom.color.r}, ${boom.color.g}, ${boom.color.b}, ${
                alpha * 0.6
              })`
            );
            gradient.addColorStop(1, "rgba(0, 0, 0, 0)");
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(boom.x, boom.y, radius, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.restore();
        }

        // Novas
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        for (let i = galaxyNovas.length - 1; i >= 0; i--) {
          const nova = galaxyNovas[i];
          const progress = (now - nova.start) / nova.duration;
          if (progress >= 1) {
            galaxyNovas.splice(i, 1);
            continue;
          }
          const eased = progress * (2 - progress);
          const radius = nova.maxRadius * eased;
          const alpha = (1 - progress) * 0.8;
          const gradient = ctx.createRadialGradient(
            nova.x,
            nova.y,
            0,
            nova.x,
            nova.y,
            radius
          );
          gradient.addColorStop(
            0,
            `rgba(${nova.color.r}, ${nova.color.g}, ${nova.color.b}, ${Math.min(
              1,
              alpha
            )})`
          );
          gradient.addColorStop(
            0.4,
            `rgba(${nova.color.r}, ${nova.color.g}, ${nova.color.b}, ${
              alpha * 0.55
            })`
          );
          gradient.addColorStop(1, "rgba(0, 0, 0, 0)");
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(nova.x, nova.y, radius, 0, Math.PI * 2);
          ctx.fill();

          // Draw lens flare effect at center
          const flare = nova.lensFlare;
          const flareElapsed = now - nova.start;
          const flareProgress = flareElapsed / flare.lingerDuration;

          if (flareProgress < 1) {
            // Update flare animation
            flare.rotation += flare.rotationSpeed;
            flare.pulsePhase += flare.pulseSpeed;

            // Pulsing intensity (more dramatic range for visibility)
            const pulse = 0.5 + Math.sin(flare.pulsePhase) * 0.5; // Pulses between 0.0 and 1.0

            // Fade in quickly, hold, then fade out very gradually
            let lifetimeAlpha;
            if (flareProgress < 0.1) {
              // Quick fade in over first 10% (0.8 seconds)
              lifetimeAlpha = flareProgress / 0.1;
            } else if (flareProgress > 0.4) {
              // Very gradual fade out over last 60% (4.8 seconds)
              const fadeProgress = (flareProgress - 0.4) / 0.6;
              lifetimeAlpha = 1 - fadeProgress * fadeProgress; // Quadratic easing
            } else {
              // Hold full brightness for 30% (2.4 seconds)
              lifetimeAlpha = 1;
            }

            const flareAlpha = Math.max(0.05, lifetimeAlpha * pulse); // Minimum 5% visibility

            ctx.save();
            ctx.translate(nova.x, nova.y);

            // Draw cross-shaped light rays (diffraction spikes)
            ctx.rotate(flare.rotation);
            for (let i = 0; i < 4; i++) {
              const angle = (i * Math.PI) / 2;
              ctx.save();
              ctx.rotate(angle);

              // Draw ray as gradient line
              const rayGradient = ctx.createLinearGradient(
                0,
                0,
                flare.rayLength,
                0
              );
              rayGradient.addColorStop(
                0,
                `rgba(255, 255, 255, ${flareAlpha * 0.9})`
              );
              rayGradient.addColorStop(
                0.3,
                `rgba(${nova.color.r}, ${nova.color.g}, ${nova.color.b}, ${
                  flareAlpha * 0.6
                })`
              );
              rayGradient.addColorStop(
                1,
                `rgba(${nova.color.r}, ${nova.color.g}, ${nova.color.b}, 0)`
              );

              ctx.strokeStyle = rayGradient;
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(0, 0);
              ctx.lineTo(flare.rayLength, 0);
              ctx.stroke();

              // Add thinner bright core to ray
              ctx.strokeStyle = `rgba(255, 255, 255, ${flareAlpha * 0.8})`;
              ctx.lineWidth = 0.5;
              ctx.beginPath();
              ctx.moveTo(0, 0);
              ctx.lineTo(flare.rayLength * 0.7, 0);
              ctx.stroke();

              ctx.restore();
            }
            ctx.restore();

            // Draw bright central point
            const centerGradient = ctx.createRadialGradient(
              nova.x,
              nova.y,
              0,
              nova.x,
              nova.y,
              8
            );
            centerGradient.addColorStop(
              0,
              `rgba(255, 255, 255, ${flareAlpha})`
            );
            centerGradient.addColorStop(
              0.5,
              `rgba(${nova.color.r}, ${nova.color.g}, ${nova.color.b}, ${
                flareAlpha * 0.8
              })`
            );
            centerGradient.addColorStop(
              1,
              `rgba(${nova.color.r}, ${nova.color.g}, ${nova.color.b}, 0)`
            );
            ctx.fillStyle = centerGradient;
            ctx.beginPath();
            ctx.arc(nova.x, nova.y, 8, 0, Math.PI * 2);
            ctx.fill();

            // Draw circular halo ring (chromatic aberration effect)
            ctx.save();
            // Blue halo (inner)
            ctx.strokeStyle = `rgba(147, 197, 253, ${flareAlpha * 0.4})`;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.arc(nova.x, nova.y, flare.haloSize * 0.9, 0, Math.PI * 2);
            ctx.stroke();

            // Main color halo (middle)
            ctx.strokeStyle = `rgba(${nova.color.r}, ${nova.color.g}, ${
              nova.color.b
            }, ${flareAlpha * 0.5})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(nova.x, nova.y, flare.haloSize, 0, Math.PI * 2);
            ctx.stroke();

            // Red halo (outer - chromatic aberration)
            ctx.strokeStyle = `rgba(248, 113, 113, ${flareAlpha * 0.3})`;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.arc(nova.x, nova.y, flare.haloSize * 1.1, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
          }
        }
        ctx.restore();

        ctx.restore();

        // Decay central shake
        if (centralImpactShake > 0.0001) {
          centralImpactShake = Math.max(
            0,
            centralImpactShake - deltaSeconds * 10
          );
          centralImpactShakePhase += deltaSeconds * 20;
          const magnitude = centralImpactShake;
          centralImpactShakeOffsetX =
            Math.sin(centralImpactShakePhase) * magnitude;
          centralImpactShakeOffsetY =
            Math.cos(centralImpactShakePhase * 1.3) * magnitude * 0.8;
        } else {
          centralImpactShake = 0;
          centralImpactShakeOffsetX = 0;
          centralImpactShakeOffsetY = 0;
        }

        lastBackgroundTime = now;
      }

      let initialBranchTimeout;
      function createGraph() {
        clearTimeout(initialBranchTimeout);
        nodes.length = 0;
        edges.length = 0;
        pulses.length = 0;
        particles.length = 0;
        dataPackets.length = 0;
        immunityPackets.length = 0;
        pingOfDeathPackets.length = 0;
        phishPackets.length = 0;
        counterStrikePackets.length = 0;

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        const root = new Node(0, centerX, centerY);
        root.baseRadius = 30;
        root.currentColor = { ...colors.blue };
        root.status = "blue";
        root.state = "alive";
        root.opacity = 1;
        root.radius = root.baseRadius;
        root.forceMultiplier = 1.0; // Full physics immediately (no spawn animation)
        nodes.push(root);

        createInitialBranches(0, desiredBranchCount);
      }

      function createInitialBranches(index, total) {
        if (index >= total) return;
        const angle = (index / total) * Math.PI * 2;
        sproutNewBranch(angle);
        initialBranchTimeout = setTimeout(
          () => createInitialBranches(index + 1, total),
          800
        );
      }

      // --- Space-Probing Functions for Organic Growth ---

      function pointToLineDistance(px, py, x1, y1, x2, y2) {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;

        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        let param = -1;

        if (lenSq !== 0) param = dot / lenSq;

        let xx, yy;
        if (param < 0) {
          xx = x1;
          yy = y1;
        } else if (param > 1) {
          xx = x2;
          yy = y2;
        } else {
          xx = x1 + param * C;
          yy = y1 + param * D;
        }

        const dx = px - xx;
        const dy = py - yy;
        return Math.sqrt(dx * dx + dy * dy);
      }

      /**
       * Score a potential node position using betweenness centrality principles:
       * - Good spacing between nodes (not too crowded)
       * - Radial outward flow from center
       * - Utilize available canvas space evenly
       * - Avoid edges and boundaries with buffer zones
       */
      function scorePosition(x, y, parentNode) {
        let score = 100; // Start with base score
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        // Penalty for proximity to other nodes - maintain personal space
        const PERSONAL_SPACE = 55;
        for (const node of nodes) {
          if (node.state !== "alive" || node === parentNode) continue;
          const dx = x - node.x;
          const dy = y - node.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist < PERSONAL_SPACE) {
            score -= (PERSONAL_SPACE - dist) * 2.5; // Heavy penalty for crowding
          }
        }

        // Penalty for proximity to edges (line-to-point distance) - only tree edges
        const EDGE_CLEARANCE = 35;
        for (const edge of edges) {
          if (
            !edge.from ||
            !edge.to ||
            edge.from.state !== "alive" ||
            edge.to.state !== "alive"
          )
            continue;
          // Skip non-tree edges
          if (
            edge.isBotnetMesh ||
            edge.isGuardianVpnTunnel ||
            edge.isWirelessLink ||
            edge.isDDOSAttack
          )
            continue;

          const dist = pointToLineDistance(
            x,
            y,
            edge.from.x,
            edge.from.y,
            edge.to.x,
            edge.to.y
          );

          if (dist < EDGE_CLEARANCE) {
            score -= (EDGE_CLEARANCE - dist) * 1.5;
          }
        }

        // Ideal distance from parent based on depth
        const parentDist = Math.sqrt(
          (x - parentNode.x) ** 2 + (y - parentNode.y) ** 2
        );
        const isFirstGen = parentNode.parent === null;
        const idealDist = isFirstGen ? 180 : 70; // 2x for first gen (180), normal for sub-branches (70)
        score -= Math.abs(parentDist - idealDist) * 0.6;

        // BETWEENNESS CENTRALITY: Reward positions that continue outward from center
        // Calculate angle from center to parent and from center to candidate
        const parentAngleFromCenter = Math.atan2(
          parentNode.y - centerY,
          parentNode.x - centerX
        );
        const candidateAngleFromCenter = Math.atan2(y - centerY, x - centerX);

        // Calculate the distance from center for both
        const parentDistFromCenter = Math.sqrt(
          (parentNode.x - centerX) ** 2 + (parentNode.y - centerY) ** 2
        );
        const candidateDistFromCenter = Math.sqrt(
          (x - centerX) ** 2 + (y - centerY) ** 2
        );

        // Reward continuing outward (candidate further from center than parent)
        if (candidateDistFromCenter > parentDistFromCenter) {
          score += 15; // Bonus for outward growth
        }

        // Reward staying in same angular sector as parent (continuation of radial flow)
        let angleDiff = Math.abs(
          candidateAngleFromCenter - parentAngleFromCenter
        );
        if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
        const angularContinuityBonus = Math.max(0, 12 - angleDiff * 6); // Bonus for staying in same direction
        score += angularContinuityBonus;

        // Penalty for being too close to canvas boundaries (with smooth falloff)
        const SOFT_BOUNDARY = 80;
        const HARD_BOUNDARY = 40;
        const distToLeft = x - padding;
        const distToRight = canvas.width - padding - x;
        const distToTop = y - padding;
        const distToBottom = canvas.height - padding - y;
        const minDistToBoundary = Math.min(
          distToLeft,
          distToRight,
          distToTop,
          distToBottom
        );

        if (minDistToBoundary < HARD_BOUNDARY) {
          score -= (HARD_BOUNDARY - minDistToBoundary) * 5; // Very strong penalty near hard edge
        } else if (minDistToBoundary < SOFT_BOUNDARY) {
          score -= (SOFT_BOUNDARY - minDistToBoundary) * 1.5; // Soft penalty in buffer zone
        }

        // Heavy penalty if the segment to the parent would cross existing tree edges
        if (parentNode && segmentCrossesExistingEdges(parentNode, { x, y })) {
          score -= 1000;
        }

        return score;
      }

      function findOptimalBranchPosition(
        parentNode,
        angle,
        distance,
        samples = 8
      ) {
        const allCandidates = [];

        const sampleOnce = (count, cone = Math.PI / 3, distJitter = 0.2) => {
          const candidates = [];
          for (let i = 0; i < count; i++) {
            const angleVariation = (i / count - 0.5) * cone; // symmetric cone
            const testAngle = angle + angleVariation;
            const distVariation =
              distance * (1 - distJitter + Math.random() * (2 * distJitter));

            const x = parentNode.baseX + Math.cos(testAngle) * distVariation;
            const y = parentNode.baseY + Math.sin(testAngle) * distVariation;

            const clampedX = Math.max(
              padding,
              Math.min(canvas.width - padding, x)
            );
            const clampedY = Math.max(
              padding,
              Math.min(canvas.height - padding, y)
            );

            const candidate = { x: clampedX, y: clampedY, angle: testAngle };
            candidate.score = scorePosition(
              candidate.x,
              candidate.y,
              parentNode
            );
            candidates.push(candidate);
            allCandidates.push(candidate);
          }
          // Prefer non-crossing candidates
          const safe = candidates.filter(
            (c) => !segmentCrossesExistingEdges(parentNode, c)
          );
          if (safe.length > 0) {
            safe.sort((a, b) => b.score - a.score);
            return safe[0];
          }
          return null;
        };

        // Try progressively larger cones / more samples to find a non-crossing option
        const attempts = [
          { count: samples, cone: Math.PI / 3, jitter: 0.2 },
          { count: Math.max(12, samples + 4), cone: Math.PI / 2, jitter: 0.3 },
          {
            count: Math.max(18, samples + 10),
            cone: (2 * Math.PI) / 3,
            jitter: 0.35,
          },
        ];

        for (const a of attempts) {
          const pick = sampleOnce(a.count, a.cone, a.jitter);
          if (pick) return pick;
        }

        // Fallback: if no safe candidate, return the highest-scoring overall
        allCandidates.sort((a, b) => b.score - a.score);
        return allCandidates[0] || { x: parentNode.x, y: parentNode.y, angle };
      }

      function sproutNewBranch(angle = null) {
        const root = nodes[0];
        let newAngle = angle;

        if (newAngle === null) {
          const mainBranches = root.children.filter(
            (n) => n.state !== "retracting"
          );
          if (mainBranches.length < 2) {
            newAngle = Math.random() * Math.PI * 2;
          } else {
            const angles = mainBranches
              .map((branch) =>
                Math.atan2(branch.baseY - root.baseY, branch.baseX - root.baseX)
              )
              .sort((a, b) => a - b);
            let maxGap = 0;
            let angleForMaxGap = 0;

            for (let i = 0; i < angles.length; i++) {
              const nextAngle =
                i === angles.length - 1
                  ? angles[0] + Math.PI * 2
                  : angles[i + 1];
              const gap = nextAngle - angles[i];
              if (gap > maxGap) {
                maxGap = gap;
                angleForMaxGap = angles[i];
              }
            }
            newAngle = angleForMaxGap + maxGap / 2;
          }
        }

        // Determine branch depth (how many levels of children will grow)
        const cosAngle = Math.abs(Math.cos(newAngle));
        let branchDepth = cosAngle > 0.5 ? 3 : 2;

        // Simple initial placement - physics will position correctly
        // Just spawn at a reasonable distance, forces will spread them out
        const targetDist = 70 + Math.random() * 30; // 70-100px initial distance

        // IMPROVED: Use space-probing for main branch position
        const optimal = findOptimalBranchPosition(
          root,
          newAngle,
          targetDist,
          12
        ); // More samples for main branches

        let endpoint = { x: optimal.x, y: optimal.y };
        let growthAngle = optimal.angle;
        if (segmentCrossesExistingEdges(root, endpoint)) {
          const nudged = nudgeEndpointToAvoidCrossing(root, endpoint);
          if (nudged) {
            endpoint = nudged;
          } else {
            const alt = findOptimalBranchPosition(
              root,
              newAngle + (Math.random() - 0.5) * (Math.PI / 2),
              targetDist,
              18
            );
            if (!alt || segmentCrossesExistingEdges(root, alt)) {
              return; // Skip this main branch to avoid crossing
            }
            endpoint = { x: alt.x, y: alt.y };
            growthAngle = alt.angle;
          }
        }

        const mainNode = new Node(
          Date.now() + Math.random(),
          endpoint.x,
          endpoint.y,
          root
        );
        root.children.push(mainNode);
        nodes.push(mainNode);
        edges.push({ from: root, to: mainNode });
        applyParentStatusToChild(root, mainNode);

        growBranchSequentially(mainNode, branchDepth, growthAngle);
        root.pulseEffect = 1;

        scheduleGroundStationPromotion(mainNode);
      }

      function scheduleGroundStationPromotion(branchNode) {
        if (!branchNode) return;
        setTimeout(() => {
          const isSingle =
            branchNode.parent === nodes[0] &&
            branchNode.children.length === 0 &&
            branchNode.state === "alive";
          const alreadySpecial =
            branchNode.isGuardian || branchNode.isGroundStation;
          if (!isSingle || alreadySpecial) return;

          if (Math.random() < 0.25) {
            convertToGroundStation(branchNode);
          }
        }, 4000 + Math.random() * 2000); // Allow initial settling before promotion
      }

      function applyParentStatusToChild(parentNode, childNode) {
        if (!parentNode || !childNode) return;
        if (childNode.isSatellite) return;
        if (
          parentNode.status === "red" ||
          parentNode.status === "yellow" ||
          parentNode.status === "malware" ||
          parentNode.status === "botnet" ||
          parentNode.status === "commandControl"
        ) {
          childNode.status = "yellow";
          childNode.statusChangedAt = Date.now();
        }
      }

      function growBranchSequentially(parentNode, depth, parentAngle) {
        if (depth <= 0) return;
        // Also check absolute depth limit
        if (getNodeDepth(parentNode) >= MAX_BRANCH_DEPTH) return;
        // Ground stations should not spawn child nodes
        if (parentNode.isGroundStation) return;
        const numChildren = Math.floor(Math.random() * 3);

        for (let i = 0; i < numChildren; i++) {
          setTimeout(() => {
            if (
              parentNode.state === "retracting" ||
              parentNode.state === "dead"
            )
              return;
            // Also check if parent became a ground station (no children allowed)
            if (parentNode.isGroundStation) return;

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            // Calculate parent's radial angle from center for outward growth
            // Use baseX/baseY (target position) not x/y (which may still be animating from center)
            const parentRadialAngle = Math.atan2(
              parentNode.baseY - centerY,
              parentNode.baseX - centerX
            );

            // Spawn with random spread around parent's outward direction
            // Physics will handle final positioning via forces
            const angleSpread = (Math.random() - 0.5) * 1.2; // ~70 degree spread
            const blendedAngle = parentRadialAngle + angleSpread;
            const dist = 60 + Math.random() * 30; // 60-90px initial distance

            const optimal = findOptimalBranchPosition(
              parentNode,
              blendedAngle,
              dist
            );

            let endpoint = { x: optimal.x, y: optimal.y };
            let nextAngle = optimal.angle;
            if (segmentCrossesExistingEdges(parentNode, endpoint)) {
              const nudged = nudgeEndpointToAvoidCrossing(parentNode, endpoint);
              if (nudged) {
                endpoint = nudged;
              } else {
                const alt = findOptimalBranchPosition(
                  parentNode,
                  blendedAngle + (Math.random() - 0.5) * 0.8,
                  dist,
                  14
                );
                if (!alt || segmentCrossesExistingEdges(parentNode, alt)) {
                  return; // Skip this child; cannot place without crossing
                }
                endpoint = { x: alt.x, y: alt.y };
                nextAngle = alt.angle;
              }
            }

            const childNode = new Node(
              Date.now() + Math.random(),
              endpoint.x,
              endpoint.y,
              parentNode
            );
            parentNode.children.push(childNode);
            nodes.push(childNode);
            edges.push({ from: parentNode, to: childNode });
            applyParentStatusToChild(parentNode, childNode);

            // IMPROVED: Longer delay to let physics settle
            setTimeout(() => {
              growBranchSequentially(childNode, depth - 1, nextAngle);
            }, 1500); // Increased from 1000ms
          }, i * (1000 + Math.random() * 400)); // Increased from 600-800ms
        }
      }

      function markBranchForRetraction(node, options = {}) {
        if (!node) return;
        const allowGroundStation = options.allowGroundStation === true;

        // Ground stations are always retracted with their branch
        // Don't skip them unless explicitly told to preserve them
        if (node.isGroundStation) {
          removeSatelliteChain(node);
          // When branch is pruned, ground station goes with it
          // Only demote to regular node if allowGroundStation=false
          if (!allowGroundStation) {
            // Branch pruning - keep ground station but remove it with branch
            // Don't demote, just prune
          } else {
            // Explicit ground station removal - demote to regular node
            node.isGroundStation = false;
            node.groundStationEstablishedAt = null;
            node.lastSatelliteLaunch = null;
            node.groundStationCountdown = 0;
            node.lastCountdownUpdate = null;
            node.satelliteChain = [];
            node.satelliteEdges = [];
          }
        }
        if (node.isSatellite) {
          untetherSatellite(node);
        }
        node.state = "retracting";

        // Clear any attached immunity packets when branch is marked for retraction
        if (
          node.attachedImmunityPackets &&
          node.attachedImmunityPackets.length > 0
        ) {
          node.attachedImmunityPackets.forEach((packet) => {
            packet.active = false;
            packet.isAttached = false;
            packet.attachedNode = null;
          });
          node.attachedImmunityPackets = [];
          node.isImmunityHealing = false;
          node.immunityHealingStartTime = 0;
        }

        // Clear targeting flag and remove any pulses targeting this node
        node.isTargeted = false;
        pulses = pulses.filter((p) => p.target !== node);

        node.children.forEach((child) =>
          markBranchForRetraction(child, options)
        );
      }

      function pruneRandomBranch() {
        const now = Date.now();
        const potentialBranches = nodes.filter(
          (n) =>
            n.parent === nodes[0] &&
            n.state === "alive" &&
            now - n.createdAt > 10000 &&
            n.status !== "botnet" && // Don't prune botnet nodes
            n.status !== "commandControl" && // Don't prune C&C nodes
            !hasBotnetMeshConnections(n) // Don't prune nodes with mesh connections
        );

        if (potentialBranches.length > 7) {
          // Weight selection based on branch size - larger branches are more resilient
          // Smaller branches (fewer descendants) are more likely to be pruned
          const branchWeights = potentialBranches.map((branch) => {
            const descendantCount = countDescendants(branch);
            // Inverse weighting: fewer descendants = higher weight (more likely to be pruned)
            // Base weight of 10, reduced by descendant count
            return Math.max(1, 10 - descendantCount);
          });

          // Calculate total weight
          const totalWeight = branchWeights.reduce(
            (sum, weight) => sum + weight,
            0
          );

          // Select a random branch based on weights
          let randomValue = Math.random() * totalWeight;
          let selectedIndex = 0;
          for (let i = 0; i < branchWeights.length; i++) {
            randomValue -= branchWeights[i];
            if (randomValue <= 0) {
              selectedIndex = i;
              break;
            }
          }

          const branchToPrune = potentialBranches[selectedIndex];
          markBranchForRetraction(branchToPrune);
        }
      }

      function pruneSingleNodeBranches() {
        const now = Date.now();
        // Find all single-node branches (direct children of root with no children of their own)
        // that have existed for more than 5 seconds
        const singleNodeBranches = nodes.filter(
          (n) =>
            n.parent === nodes[0] &&
            n.state === "alive" &&
            n.children.length === 0 &&
            !n.isGroundStation &&
            now - n.createdAt > 5000 &&
            n.status !== "botnet" && // Don't prune botnet nodes
            n.status !== "commandControl" && // Don't prune C&C nodes
            !hasBotnetMeshConnections(n) // Don't prune nodes with mesh connections
        );

        // Prune all single-node branches that meet the criteria
        singleNodeBranches.forEach((branch) => {
          markBranchForRetraction(branch);
        });
      }

      function spawnCentralImmunityPackets(centralNode) {
        // Bot Defense Mode spawns SUPERCHARGED immunity packets (infinite during mode)
        // These packets will return to central node and become part of defense buffer
        if (!centralNode || centralNode.parent !== null) return;

        edges.forEach((edge) => {
          // Check if this edge is connected to the central node
          const connectedToCentral =
            edge.from === centralNode || edge.to === centralNode;
          if (!connectedToCentral) return;

          // Make sure the other node is alive
          const otherNode = edge.from === centralNode ? edge.to : edge.from;
          if (!otherNode || otherNode.state !== "alive") return;

          // Spawn SUPERCHARGED immunity packets during Bot Defense Mode
          // Spawn 2-3 packets per edge for a noticeable response
          const packetCount = 2 + Math.floor(Math.random() * 2); // 2-3 packets

          for (let i = 0; i < packetCount; i++) {
            // Spawn going away from central (direction based on edge orientation)
            const direction = edge.from === centralNode ? 1 : -1;
            const packet = new ImmunityPacket(edge, direction);
            packet.isSupercharged = true; // Bot Defense Mode creates supercharged packets
            packet.radius = Math.max(packet.radius, 3); // Larger radius for supercharged
            packet.progress = 0.05 + i * 0.1; // Stagger slightly
            immunityPackets.push(packet);
            incrementStat("totalImmunityPackets");
          }
        });
      }

      function redistributeImmunityPackets(centralNode) {
        // Get all attached immunity packets from central node
        const packetsToRedistribute = [...centralNode.attachedImmunityPackets];

        if (packetsToRedistribute.length > 0) {
          logEvent("immunitySupercharged", {
            packetCount: packetsToRedistribute.length,
          });
        }

        // Clear the central node's attached packets
        centralNode.attachedImmunityPackets = [];
        centralNode.isImmunityHealing = false;
        centralNode.immunityHealingStartTime = 0;

        // Find all healthy edges to redistribute packets to
        const healthyEdges = edges.filter(
          (edge) =>
            edge.from &&
            edge.to &&
            edge.from.state === "alive" &&
            edge.to.state === "alive" &&
            (edge.from.status === "green" || edge.to.status === "green")
        );

        if (healthyEdges.length === 0) {
          // No healthy edges, deactivate all packets
          packetsToRedistribute.forEach((packet) => {
            packet.active = false;
            packet.isAttached = false;
            packet.attachedNode = null;
          });
          return;
        }

        // Redistribute each packet to a random healthy edge
        packetsToRedistribute.forEach((packet) => {
          const randomEdge =
            healthyEdges[Math.floor(Math.random() * healthyEdges.length)];

          // Detach from central node
          packet.isAttached = false;
          packet.attachedNode = null;

          // Assign to new edge with random direction and progress
          packet.edge = randomEdge;
          packet.direction = Math.random() < 0.5 ? 1 : -1;
          packet.progress = Math.random(); // Random position along edge
          packet.lateralOffset = packet.direction === 1 ? 5 : -5;
        });
      }

      function updateNodeStatus(node, newStatus) {
        if (!node || node.state !== "alive" || node.status === newStatus)
          return;
        if (node.isSatellite) return;

        // Prevent ground stations from going down or getting infected during launch countdown
        if (
          node.isGroundStation &&
          node.groundStationCountdown > 0 &&
          (newStatus === "red" ||
            newStatus === "malware" ||
            newStatus === "botnet" ||
            newStatus === "commandControl")
        ) {
          return;
        }

        // Prevent infection of ground stations and down nodes
        if (
          node.isGroundStation &&
          (newStatus === "malware" ||
            newStatus === "botnet" ||
            newStatus === "commandControl")
        ) {
          return;
        }
        if (
          node.status === "down" &&
          (newStatus === "malware" ||
            newStatus === "botnet" ||
            newStatus === "commandControl")
        ) {
          return;
        }

        const previousStatus = node.status;
        const isRoot = node.parent === null;
        if (
          isRoot &&
          (newStatus === "malware" ||
            newStatus === "botnet" ||
            newStatus === "commandControl")
        ) {
          // CRITICAL ALERT for central node infection!
          logEvent("centralCompromised", { node });

          node.isSelfHealing = false; // Reset healing state on new infection
          node.hasRecoveryShield = false; // Clear recovery shield on new infection
          // Reset Bot Defense Mode immediately
          node.botDefenseModeActive = false;
          node.botDefenseTargets = [];
          node.botDefenseLastBurst = 0;

          // Redistribute immunity packets back into the network
          if (
            node.attachedImmunityPackets &&
            node.attachedImmunityPackets.length > 0
          ) {
            redistributeImmunityPackets(node);
          }
        }

        if (
          node.isGuardian &&
          (newStatus === "malware" ||
            newStatus === "botnet" ||
            newStatus === "commandControl")
        ) {
          demoteGuardian(node, "guardianDemoted");
          newStatus = "malware";
        }

        node.status = newStatus;
        node.statusChangedAt = Date.now();
        node.isHealing = false;

        // Clear immunity healing state when node changes status
        if (
          newStatus !== "malware" &&
          newStatus !== "botnet" &&
          newStatus !== "commandControl"
        ) {
          node.isImmunityHealing = false;
          node.immunityHealingStartTime = 0;
          // Detach all immunity packets
          node.attachedImmunityPackets.forEach((packet) => {
            packet.isAttached = false;
            packet.attachedNode = null;
          });
          node.attachedImmunityPackets = [];
        }

        if (
          newStatus === "malware" ||
          newStatus === "botnet" ||
          newStatus === "commandControl"
        ) {
          if (!node.infectedAt) {
            node.infectedAt = Date.now();
            node.dispatchDelay = 2000 + Math.random() * 4000; // 2-6 seconds delay before dispatch packet can be sent
            node.spreadDelay = 500 + Math.random() * 2500; // 0.5-3 seconds
            node.canSpread = Math.random() > 0.05; // 95% chance to spread, 5% chance not to
          }
        } else if (newStatus === "red") {
          // Ground stations do not retract when going red
        } else if (newStatus === "green" || (isRoot && newStatus === "blue")) {
          node.infectedAt = null;
          node.spreadDelay = 0;
          node.canSpread = true;
          node.isTargeted = false;

          // Track recovery if previous status was infected
          if (
            previousStatus === "malware" ||
            previousStatus === "botnet" ||
            previousStatus === "red" ||
            previousStatus === "yellow"
          ) {
            incrementStat("totalRecoveries");
          }

          // 25% chance to gain firewall when recovering to healthy status
          // (if node doesn't already have one and isn't a satellite)
          if (!node.hasFirewall && !node.isSatellite && Math.random() < 0.25) {
            node.hasFirewall = true;
            logEvent("firewallGained", { node });
          }
        }

        const statusLogKey = STATUS_LOG_KEYS[newStatus];
        if (statusLogKey) {
          logEvent(statusLogKey, {
            node,
            previousStatus,
            isGroundStation: node.isGroundStation,
          });
        }

        if (
          newStatus === "red" ||
          newStatus === "malware" ||
          newStatus === "botnet"
        )
          propagateStatus(node, "yellow", true);
        if (newStatus === "green" || (isRoot && newStatus === "blue"))
          propagateStatus(node, "green", true);
      }

      /**
       * Check if a node has an alternate path to a healthy branch through satellite wireless links.
       * This allows nodes on impacted branches to maintain connectivity via satellite bridges.
       */
      function hasWirelessPathToHealthyBranch(node) {
        if (!node) return false;

        // Find all wireless links connected to this node
        const wirelessLinks = edges.filter(
          (e) => e.isWirelessLink && (e.from === node || e.to === node)
        );

        if (wirelessLinks.length === 0) return false;

        // For each wireless link, check if it leads to a healthy branch
        for (const link of wirelessLinks) {
          const otherEnd = link.from === node ? link.to : link.from;

          // Skip if other end is not alive
          if (!otherEnd || otherEnd.state !== "alive") continue;

          // If connected to a satellite, check if that satellite connects to a healthy branch
          if (otherEnd.isSatellite) {
            // Check satellite's other connections
            const satelliteLinks = edges.filter(
              (e) =>
                e.isWirelessLink &&
                (e.from === otherEnd || e.to === otherEnd) &&
                e !== link // Don't check the link back to original node
            );

            for (const satLink of satelliteLinks) {
              const destination =
                satLink.from === otherEnd ? satLink.to : satLink.from;
              if (!destination || destination.state !== "alive") continue;

              // Check if destination has a path to central node through healthy nodes
              if (hasHealthyPathToCentral(destination)) {
                return true;
              }
            }
          }
          // If directly connected to a ground station or node, check its path to central
          else if (hasHealthyPathToCentral(otherEnd)) {
            return true;
          }
        }

        return false;
      }

      /**
       * Check if a node has a healthy path to the central node through its tree structure.
       */
      function hasHealthyPathToCentral(node) {
        if (!node || node.state !== "alive") return false;

        // Central node is always healthy (blue or green)
        if (node.parent === null) {
          return node.status === "blue" || node.status === "green";
        }

        // Check if this node and all ancestors up to central are healthy
        let current = node;
        while (current) {
          // Red, malware, botnet, or commandControl nodes block the path
          if (
            current.status === "red" ||
            current.status === "malware" ||
            current.status === "botnet" ||
            current.status === "commandControl"
          ) {
            return false;
          }

          // If we reached the central node and it's healthy, path is good
          if (current.parent === null) {
            return current.status === "blue" || current.status === "green";
          }

          current = current.parent;
        }

        return false;
      }

      function propagateStatus(parentNode, status, preserveMalware = false) {
        for (const child of parentNode.children) {
          if (!child || child.isSatellite) continue;

          // If we are propagating a healing status, do not overwrite an active 'malware' or 'botnet' status.
          if (
            preserveMalware &&
            (child.status === "malware" ||
              child.status === "botnet" ||
              child.status === "commandControl")
          ) {
            // Recursively call to heal nodes *below* this infected one.
            propagateStatus(child, status, preserveMalware);
            // Then, skip changing the status of the malware node itself.
            continue;
          }

          // NEW: When propagating yellow (impacted) status, check for alternate wireless paths
          // If the child has a wireless connection to a healthy branch, skip marking it yellow
          if (status === "yellow" && hasWirelessPathToHealthyBranch(child)) {
            // Node has alternate connectivity via satellite network, keep it green
            if (child.status !== "green") {
              child.status = "green";
            }
            // Still recurse to check children, but don't propagate yellow
            propagateStatus(child, "green", preserveMalware);
            continue;
          }

          child.status = status;
          propagateStatus(child, status, preserveMalware);
        }
      }

      // --- Self-healing and dynamic growth functions ---
      function healNetwork() {
        const HEAL_DELAY = 2000 / healSpeedMultiplier;
        const SELF_HEAL_DELAY = 3000 / healSpeedMultiplier; // Yellow nodes with healthy parents heal after 3 seconds

        // First, check for yellow nodes with healthy parents that should self-heal
        const yellowNodesWithHealthyParent = nodes.filter(
          (n) =>
            n.status === "yellow" &&
            n.parent &&
            n.state === "alive" &&
            !n.isSatellite &&
            (n.parent.status === "green" ||
              (n.parent.parent === null && n.parent.status === "blue")) &&
            Date.now() > n.statusChangedAt + SELF_HEAL_DELAY
        );

        if (yellowNodesWithHealthyParent.length > 0) {
          // Heal these nodes directly to green
          yellowNodesWithHealthyParent.forEach((node) => {
            updateNodeStatus(node, "green");
          });
          return;
        }

        // NEW: Check for yellow nodes with wireless paths to healthy branches
        const yellowNodesWithWirelessPath = nodes.filter(
          (n) =>
            n.status === "yellow" &&
            n.state === "alive" &&
            !n.isSatellite &&
            hasWirelessPathToHealthyBranch(n) &&
            Date.now() > n.statusChangedAt + SELF_HEAL_DELAY
        );

        if (yellowNodesWithWirelessPath.length > 0) {
          // Heal these nodes via satellite connectivity
          yellowNodesWithWirelessPath.forEach((node) => {
            updateNodeStatus(node, "green");
          });
          return;
        }

        // Then, handle yellow nodes with red parents (adoption logic)
        const yellowNodes = nodes.filter(
          (n) =>
            n.status === "yellow" &&
            n.parent &&
            n.parent.status === "red" &&
            !n.isHealing &&
            Date.now() > n.parent.statusChangedAt + HEAL_DELAY
        );
        if (yellowNodes.length === 0) return;

        const targetNode = yellowNodes[0];

        const potentialHealers = nodes.filter((n) => {
          if (n.status !== "green" || n.state !== "alive") return false;
          if (n.id === targetNode.id) return false;
          if (n.isSatellite) return false; // Satellites cannot adopt nodes
          if (isDescendant(targetNode, n)) return false;
          // Don't adopt if it would push subtree beyond max depth
          if (getNodeDepth(n) >= MAX_BRANCH_DEPTH) return false;
          return true;
        });

        if (potentialHealers.length === 0) return;

        let closestHealer = null;
        let minDistance = Infinity;
        let minCost = Infinity;
        const centerX = canvas.width / 2;

        potentialHealers.forEach((healer) => {
          const dx = healer.x - targetNode.x;
          const dy = targetNode.y - healer.y;
          const distanceSq = dx * dx + dy * dy;

          let penalty = 0;
          // Add a penalty for crossing the vertical centerline to prevent criss-crossing
          if (
            (targetNode.x > centerX && healer.x < centerX) ||
            (targetNode.x < centerX && healer.x > centerX)
          ) {
            penalty = 300 * 300; // Large penalty equivalent to a 300px distance squared
          }

          const cost = distanceSq + penalty;

          if (cost < minCost) {
            minCost = cost;
            minDistance = distanceSq;
            closestHealer = healer;
          }
        });

        if (closestHealer && minDistance < 75 * 75) {
          targetNode.isHealing = true;

          const oldParent = targetNode.parent;
          edges = edges.filter(
            (edge) => !(edge.from === oldParent && edge.to === targetNode)
          );
          oldParent.children = oldParent.children.filter(
            (child) => child.id !== targetNode.id
          );

          targetNode.parent = closestHealer;
          closestHealer.children.push(targetNode);
          edges.push({ from: closestHealer, to: targetNode });

          updateNodeStatus(targetNode, "green");
        }
      }

      function adoptRedNodes() {
        const ADOPTION_DELAY = 2000 / healSpeedMultiplier;
        const redNodesToAdopt = nodes.filter(
          (n) =>
            n.status === "red" &&
            n.parent &&
            !n.isHealing &&
            n.children.length > 0 &&
            Date.now() > n.statusChangedAt + ADOPTION_DELAY
        );

        if (redNodesToAdopt.length === 0) return;

        const targetNode = redNodesToAdopt[0];

        const potentialAdopters = nodes.filter((n) => {
          if (n.status !== "green" || n.state !== "alive") return false;
          if (n.id === targetNode.id) return false;
          if (n.isSatellite) return false; // Satellites cannot adopt nodes
          if (n.parent === targetNode) return false;
          if (targetNode.parent && targetNode.parent.id === n.id) return false;
          if (isDescendant(targetNode, n)) return false;
          // Don't adopt if it would push subtree beyond max depth
          if (getNodeDepth(n) >= MAX_BRANCH_DEPTH) return false;
          return true;
        });

        if (potentialAdopters.length === 0) return;

        let closestAdopter = null;
        let minDistance = Infinity;
        let minCost = Infinity;
        const centerX = canvas.width / 2;

        potentialAdopters.forEach((adopter) => {
          const dx = adopter.x - targetNode.x;
          const dy = adopter.y - targetNode.y;
          const distanceSq = dx * dx + dy * dy;

          let penalty = 0;
          // Add a penalty for crossing the vertical centerline to prevent criss-crossing
          if (
            (targetNode.x > centerX && adopter.x < centerX) ||
            (targetNode.x < centerX && adopter.x > centerX)
          ) {
            penalty = 300 * 300; // Large penalty equivalent to a 300px distance squared
          }

          const cost = distanceSq + penalty;

          if (cost < minCost) {
            minCost = cost;
            minDistance = distanceSq;
            closestAdopter = adopter;
          }
        });

        if (closestAdopter && minDistance < 75 * 75) {
          targetNode.isHealing = true;

          const oldParent = targetNode.parent;
          if (oldParent) {
            edges = edges.filter(
              (edge) => !(edge.from === oldParent && edge.to === targetNode)
            );
            oldParent.children = oldParent.children.filter(
              (c) => c !== targetNode
            );
          }

          targetNode.parent = closestAdopter;
          closestAdopter.children.push(targetNode);
          edges.push({ from: closestAdopter, to: targetNode });

          updateNodeStatus(targetNode, "green");
        }
      }

      function countDescendants(node) {
        let count = node.children.filter(
          (child) => child && !child.isSatellite
        ).length;
        node.children.forEach((child) => {
          if (!child || child.isSatellite) return;
          count += countDescendants(child);
        });
        return count;
      }

      function isNodeInDDOSBranch(node) {
        // Check if node is part of a branch under DDOS attack
        if (!node || node.parent === null) return false; // Central node never affected

        // Walk up to find the main branch (direct child of central)
        let current = node;
        while (current.parent && current.parent.parent !== null) {
          current = current.parent;
        }

        // current is now the main branch node (direct child of central)
        return current.isUnderDDOS === true;
      }

      function hasBotnetMeshConnections(node) {
        // Check if a node has any botnet mesh connections
        return edges.some(
          (edge) =>
            edge.isBotnetMesh && (edge.from === node || edge.to === node)
        );
      }

      function getNodeDefenseBonus(node) {
        if (!node) return 0;
        if (node.isGuardian) return 0.75;
        if (node.parent === null) return 0; // Central node uses different logic

        const descendantCount = countDescendants(node);

        if (descendantCount >= 6) return 0.15; // 15% bonus
        if (descendantCount >= 4) return 0.1; // 10% bonus
        if (descendantCount >= 2) return 0.05; // 5% bonus
        return 0; // No bonus
      }

      function getNodeDepth(node) {
        let depth = 0;
        let current = node;
        while (current.parent) {
          depth++;
          current = current.parent;
        }
        return depth;
      }

      function isDescendant(parent, potentialChild) {
        if (parent.children.length === 0) return false;
        for (const child of parent.children) {
          if (child.id === potentialChild.id) return true;
          if (isDescendant(child, potentialChild)) return true;
        }
        return false;
      }

      function resolveCrossings() {
        const CROSSING_CHECK_DELAY = 1000;
        if (Date.now() - lastCrossingCheck < CROSSING_CHECK_DELAY) {
          return;
        }
        lastCrossingCheck = Date.now();

        // Only check tree edges (parent-child), not wireless/mesh/VPN links
        const edgesToCheck = edges.filter(
          (e) =>
            e.from &&
            e.to &&
            e.from.state === "alive" &&
            e.to.state === "alive" &&
            !e.isWirelessLink &&
            !e.isBotnetMesh &&
            !e.isGuardianVpnTunnel &&
            !e.isDDOSAttack
        );

        for (let i = 0; i < edgesToCheck.length; i++) {
          for (let j = i + 1; j < edgesToCheck.length; j++) {
            const edge1 = edgesToCheck[i];
            const edge2 = edgesToCheck[j];

            if (
              edge1.from === edge2.from ||
              edge1.from === edge2.to ||
              edge1.to === edge2.from ||
              edge1.to === edge2.to
            ) {
              continue;
            }

            if (linesIntersect(edge1.from, edge1.to, edge2.from, edge2.to)) {
              const nodeToMove =
                getNodeDepth(edge1.to) > getNodeDepth(edge2.to)
                  ? edge1.to
                  : edge2.to;
              const potentialNewParent =
                nodeToMove === edge1.to ? edge2.from : edge1.from;
              const oldParent = nodeToMove.parent;

              if (
                oldParent &&
                nodeToMove.status !== "malware" &&
                !nodeToMove.isGroundStation && // Ground stations never move from parent
                !nodeToMove.isSatellite && // Satellites are free-floating
                (potentialNewParent.status === "green" ||
                  potentialNewParent.status === "blue") &&
                !isDescendant(nodeToMove, potentialNewParent) &&
                potentialNewParent !== nodeToMove
              ) {
                oldParent.children = oldParent.children.filter(
                  (child) => child.id !== nodeToMove.id
                );
                nodeToMove.parent = potentialNewParent;
                potentialNewParent.children.push(nodeToMove);

                const edgeToUpdate = edges.find(
                  (e) => e.to.id === nodeToMove.id
                );
                if (edgeToUpdate) {
                  edgeToUpdate.from = potentialNewParent;
                }
                return;
              }
            }
          }
        }
      }

      function spreadMalware() {
        const MULTI_INFECTION_CHANCE = 0.1 * attackFreqMultiplier;
        const DOWNSTREAM_INFECTION_CHANCE = 0.08 * attackFreqMultiplier;
        const UPSTREAM_ATTACK_CHANCE = 0.02 * attackFreqMultiplier;

        // Filter for malware/botnet nodes that are ready to spread (passed their delay and have spreading enabled)
        const malwareNodes = nodes.filter(
          (n) =>
            (n.status === "malware" ||
              n.status === "botnet" ||
              n.status === "commandControl") &&
            n.state === "alive" &&
            n.spreadingInfections.length === 0 &&
            n.canSpread &&
            n.infectedAt &&
            Date.now() > n.infectedAt + n.spreadDelay
        );

        malwareNodes.forEach((node) => {
          if (Math.random() < MULTI_INFECTION_CHANCE) {
            const neighbors = [...node.children];
            if (node.parent) {
              neighbors.push(node.parent);
            }

            const validTargets = neighbors.filter(
              (n) =>
                n &&
                !n.isSatellite &&
                !n.isGroundStation &&
                n.state === "alive" &&
                n.status !== "malware" &&
                n.status !== "botnet" &&
                n.status !== "down" &&
                !n.isBeingInfected
            );

            validTargets.forEach((target) => {
              node.spreadingInfections.push({
                target: target,
                startTime: Date.now(),
              });
              if (target.parent !== null) {
                target.isBeingInfected = true;
              }
            });
          } else {
            if (Math.random() < DOWNSTREAM_INFECTION_CHANCE) {
              const potentialTargets = node.children.filter(
                (n) =>
                  n &&
                  !n.isSatellite &&
                  !n.isGroundStation &&
                  n.state === "alive" &&
                  n.status !== "malware" &&
                  n.status !== "down" &&
                  !n.isBeingInfected
              );
              if (potentialTargets.length > 0) {
                const target =
                  potentialTargets[
                    Math.floor(Math.random() * potentialTargets.length)
                  ];
                node.spreadingInfections.push({
                  target: target,
                  startTime: Date.now(),
                });
                target.isBeingInfected = true;
                return;
              }
            }

            if (Math.random() < UPSTREAM_ATTACK_CHANCE) {
              const parent = node.parent;
              if (
                parent &&
                !parent.isSatellite &&
                !parent.isGroundStation &&
                parent.state === "alive" &&
                parent.status !== "malware" &&
                parent.status !== "botnet" &&
                parent.status !== "down" &&
                !parent.isBeingInfected
              ) {
                node.spreadingInfections.push({
                  target: parent,
                  startTime: Date.now(),
                });
                if (parent.parent !== null) {
                  parent.isBeingInfected = true;
                }
              }
            }
          }
        });
      }

      function optimizeBotnetMesh() {
        // Periodically restructure mesh to prefer shorter connections
        if (Math.random() > 0.05) return; // Only optimize 5% of frames

        const MAX_MESH_CONNECTIONS = 5;
        const MAX_CC_MESH_CONNECTIONS = 10; // C&C nodes can have more connections

        // Helper function to get max connections for a node
        const getMaxConnections = (node) => {
          return node.status === "commandControl" || node.isCommandControl
            ? MAX_CC_MESH_CONNECTIONS
            : MAX_MESH_CONNECTIONS;
        };

        // Find all botnet nodes (including C&C)
        const botnetNodes = nodes.filter(
          (n) =>
            (n.status === "botnet" || n.status === "commandControl") &&
            n.state === "alive" &&
            n.parent !== null
        );

        if (botnetNodes.length < 3) return;

        // For each botnet node, consider optimizing its connections
        botnetNodes.forEach((node) => {
          // Skip if this botnet is currently participating in a DDOS attack
          const isInActiveDDOS = nodes.some(
            (n) =>
              n.status === "commandControl" &&
              n.ddosState === "active" &&
              n.ddosBotnets &&
              n.ddosBotnets.includes(node)
          );
          if (isInActiveDDOS) return;

          // Get current mesh connections for this node
          const currentMeshEdges = edges.filter(
            (edge) =>
              edge.isBotnetMesh && (edge.from === node || edge.to === node)
          );

          if (currentMeshEdges.length === 0) return;

          // Find the longest current connection
          let longestEdge = null;
          let longestDistance = 0;

          currentMeshEdges.forEach((edge) => {
            const other = edge.from === node ? edge.to : edge.from;
            const dx = other.x - node.x;
            const dy = other.y - node.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > longestDistance) {
              longestDistance = distance;
              longestEdge = edge;
            }
          });

          // Find nearby botnet nodes that could be better connections
          const nearbyBotnets = botnetNodes.filter((other) => {
            if (other === node) return false;
            if (other.parent === node || node.parent === other) return false;

            // Check if already connected
            const alreadyConnected = edges.some(
              (edge) =>
                edge.isBotnetMesh &&
                ((edge.from === node && edge.to === other) ||
                  (edge.from === other && edge.to === node))
            );
            if (alreadyConnected) return false;

            // Calculate distance
            const dx = other.x - node.x;
            const dy = other.y - node.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // Only consider if significantly closer than longest edge
            return distance < longestDistance * 0.7;
          });

          if (nearbyBotnets.length === 0) return;

          // Find the closest candidate
          let closestNode = null;
          let closestDistance = Infinity;

          nearbyBotnets.forEach((other) => {
            // Check if other node has room for more connections
            const otherMeshCount = edges.filter(
              (edge) =>
                edge.isBotnetMesh && (edge.from === other || edge.to === other)
            ).length;

            if (otherMeshCount >= getMaxConnections(other)) return;

            const dx = other.x - node.x;
            const dy = other.y - node.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < closestDistance) {
              closestDistance = distance;
              closestNode = other;
            }
          });

          // If we found a better connection, make the swap
          if (closestNode && longestEdge) {
            // Remove longest edge
            const edgeIndex = edges.indexOf(longestEdge);
            if (edgeIndex !== -1) {
              edges.splice(edgeIndex, 1);
            }

            // Add new shorter edge
            edges.push({ from: node, to: closestNode, isBotnetMesh: true });
          }
        });
      }

      function detectAndFormBotnets() {
        // First, remove all botnet mesh connections that involve non-botnet nodes
        edges = edges.filter((edge) => {
          if (edge.isBotnetMesh) {
            // Keep mesh edge only if both nodes are still malware, botnet, or C&C
            return (
              (edge.from.status === "malware" ||
                edge.from.status === "botnet" ||
                edge.from.status === "commandControl") &&
              (edge.to.status === "malware" ||
                edge.to.status === "botnet" ||
                edge.to.status === "commandControl") &&
              edge.from.state === "alive" &&
              edge.to.state === "alive"
            );
          }
          return true; // Keep non-mesh edges
        });

        // Find all infected nodes (malware, botnet, or C&C, excluding central node)
        const infectedNodes = nodes.filter(
          (n) =>
            (n.status === "malware" ||
              n.status === "botnet" ||
              n.status === "commandControl") &&
            n.state === "alive" &&
            n.parent !== null
        );

        // Find connected clusters of infected nodes
        const visited = new Set();
        const clusters = [];

        function findConnectedInfected(node, cluster) {
          if (
            visited.has(node.id) ||
            (node.status !== "malware" &&
              node.status !== "botnet" &&
              node.status !== "commandControl") ||
            node.parent === null
          )
            return;

          visited.add(node.id);
          cluster.push(node);

          // Check connected nodes (parent, children, AND mesh connections)
          const connected = [...node.children];
          if (node.parent) connected.push(node.parent);

          // Also check for botnet mesh connections
          edges.forEach((edge) => {
            if (edge.isBotnetMesh) {
              if (edge.from === node && !connected.includes(edge.to)) {
                connected.push(edge.to);
              } else if (edge.to === node && !connected.includes(edge.from)) {
                connected.push(edge.from);
              }
            }
          });

          connected.forEach((connectedNode) => {
            if (
              connectedNode &&
              (connectedNode.status === "malware" ||
                connectedNode.status === "botnet" ||
                connectedNode.status === "commandControl")
            ) {
              findConnectedInfected(connectedNode, cluster);
            }
          });
        }

        // Find all clusters
        infectedNodes.forEach((node) => {
          if (!visited.has(node.id)) {
            const cluster = [];
            findConnectedInfected(node, cluster);
            clusters.push(cluster);
          }
        });

        // Process each cluster
        clusters.forEach((cluster) => {
          // Check if cluster is large enough to form a C&C node
          if (cluster.length >= 7) {
            // Filter out any existing C&C nodes from the cluster
            const botnetNodesInCluster = cluster.filter(
              (n) => n.status === "botnet"
            );

            // Only form C&C if we have 7+ botnet nodes (not C&C)
            if (botnetNodesInCluster.length >= 7) {
              // Filter out first-level branch nodes (direct children of central node)
              // C&C should be deeper in the mesh, behind protective botnet nodes
              const eligibleForCC = botnetNodesInCluster.filter(
                (n) => n.parent !== nodes[0]
              );

              // Require at least 7 eligible nodes - don't allow first-level nodes as C&C
              if (eligibleForCC.length < 7) {
                return; // Skip C&C formation for this cluster
              }

              // Sort nodes by number of descendants (leaf nodes first)
              const nodesWithDescendants = eligibleForCC
                .map((node) => ({
                  node: node,
                  descendants: countDescendants(node),
                }))
                .sort((a, b) => a.descendants - b.descendants);

              // Pick 4 nodes with fewest descendants to collapse into C&C
              // The 5th node (at index 4) becomes the C&C node itself
              const nodesToRemove = nodesWithDescendants
                .slice(0, 4)
                .map((n) => n.node);
              const ccNode = nodesWithDescendants[4].node; // 5th node becomes C&C

              // Retract the 4 nodes sequentially
              nodesToRemove.forEach((node, index) => {
                // Delay retraction sequentially for visual effect (0.5 second intervals)
                setTimeout(() => {
                  // Find nodes connected via mesh edges before removing
                  const meshConnectedNodes = [];
                  edges.forEach((edge) => {
                    if (edge.isBotnetMesh) {
                      if (
                        edge.from === node &&
                        edge.to.state === "alive" &&
                        !nodesToRemove.includes(edge.to)
                      ) {
                        meshConnectedNodes.push(edge.to);
                      } else if (
                        edge.to === node &&
                        edge.from.state === "alive" &&
                        !nodesToRemove.includes(edge.from)
                      ) {
                        meshConnectedNodes.push(edge.from);
                      }
                    }
                  });

                  // Reassign children before retracting
                  if (node.children.length > 0) {
                    node.children.forEach((child) => {
                      // Find a safe parent - prefer one that's NOT being removed
                      let safeParent = node.parent;

                      // If current parent is also being removed, use ccNode instead
                      if (nodesToRemove.includes(safeParent)) {
                        safeParent = ccNode;
                      }

                      // If parent is nucleus or ccNode, keep them there
                      if (
                        !nodesToRemove.includes(child) &&
                        safeParent &&
                        safeParent.state === "alive"
                      ) {
                        child.parent = safeParent;
                        safeParent.children.push(child);
                        // Update edge
                        edges = edges.filter(
                          (e) => !(e.from === node && e.to === child)
                        );
                        if (
                          !edges.some(
                            (e) => e.from === safeParent && e.to === child
                          )
                        ) {
                          edges.push({ from: safeParent, to: child });
                        }
                      }
                    });
                    // Clear children array to allow retraction animation to proceed
                    node.children = [];
                  }

                  // Reconnect mesh-connected nodes to ccNode
                  meshConnectedNodes.forEach((connectedNode) => {
                    // Connect to ccNode if not already connected
                    const alreadyConnected = edges.some(
                      (e) =>
                        (e.from === ccNode && e.to === connectedNode) ||
                        (e.from === connectedNode && e.to === ccNode)
                    );
                    if (!alreadyConnected) {
                      edges.push({
                        from: ccNode,
                        to: connectedNode,
                        isBotnetMesh: true,
                      });
                    }
                  });

                  // Remove from parent's children
                  if (node.parent) {
                    node.parent.children = node.parent.children.filter(
                      (c) => c !== node
                    );
                  }

                  // Clean up immunity packets attached to this node
                  if (
                    node.attachedImmunityPackets &&
                    node.attachedImmunityPackets.length > 0
                  ) {
                    node.attachedImmunityPackets.forEach((packet) => {
                      packet.active = false;
                      packet.isAttached = false;
                      packet.attachedNode = null;
                    });
                    node.attachedImmunityPackets = [];
                    node.isImmunityHealing = false;
                    node.immunityHealingStartTime = 0;
                  }

                  // Mark for retraction
                  node.state = "retracting";

                  // Clear targeting flag and remove any pulses targeting this node
                  node.isTargeted = false;

                  // Remove pulses targeting this node to prevent particle shower
                  pulses = pulses.filter((p) => p.target !== node);

                  // Remove mesh edges
                  edges = edges.filter((e) => e.from !== node && e.to !== node);
                }, index * 500); // 500ms delay between each (2 seconds total for 4 nodes)
              });

              const clusterSize = cluster.length;

              // Transform the ccNode to C&C after all nodes retract
              setTimeout(() => {
                if (ccNode.state === "alive") {
                  ccNode.status = "commandControl";
                  ccNode.isCommandControl = true;
                  ccNode.statusChangedAt = Date.now();
                  ccNode.baseRadius = 20;
                  ccNode.targetRadius = 20;
                  ccNode.currentColor = { ...colors.commandControl };
                  logEvent("commandControlDetected", {
                    node: ccNode,
                    clusterSize,
                  });
                }
              }, 2000); // After 4 nodes retract (2 seconds)

              // Create mesh connections from C&C to remaining botnet nodes in cluster
              // (excluding the removed nodes and the ccNode itself)
              // C&C can have up to 10 connections, prioritize closer nodes
              const remainingNodes = cluster.filter(
                (n) => !nodesToRemove.includes(n) && n !== ccNode
              );

              // Sort by distance to prioritize closer nodes
              const nodesWithDistance = remainingNodes
                .map((node) => ({
                  node: node,
                  distance: Math.sqrt(
                    (node.x - ccNode.x) ** 2 + (node.y - ccNode.y) ** 2
                  ),
                }))
                .sort((a, b) => a.distance - b.distance);

              // Count existing C&C mesh connections (start at 0)
              let ccMeshCount = 0;
              const MAX_CC_MESH = 10;

              nodesWithDistance.forEach(({ node }) => {
                if (ccMeshCount >= MAX_CC_MESH) return; // C&C at max connections

                // Check if connection already exists
                const edgeExists = edges.some(
                  (e) =>
                    (e.from === ccNode && e.to === node) ||
                    (e.from === node && e.to === ccNode)
                );

                if (!edgeExists && botnetMeshHasClearPath(ccNode, node)) {
                  edges.push({ from: ccNode, to: node, isBotnetMesh: true });
                  ccMeshCount++;
                }
              });

              // Log C&C bridge creation
              if (ccMeshCount > 0) {
                logEvent("ccMeshBridged", { node: ccNode, count: ccMeshCount });
              }

              return; // Skip normal botnet processing for this cluster
            }
          }

          if (cluster.length >= 3) {
            // Convert to botnet and create mesh connections
            // Mark formation time for migration period
            const formationTime = Date.now();
            cluster.forEach((node) => {
              if (
                node.status !== "botnet" &&
                node.status !== "commandControl"
              ) {
                node.status = "botnet";
                node.statusChangedAt = formationTime;
                node.botnetFormationTime = formationTime; // Track for migration
              }
            });

            // Create limited mesh connections (max 3 per node, 10 for C&C) to reduce clutter
            const MAX_MESH_CONNECTIONS = 3;
            const MAX_CC_MESH_CONNECTIONS = 10;

            // Helper function to get max connections for a node
            const getMaxConnections = (node) => {
              return node.status === "commandControl" || node.isCommandControl
                ? MAX_CC_MESH_CONNECTIONS
                : MAX_MESH_CONNECTIONS;
            };

            // Track mesh connection counts for each node
            const meshCounts = new Map();
            cluster.forEach((node) => meshCounts.set(node.id, 0));

            // Count existing mesh connections
            edges.forEach((edge) => {
              if (edge.isBotnetMesh) {
                if (cluster.includes(edge.from)) {
                  meshCounts.set(
                    edge.from.id,
                    (meshCounts.get(edge.from.id) || 0) + 1
                  );
                }
                if (cluster.includes(edge.to)) {
                  meshCounts.set(
                    edge.to.id,
                    (meshCounts.get(edge.to.id) || 0) + 1
                  );
                }
              }
            });

            // Create new mesh connections up to the limit (within cluster)
            for (let i = 0; i < cluster.length; i++) {
              const nodeA = cluster[i];

              // Skip if this node already has max connections
              if (meshCounts.get(nodeA.id) >= getMaxConnections(nodeA))
                continue;

              // Skip if this botnet is currently participating in a DDOS attack
              const isNodeAInDDOS = nodes.some(
                (n) =>
                  n.status === "commandControl" &&
                  n.ddosState === "active" &&
                  n.ddosBotnets &&
                  n.ddosBotnets.includes(nodeA)
              );
              if (isNodeAInDDOS) continue;

              for (let j = i + 1; j < cluster.length; j++) {
                const nodeB = cluster[j];

                // Skip if either node has max connections
                if (meshCounts.get(nodeB.id) >= getMaxConnections(nodeB))
                  continue;
                if (meshCounts.get(nodeA.id) >= getMaxConnections(nodeA)) break;

                // Skip if nodeB is also participating in a DDOS attack
                const isNodeBInDDOS = nodes.some(
                  (n) =>
                    n.status === "commandControl" &&
                    n.ddosState === "active" &&
                    n.ddosBotnets &&
                    n.ddosBotnets.includes(nodeB)
                );
                if (isNodeBInDDOS) continue;

                // Check if edge already exists
                const edgeExists = edges.some(
                  (edge) =>
                    (edge.from === nodeA && edge.to === nodeB) ||
                    (edge.from === nodeB && edge.to === nodeA)
                );

                // Create mesh edge if possible (must have clear path)
                if (
                  !edgeExists &&
                  nodeA.parent !== nodeB &&
                  nodeB.parent !== nodeA &&
                  botnetMeshHasClearPath(nodeA, nodeB)
                ) {
                  edges.push({ from: nodeA, to: nodeB, isBotnetMesh: true });
                  meshCounts.set(nodeA.id, meshCounts.get(nodeA.id) + 1);
                  meshCounts.set(nodeB.id, meshCounts.get(nodeB.id) + 1);
                }
              }
            }

            // Bridge to nearby infected nodes within the same branch
            const BRIDGE_DISTANCE = 100; // Maximum distance to bridge within branch
            cluster.forEach((nodeA) => {
              // Skip if already at max connections
              if (meshCounts.get(nodeA.id) >= getMaxConnections(nodeA)) return;

              // Skip if this botnet is currently participating in a DDOS attack
              const isInActiveDDOS = nodes.some(
                (n) =>
                  n.status === "commandControl" &&
                  n.ddosState === "active" &&
                  n.ddosBotnets &&
                  n.ddosBotnets.includes(nodeA)
              );
              if (isInActiveDDOS) return;

              // Find nearby infected nodes NOT in this cluster (but in same branch)
              infectedNodes.forEach((nodeB) => {
                // Skip if same cluster or already at max
                if (cluster.includes(nodeB)) return;
                if (!meshCounts.has(nodeB.id)) meshCounts.set(nodeB.id, 0);
                if (meshCounts.get(nodeB.id) >= getMaxConnections(nodeB))
                  return;
                if (meshCounts.get(nodeA.id) >= getMaxConnections(nodeA))
                  return;

                // Prevent cross-branch bridging - only allow within same root branch
                const branchA = getRootBranch(nodeA);
                const branchB = getRootBranch(nodeB);
                if (branchA !== branchB) return;

                // Prevent mesh connections if EITHER branch is under DDOS attack
                if (nodeA.isUnderDDOS || (branchA && branchA.isUnderDDOS))
                  return;
                if (nodeB.isUnderDDOS || (branchB && branchB.isUnderDDOS))
                  return;

                // Check distance
                const dx = nodeB.x - nodeA.x;
                const dy = nodeB.y - nodeA.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance <= BRIDGE_DISTANCE) {
                  // Check if edge already exists
                  const edgeExists = edges.some(
                    (edge) =>
                      (edge.from === nodeA && edge.to === nodeB) ||
                      (edge.from === nodeB && edge.to === nodeA)
                  );

                  // Create bridge connection (must have clear path)
                  if (
                    !edgeExists &&
                    nodeA.parent !== nodeB &&
                    nodeB.parent !== nodeA &&
                    botnetMeshHasClearPath(nodeA, nodeB)
                  ) {
                    edges.push({ from: nodeA, to: nodeB, isBotnetMesh: true });
                    meshCounts.set(nodeA.id, meshCounts.get(nodeA.id) + 1);
                    meshCounts.set(nodeB.id, meshCounts.get(nodeB.id) + 1);
                    logEvent("botnetBridged");
                  }
                }
              });
            });
          } else {
            // Cluster has fewer than 3 nodes - downgrade botnets back to malware
            cluster.forEach((node) => {
              if (node.status === "botnet") {
                node.status = "malware";
                node.statusChangedAt = Date.now();
              }
            });

            // Remove mesh connections for this small cluster
            edges = edges.filter((edge) => {
              if (edge.isBotnetMesh) {
                const involvesCluster =
                  cluster.includes(edge.from) || cluster.includes(edge.to);
                return !involvesCluster; // Remove if it involves this cluster
              }
              return true;
            });
          }
        });
      }

      function spontaneouslySprout() {
        if (Math.random() > 0.05) return;

        const potentialParents = nodes.filter((n) => {
          if (n.state !== "alive" || n.status !== "green") return false;
          if (n.children.length >= 3 || n.isSatellite || n.isGroundStation)
            return false;
          // Limit branch depth - don't spawn children beyond max depth
          if (getNodeDepth(n) >= MAX_BRANCH_DEPTH) return false;
          return true;
        });
        if (potentialParents.length === 0) return;

        const parentNode =
          potentialParents[Math.floor(Math.random() * potentialParents.length)];

        // Simple spawning - physics will handle positioning
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        // Use baseX/baseY (target position) not x/y (which may still be animating)
        const parentRadialAngle = Math.atan2(
          parentNode.baseY - centerY,
          parentNode.baseX - centerX
        );
        const angle = parentRadialAngle + (Math.random() - 0.5) * 1.2;
        const dist = 60 + Math.random() * 30;

        const optimal = findOptimalBranchPosition(parentNode, angle, dist);

        const childNode = new Node(
          Date.now() + Math.random(),
          optimal.x,
          optimal.y,
          parentNode
        );
        parentNode.children.push(childNode);
        nodes.push(childNode);
        edges.push({ from: parentNode, to: childNode });
        applyParentStatusToChild(parentNode, childNode);
      }

      /**
       * Healthy nodes on the perimeter have a chance to sprout a ground station.
       * Ground stations launch satellites into orbit.
       */
      function sproutGroundStationFromHealthyNode() {
        if (Math.random() > GROUND_STATION_SPROUT_CHANCE) return;

        // Cap at 5 maximum ground stations
        const MAX_GROUND_STATIONS = 3;
        const activeGroundStations = nodes.filter(
          (n) => n.isGroundStation && n.state === "alive"
        );
        if (activeGroundStations.length >= MAX_GROUND_STATIONS) {
          return; // Don't spawn more ground stations if at cap
        }

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const canvasRadius = Math.min(canvas.width, canvas.height) / 2;

        // Find healthy perimeter nodes (not already ground stations, not satellites)
        const candidates = nodes.filter((n) => {
          if (n.state !== "alive" || n.status !== "green") return false;
          if (n.isSatellite || n.isGroundStation) return false;
          if (n.parent === null) return false; // Not the central node
          if (n.parent && n.parent.isGroundStation) return false; // Don't convert children of ground stations
          // Must be on the outer part of the network (>50% radius)
          const distFromCenter = Math.sqrt(
            (n.x - centerX) ** 2 + (n.y - centerY) ** 2
          );
          if (distFromCenter < canvasRadius * 0.5) return false;
          return true;
        });

        if (candidates.length === 0) return;

        // Pick a random candidate and convert to ground station
        const targetNode =
          candidates[Math.floor(Math.random() * candidates.length)];
        convertToGroundStation(targetNode);

        logEvent("custom", {
          message: `üì° Node ${targetNode.id} upgraded to Ground Station!`,
        });
      }

      /**
       * Launch a satellite from a ground station into orbit.
       * Satellites orbit freely at varying radii above the network.
       */
      function launchSatelliteFromGroundStation(groundStation) {
        if (
          !groundStation ||
          !groundStation.isGroundStation ||
          groundStation.state !== "alive"
        )
          return null;

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        // Calculate ground station's outward direction from center
        const gsOutwardAngle = Math.atan2(
          groundStation.y - centerY,
          groundStation.x - centerX
        );

        // Calculate elliptical orbital radii (spread satellites throughout orbital zone)
        // Use separate X and Y radii to match widescreen shape
        // DYNAMIC: Scale orbit based on current view scale to ensure they stay outside
        // We want orbits to be roughly 1.2x the screen size at current zoom, or at least outside the network
        const orbitBaseScale = 1 / Math.max(0.1, viewState.scale);

        const orbitRadiusRatio =
          (SATELLITE_ORBIT_RADIUS_MIN +
            Math.random() *
              (SATELLITE_ORBIT_RADIUS_MAX - SATELLITE_ORBIT_RADIUS_MIN)) *
          orbitBaseScale;

        const orbitalRadiusX = (canvas.width / 2) * orbitRadiusRatio; // Wider for widescreen
        const orbitalRadiusY = (canvas.height / 2) * orbitRadiusRatio; // Narrower vertically

        // ALWAYS launch outward from ground station within a narrow cone (¬±25¬∞ variance)
        // This ensures satellites launch near the ground station, not to distant orbital positions
        const launchAngleVariance = (Math.random() - 0.5) * (Math.PI / 3.6); // ¬±25¬∞ = ¬±0.436 radians
        const launchAngle = gsOutwardAngle + launchAngleVariance;

        // Calculate launch position (at ground station)
        const launchX = groundStation.x;
        const launchY = groundStation.y;

        // Create free-floating satellite at launch position
        const satellite = new Node(
          Date.now() + Math.random(),
          launchX,
          launchY,
          null
        );
        satellite.isSatellite = true;
        satellite.isFreefloating = true;
        satellite.launchedFrom = groundStation;
        satellite.baseRadius = 9;
        satellite.targetRadius = 9;
        satellite.radius = 9; // Start at full size
        satellite.status = "green";
        satellite.currentColor = { ...colors.satellite };
        satellite.opacity = 1; // Start fully visible
        satellite.state = "alive"; // Start alive, not spawning
        satellite.forceMultiplier = 1.0; // Full physics immediately (no spawn animation)
        satellite.children = [];
        satellite.hasFirewall = false;
        satellite.canSpread = false;
        satellite.unlinkTime = null;

        // Assign orbital parameters (elliptical orbit following screen shape)
        satellite.orbitalRadiusX = orbitalRadiusX; // Horizontal radius
        satellite.orbitalRadiusY = orbitalRadiusY; // Vertical radius
        satellite.orbitalAngle = launchAngle; // Target angle in orbit
        satellite.orbitalSpeed =
          ORBITAL_SPEED_BASE + (Math.random() - 0.5) * ORBITAL_SPEED_VARIANCE;
        satellite.orbitalDirection = Math.random() < 0.5 ? 1 : -1;
        satellite.orbitScale = 1.2 + Math.random() * 0.5; // Orbit at 1.2x to 1.7x the network radius

        // Start launch animation
        satellite.launchStartTime = Date.now();

        nodes.push(satellite);

        // Create initial wireless link to ground station
        const launchLink = {
          from: groundStation,
          to: satellite,
          isWirelessLink: true,
          pulseSeed: Math.random() * Math.PI * 2,
        };
        edges.push(launchLink);

        logEvent("custom", {
          message: `üöÄ Ground station ${
            groundStation.id
          } launched satellite into ${
            satellite.orbitalDirection > 0 ? "CCW" : "CW"
          } orbit`,
        });

        return satellite;
      }

      /**
       * Check and despawn satellites that have exceeded their maximum lifespan (3 minutes)
       */
      function checkSatelliteLifespans() {
        const now = Date.now();
        const satellites = nodes.filter(
          (n) =>
            n.isSatellite && (n.state === "alive" || n.state === "spawning")
        );

        for (const satellite of satellites) {
          const age = now - satellite.createdAt;
          if (age >= SATELLITE_MAX_LIFESPAN) {
            // Satellite has reached end of life - untether it
            untetherSatellite(satellite);
            logEvent("custom", {
              message: `üõ∞Ô∏è Satellite ${satellite.id} reached end of service life (2 min) - deorbiting...`,
            });
          }
        }
      }

      /**
       * Check and revert ground stations that have exceeded their maximum lifespan (2 minutes)
       * or have become parent to non-satellite nodes
       */
      function checkGroundStationLifespans() {
        const now = Date.now();
        const groundStations = nodes.filter(
          (n) => n.isGroundStation && n.state === "alive"
        );

        for (const gs of groundStations) {
          if (!gs.groundStationEstablishedAt)
            gs.groundStationEstablishedAt = now;

          // Check if ground station has any non-satellite children
          const hasNonSatelliteChild =
            gs.children &&
            gs.children.some(
              (child) => child && child.state === "alive" && !child.isSatellite
            );

          if (hasNonSatelliteChild) {
            // Ground station should not be a parent to regular nodes - revert it
            logEvent("custom", {
              message: `üì° Ground station ${gs.id} reverted to normal node (became parent to regular node).`,
            });
            revertGroundStationToNormalNode(gs);
            continue;
          }

          const age = now - gs.groundStationEstablishedAt;
          if (age >= GROUND_STATION_MAX_LIFESPAN) {
            // Ground station has reached end of life - revert to normal node
            logEvent("custom", {
              message: `üì° Ground station ${gs.id} reverted to normal node after 2 minutes of service.`,
            });
            revertGroundStationToNormalNode(gs);
          }
        }
      }

      /**
       * Helper function to revert a ground station back to a normal node
       */
      function revertGroundStationToNormalNode(gs) {
        if (!gs || !gs.isGroundStation) return;

        // Remove satellite chain
        removeSatelliteChain(gs);

        // Revert to regular node (don't retract)
        gs.isGroundStation = false;
        gs.baseRadius = 15;
        gs.targetRadius = 15;
        gs.radius = 15;
        gs.currentColor = { ...colors.green };
        // Keep current status (green/yellow) - don't force green if it's impacted

        // Clear ground station specific properties
        gs.groundStationEstablishedAt = null;
        gs.lastSatelliteLaunch = null;
        gs.groundStationCountdown = 0;
        gs.lastCountdownUpdate = null;
        gs.satelliteChain = [];
        gs.satelliteEdges = [];
      }

      /**
       * Ground stations launch a satellite only if they don't have an active satellite link.
       */
      function groundStationsLaunchSatellites() {
        const now = Date.now();

        // Cap at 7 maximum orbiting satellites
        const MAX_SATELLITES = 7;
        const activeSatellites = nodes.filter(
          (n) => n.isSatellite && n.state === "alive"
        );
        if (activeSatellites.length >= MAX_SATELLITES) {
          return; // Don't launch more satellites if at cap
        }

        // Allow green and yellow (impacted) ground stations to launch satellites
        const groundStations = nodes.filter(
          (n) =>
            n.isGroundStation &&
            n.state === "alive" &&
            (n.status === "green" || n.status === "yellow")
        );

        for (const gs of groundStations) {
          // Handle countdown for ground stations
          if (
            gs.groundStationCountdown !== undefined &&
            gs.groundStationCountdown > 0
          ) {
            // Decrease countdown by time since last check
            if (!gs.lastCountdownUpdate) gs.lastCountdownUpdate = now;
            const deltaTime = now - gs.lastCountdownUpdate;
            gs.groundStationCountdown = Math.max(
              0,
              gs.groundStationCountdown - deltaTime
            );
            gs.lastCountdownUpdate = now;

            if (gs.groundStationCountdown <= 0) {
              // Countdown complete - launch satellite!
              gs.groundStationCountdown = 0;
              launchSatelliteFromGroundStation(gs);
              gs.lastSatelliteLaunch = now;
              logEvent("custom", {
                message: `üõ∞Ô∏è Ground station ${gs.id} launched satellite!`,
              });
            }
            continue; // Skip normal launch logic while in countdown
          }

          if (!gs.lastSatelliteLaunch) gs.lastSatelliteLaunch = now;

          // Check if ground station already has an active satellite link
          const hasActiveSatelliteLink = edges.some(
            (e) =>
              e.isWirelessLink &&
              (e.from === gs || e.to === gs) &&
              ((e.from === gs && e.to.isSatellite && e.to.state === "alive") ||
                (e.to === gs && e.from.isSatellite && e.from.state === "alive"))
          );

          // Start countdown if no active satellite link and launch interval elapsed
          if (
            !hasActiveSatelliteLink &&
            now - gs.lastSatelliteLaunch >= GROUND_STATION_LAUNCH_INTERVAL
          ) {
            // Begin 10-second countdown
            gs.groundStationCountdown = 10000;
            gs.lastCountdownUpdate = now;
            logEvent("custom", {
              message: `üì° Ground station ${gs.id} initiating satellite launch sequence...`,
            });
          }
        }
      }

      /**
       * Update wireless links for satellites and ground stations.
       * Satellites link to ground stations and other satellites.
       * Ground stations create wireless bridges to other ground stations with clear view.
       */
      function updateSatelliteWirelessLinks() {
        // Calculate wireless link max distance as 25% of screen diagonal
        const screenDiagonal = Math.sqrt(
          canvas.width * canvas.width + canvas.height * canvas.height
        );
        const WIRELESS_LINK_MAX_DISTANCE =
          screenDiagonal * WIRELESS_LINK_MAX_DISTANCE_RATIO;

        const aliveSatellites = nodes.filter(
          (n) => n.isSatellite && n.state === "alive"
        );
        const groundStations = nodes.filter(
          (n) => n.isGroundStation && n.state === "alive"
        );

        // Remove stale wireless links (where one end is gone, no clear view, or too far)
        for (let i = edges.length - 1; i >= 0; i--) {
          const edge = edges[i];
          if (!edge.isWirelessLink) continue;

          const fromAlive = edge.from && edge.from.state === "alive";
          const toAlive = edge.to && edge.to.state === "alive";

          if (!fromAlive || !toAlive) {
            edges.splice(i, 1);
            continue;
          }

          // Drop wireless links to compromised/down ground stations (but allow impacted/yellow)
          const fromIsCompromisedGS =
            edge.from &&
            edge.from.isGroundStation &&
            (edge.from.status === "red" ||
              edge.from.status === "malware" ||
              edge.from.status === "botnet" ||
              edge.from.status === "commandControl");
          const toIsCompromisedGS =
            edge.to &&
            edge.to.isGroundStation &&
            (edge.to.status === "red" ||
              edge.to.status === "malware" ||
              edge.to.status === "botnet" ||
              edge.to.status === "commandControl");

          if (fromIsCompromisedGS || toIsCompromisedGS) {
            edges.splice(i, 1);
            continue;
          }

          // Check distance - remove if too far
          const dx = edge.to.x - edge.from.x;
          const dy = edge.to.y - edge.from.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          if (distance > WIRELESS_LINK_MAX_DISTANCE) {
            edges.splice(i, 1);
            continue;
          }

          // Check if still have clear view
          if (!nodesHaveClearView(edge.from, edge.to)) {
            edges.splice(i, 1);
          }
        }

        // Create new wireless links for satellites
        for (const sat of aliveSatellites) {
          // Link to ground stations (healthy and impacted, but not compromised)
          for (const gs of groundStations) {
            // Skip compromised/down ground stations (allow yellow/impacted for redundancy)
            if (
              gs.status === "red" ||
              gs.status === "malware" ||
              gs.status === "botnet" ||
              gs.status === "commandControl"
            )
              continue;
            if (hasAnyEdgeBetween(sat, gs)) continue;

            // Check distance
            const dx = gs.x - sat.x;
            const dy = gs.y - sat.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance > WIRELESS_LINK_MAX_DISTANCE) continue;

            if (nodesHaveClearView(sat, gs)) {
              edges.push({
                from: sat,
                to: gs,
                isWirelessLink: true,
                pulseSeed: Math.random() * Math.PI * 2,
              });
            }
          }

          // Link to nearby satellites (mesh network, within 100px range)
          for (const other of aliveSatellites) {
            if (other === sat) continue;
            if (hasAnyEdgeBetween(sat, other)) continue;

            // Check distance
            const dx = other.x - sat.x;
            const dy = other.y - sat.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance > WIRELESS_LINK_MAX_DISTANCE) continue;

            if (nodesHaveClearView(sat, other)) {
              edges.push({
                from: sat,
                to: other,
                isWirelessLink: true,
                isSatelliteMesh: true,
                pulseSeed: Math.random() * Math.PI * 2,
              });
            }
          }
        }

        // Create wireless bridges between ground stations with clear view
        for (let i = 0; i < groundStations.length; i++) {
          const gs1 = groundStations[i];
          // Skip compromised/down ground stations
          if (
            gs1.status === "red" ||
            gs1.status === "malware" ||
            gs1.status === "botnet" ||
            gs1.status === "commandControl"
          )
            continue;

          for (let j = i + 1; j < groundStations.length; j++) {
            const gs2 = groundStations[j];
            // Skip compromised/down ground stations
            if (
              gs2.status === "red" ||
              gs2.status === "malware" ||
              gs2.status === "botnet" ||
              gs2.status === "commandControl"
            )
              continue;

            // Skip if already connected
            if (hasAnyEdgeBetween(gs1, gs2)) continue;

            // Check distance
            const dx = gs2.x - gs1.x;
            const dy = gs2.y - gs1.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance > WIRELESS_LINK_MAX_DISTANCE) continue;

            // Check clear view and create bridge
            if (nodesHaveClearView(gs1, gs2)) {
              edges.push({
                from: gs1,
                to: gs2,
                isWirelessLink: true,
                isGroundStationBridge: true,
                pulseSeed: Math.random() * Math.PI * 2,
              });
              logEvent("custom", {
                message: `üì° Wireless bridge established between ground stations ${gs1.id} and ${gs2.id}`,
              });
            }
          }
        }
      }

      /**
       * Detect and merge ground stations that connect via wireless links.
       * When two ground stations link up, collapse them into one.
       */
      function mergeConnectedGroundStations() {
        const groundStations = nodes.filter(
          (n) => n.isGroundStation && n.state === "alive"
        );
        if (groundStations.length < 2) return;

        // Find pairs of ground stations connected by wireless links
        for (let i = 0; i < groundStations.length; i++) {
          const gs1 = groundStations[i];

          // Check if gs1 has wireless link to another ground station
          const connectedGS = edges.find(
            (edge) =>
              edge.isWirelessLink &&
              ((edge.from === gs1 &&
                edge.to.isGroundStation &&
                edge.to.state === "alive") ||
                (edge.to === gs1 &&
                  edge.from.isGroundStation &&
                  edge.from.state === "alive"))
          );

          if (connectedGS) {
            const gs2 =
              connectedGS.from === gs1 ? connectedGS.to : connectedGS.from;

            // Keep the older ground station, remove the newer one
            const keepStation =
              gs1.groundStationEstablishedAt <= gs2.groundStationEstablishedAt
                ? gs1
                : gs2;
            const removeStation = keepStation === gs1 ? gs2 : gs1;

            logEvent("custom", {
              message: `üì° Ground stations ${keepStation.id} and ${removeStation.id} merged - consolidating operations.`,
            });

            // Transfer satellites from removed station to kept station
            if (
              removeStation.satelliteChain &&
              removeStation.satelliteChain.length > 0
            ) {
              removeStation.satelliteChain.forEach((sat) => {
                if (sat && sat.state === "alive") {
                  sat.satelliteHost = keepStation;
                  if (!keepStation.satelliteChain)
                    keepStation.satelliteChain = [];
                  keepStation.satelliteChain.push(sat);
                }
              });
            }

            // Demote and prune the removed station
            removeSatelliteChain(removeStation);
            removeStation.isGroundStation = false;
            removeStation.baseRadius = 15;
            removeStation.targetRadius = 15;
            removeStation.currentColor = { ...colors.green };
            removeStation.status = "green";

            // Clear ground station specific properties
            removeStation.groundStationEstablishedAt = null;
            removeStation.lastSatelliteLaunch = null;
            removeStation.groundStationCountdown = 0;
            removeStation.lastCountdownUpdate = null;
            removeStation.satelliteChain = [];
            removeStation.satelliteEdges = [];

            markBranchForRetraction(removeStation, {
              allowGroundStation: true,
            });

            // Only merge one pair per frame to avoid cascading issues
            return;
          }
        }
      }

      function simulateNetworkEvents() {
        const rootNode = nodes[0];
        if (rootNode) {
          const SELF_HEAL_DELAY = 5000 / healSpeedMultiplier;
          if (
            (rootNode.status === "malware" ||
              rootNode.status === "botnet" ||
              rootNode.status === "commandControl") &&
            !rootNode.isSelfHealing
          ) {
            if (Date.now() > rootNode.statusChangedAt + SELF_HEAL_DELAY) {
              rootNode.isSelfHealing = true;
              rootNode.selfHealingStartTime = Date.now();
              const directChildren = (rootNode.children || []).filter(
                (ch) => ch && ch.state === "alive"
              );
              rootNode.selfHealingPacketCap = directChildren.length * 4 * 2; // double the normal per-branch spawn
              rootNode.selfHealingPacketsCreated = 0;
              rootNode.selfHealingDispatchAllowance = 0;
              logEvent("centralUnderAttack");
            }
          }
        }

        const aliveNodes = nodes.filter(
          (n) => n.state === "alive" && n.parent !== null && !n.isSatellite
        );
        if (aliveNodes.length === 0) return;

        const RED_NODE_TIMEOUT = 10000 / healSpeedMultiplier;
        aliveNodes
          .filter((n) => n.status === "red")
          .forEach((node) => {
            // Allow all red nodes to heal after timeout to prevent deadlocks
            if (Date.now() > node.statusChangedAt + RED_NODE_TIMEOUT) {
              // Default: 10% chance to become malware, 90% chance to heal to green
              // If hit by ping of death: 50% chance to become malware!
              let malwareChance = 0.1;
              if (node.hitByPingOfDeath) {
                malwareChance = 0.5; // Significantly higher chance
                node.hitByPingOfDeath = false; // Clear the flag
              }
              const newStatus =
                Math.random() < malwareChance ? "malware" : "green";
              updateNodeStatus(node, newStatus);

              // Chance to promote recovered nodes to guardians if they endured a ping of death
              if (
                newStatus === "green" &&
                node.hitByPingOfDeath === false &&
                Math.random() < 0.25
              ) {
                promoteToGuardian(node, "guardianPromotionPingRecovery");
              }
            }
          });

        // DISABLED: Logic for decaying entire branches that are down for 5 seconds
        // const BRANCH_DECAY_TIMEOUT = 5000;
        // if (rootNode && rootNode.children) {
        //     const downBranches = rootNode.children.filter(branch =>
        //         branch.status === 'red' &&
        //         branch.state === 'alive'
        //     );

        //     downBranches.forEach(branch => {
        //         if (Date.now() > branch.statusChangedAt + BRANCH_DECAY_TIMEOUT) {
        //             markBranchForRetraction(branch);
        //         }
        //     });
        // }

        if (Math.random() < 0.3 * attackFreqMultiplier) {
          // Red node frequency
          const target =
            aliveNodes[Math.floor(Math.random() * aliveNodes.length)];
          // Grace period: newly sprouted nodes can't go down for 5 seconds
          const nodeAge = Date.now() - target.createdAt;
          const GRACE_PERIOD = 5000; // 5 seconds
          if (target.status === "green" && nodeAge >= GRACE_PERIOD) {
            updateNodeStatus(target, "red");
          }
        }
        if (Math.random() < 0.02 * attackFreqMultiplier) {
          // Malware infection rate (reduced from 5% to 2%)
          const target =
            aliveNodes[Math.floor(Math.random() * aliveNodes.length)];
          if (
            target.status === "green" &&
            !target.isTargeted &&
            target.remediationState === "none"
          ) {
            updateNodeStatus(target, "malware");
          }
        }

        healNetwork();
        spontaneouslySprout();
        sproutGroundStationFromHealthyNode();
        checkSatelliteLifespans(); // Despawn satellites after 2 minutes
        checkGroundStationLifespans(); // Revert ground stations after 2 minutes
        groundStationsLaunchSatellites();
        updateSatelliteWirelessLinks(); // Dynamic wireless bridging (includes ground station bridges)
        // mergeConnectedGroundStations(); // DISABLED: Allow ground stations to maintain wireless bridges
        adoptRedNodes();
        spreadMalware();
        detectAndFormBotnets();
        cleanupBotnetMeshEdges(); // Remove mesh edges crossing healthy branches
        evaluateBotDefenseMode();
        optimizeBotnetMesh();
        resolveCrossings();
      }

      function updateNetworkTopology() {
        const currentBranches = nodes.filter(
          (n) =>
            n.parent === nodes[0] &&
            (n.state === "alive" || n.state === "spawning")
        ).length;
        const changeProbability = 0.1;

        if (currentBranches > desiredBranchCount) {
          pruneRandomBranch();
          pruneSingleNodeBranches();
          return;
        }

        if (Math.random() < changeProbability) pruneRandomBranch();
        pruneSingleNodeBranches();

        if (
          currentBranches < desiredBranchCount &&
          Math.random() < changeProbability
        ) {
          sproutNewBranch();
        }
      }

      function convertToGroundStation(node) {
        if (!node || node.state !== "alive") return;
        // Allow perimeter nodes, not just direct children of root
        if (node.parent === null) return; // Not the central node

        if (node.isGuardian) {
          demoteGuardian(node);
        }
        node.isGroundStation = true;
        node.groundStationEstablishedAt = Date.now();
        node.lastSatelliteLaunch = null; // Will be set after countdown
        node.groundStationCountdown = 10000; // 10 second countdown before first launch
        node.baseRadius = 24;
        node.targetRadius = node.baseRadius;
        node.shieldStrength = Math.max(node.shieldStrength || 0, 0.65);
        node.currentColor = { ...colors.groundStation };
        node.hasFirewall = true;
        node.status = "green";
        createPopParticles(node.x, node.y, colors.blue);
        logEvent("groundStationEstablished", { node });
      }

      function registerSatelliteEdge(groundStation, edge) {
        if (!groundStation || !edge) return;
        if (!groundStation.satelliteEdges) {
          groundStation.satelliteEdges = [];
        }
        if (!groundStation.satelliteEdges.includes(edge)) {
          groundStation.satelliteEdges.push(edge);
        }
        if (!edge.satelliteHosts) {
          edge.satelliteHosts = new Set();
        }
        edge.satelliteHosts.add(groundStation);
      }

      function unregisterSatelliteEdge(edge) {
        if (!edge) return;
        if (edge.satelliteHosts && edge.satelliteHosts.size > 0) {
          edge.satelliteHosts.forEach((host) => {
            if (host && host.satelliteEdges) {
              host.satelliteEdges = host.satelliteEdges.filter(
                (e) => e !== edge
              );
            }
          });
          edge.satelliteHosts.clear();
        }
      }

      // OLD TETHERED SATELLITE CREATION - DISABLED
      // Only free-floating orbital satellites are created via launchSatelliteFromGroundStation()
      function createSatelliteNode(groundStation, parent, baseX, baseY) {
        // Disabled - this function created tethered satellites which are no longer used
        // Use launchSatelliteFromGroundStation() instead for free-floating orbital satellites
        return null;
      }

      function getOutwardAngleFrom(node) {
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        const bx = (node.baseX !== undefined ? node.baseX : node.x) - cx;
        const by = (node.baseY !== undefined ? node.baseY : node.y) - cy;
        return Math.atan2(by, bx);
      }

      function findSatelliteTargetPosition(
        groundStation,
        parent,
        baseAngle,
        distance
      ) {
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        const parentBx = parent.baseX !== undefined ? parent.baseX : parent.x;
        const parentBy = parent.baseY !== undefined ? parent.baseY : parent.y;
        const distFromCenterParent = Math.hypot(parentBx - cx, parentBy - cy);
        const perpendicular = baseAngle + Math.PI / 2;

        const angleOffsets = [
          0, 0.12, -0.12, 0.22, -0.22, 0.35, -0.35, 0.5, -0.5,
        ];
        const lateralScales = [
          0, 0.15, -0.15, 0.3, -0.3, 0.45, -0.45, 0.6, -0.6, 0.8, -0.8,
        ];
        const distanceMultipliers = [1.0, 1.1, 0.9, 1.25, 0.75];
        const outwardSlack = 6; // allow up to 6px non-outward movement near the border

        // Preferred: try using the current parent as the origin to place the next satellite one segment out
        const baseAngleParent = getOutwardAngleFrom(parent);
        const perpParent = baseAngleParent + Math.PI / 2;
        for (const sm of distanceMultipliers) {
          const segDist = distance * sm;
          for (const da of angleOffsets) {
            const ang2 = baseAngleParent + da;
            for (const ls of lateralScales) {
              const lateral = ls * SATELLITE_CHAIN_SEGMENT_LENGTH;
              const x =
                parentBx +
                Math.cos(ang2) * segDist +
                Math.cos(perpParent) * lateral;
              const y =
                parentBy +
                Math.sin(ang2) * segDist +
                Math.sin(perpParent) * lateral;

              const clampedX = Math.max(
                padding,
                Math.min(canvas.width - padding, x)
              );
              const clampedY = Math.max(
                padding,
                Math.min(canvas.height - padding, y)
              );

              const distFromCenter = Math.hypot(clampedX - cx, clampedY - cy);
              if (distFromCenter < distFromCenterParent - outwardSlack)
                continue;

              let candidate = { x: clampedX, y: clampedY };
              if (segmentCrossesExistingEdges(parent, candidate)) {
                const nudged = nudgeEndpointToAvoidCrossing(parent, candidate);
                if (!nudged) continue;
                candidate = nudged;
                const d2 = Math.hypot(candidate.x - cx, candidate.y - cy);
                if (d2 < distFromCenterParent - outwardSlack) continue;
                if (segmentCrossesExistingEdges(parent, candidate)) continue;
              }

              return candidate;
            }
          }
        }

        // Fallback: use the ground station as the origin for a broader search
        for (const dm of distanceMultipliers) {
          const dist = distance * dm;
          for (const da of angleOffsets) {
            const ang = baseAngle + da;
            for (const ls of lateralScales) {
              const lateral = ls * SATELLITE_CHAIN_SEGMENT_LENGTH;
              const x =
                groundStation.baseX +
                Math.cos(ang) * dist +
                Math.cos(perpendicular) * lateral;
              const y =
                groundStation.baseY +
                Math.sin(ang) * dist +
                Math.sin(perpendicular) * lateral;

              const clampedX = Math.max(
                padding,
                Math.min(canvas.width - padding, x)
              );
              const clampedY = Math.max(
                padding,
                Math.min(canvas.height - padding, y)
              );

              // Ensure outward: strictly farther from center than parent
              const distFromCenter = Math.hypot(clampedX - cx, clampedY - cy);
              if (distFromCenter < distFromCenterParent - outwardSlack)
                continue;

              // Avoid crossing wired/guardian edges when tethering; try nudging if needed
              let candidate = { x: clampedX, y: clampedY };
              if (segmentCrossesExistingEdges(parent, candidate)) {
                const nudged = nudgeEndpointToAvoidCrossing(parent, candidate);
                if (!nudged) continue;
                candidate = nudged;
                // Still require outward
                const d2 = Math.hypot(candidate.x - cx, candidate.y - cy);
                if (d2 < distFromCenterParent - outwardSlack) continue;
                if (segmentCrossesExistingEdges(parent, candidate)) continue;
              }

              return candidate;
            }
          }
        }
        return null;
      }

      // OLD SATELLITE CHAIN SYSTEM - DISABLED
      // This has been replaced by the free-floating orbital satellite system
      // Only ground stations can launch satellites via launchSatelliteFromGroundStation()
      function buildSatelliteChain(groundStation) {
        // Disabled - use launchSatelliteFromGroundStation instead
        return;
      }

      function removeSatelliteChain(groundStation) {
        if (!groundStation) return;
        const satellites = groundStation.satelliteChain || [];
        if (satellites.length === 0) return;

        satellites.forEach((satellite) => untetherSatellite(satellite));

        groundStation.satelliteChain = [];
        groundStation.satelliteEdges = [];
        groundStation.lastSatelliteChainCheck = Date.now();
      }

      /**
       * Try to adopt a satellite by another satellite that has a wireless link to it.
       * This allows satellites to remain in the network when their parent goes down.
       * Returns true if adoption succeeded, false otherwise.
       */
      function trySatelliteAdoption(satellite) {
        if (!satellite || !satellite.isSatellite || satellite.state !== "alive")
          return false;

        // Calculate wireless link max distance as 25% of screen diagonal
        const screenDiagonal = Math.sqrt(
          canvas.width * canvas.width + canvas.height * canvas.height
        );
        const WIRELESS_LINK_MAX_DISTANCE =
          screenDiagonal * WIRELESS_LINK_MAX_DISTANCE_RATIO;

        // Find wireless links connected to this satellite
        const wirelessLinks = edges.filter(
          (edge) =>
            edge.isWirelessLink &&
            (edge.from === satellite || edge.to === satellite)
        );

        if (wirelessLinks.length === 0) return false;

        // Find potential adopters - satellites or healthy nodes on the other end of wireless links
        for (const link of wirelessLinks) {
          const otherNode = link.from === satellite ? link.to : link.from;
          if (!otherNode || otherNode.state !== "alive") continue;

          // Verify distance is still within limits (safety check)
          const dx = otherNode.x - satellite.x;
          const dy = otherNode.y - satellite.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          if (distance > WIRELESS_LINK_MAX_DISTANCE) continue;

          let newHost = null;

          if (otherNode.isSatellite) {
            // Adopter is a satellite - must be tethered with valid host
            if (!otherNode.isTethered) continue;
            const adopterHost = otherNode.satelliteHost;
            if (!adopterHost || adopterHost.state !== "alive") continue;
            const hostIsGroundStation = adopterHost.isGroundStation;
            const hostIsHealthyNode =
              !adopterHost.isGroundStation &&
              (adopterHost.status === "green" ||
                adopterHost.status === "yellow");
            if (!hostIsGroundStation && !hostIsHealthyNode) continue;
            newHost = adopterHost;
          } else if (otherNode.isGroundStation) {
            // Adopter is a ground station - use it as host
            newHost = otherNode;
          } else if (
            otherNode.status === "green" ||
            otherNode.status === "yellow"
          ) {
            // Adopter is a healthy or yellow regular node - it becomes the new host
            newHost = otherNode;
          } else {
            continue; // Not a valid adopter
          }

          // Adoption successful! Re-parent the satellite
          const oldParent = satellite.parent;
          const oldHost = satellite.satelliteHost;

          // Remove from old parent's children
          if (oldParent && oldParent.children) {
            oldParent.children = oldParent.children.filter(
              (c) => c !== satellite
            );
          }

          // Remove old edge to parent
          edges = edges.filter(
            (edge) =>
              !(edge.from === oldParent && edge.to === satellite) &&
              !(edge.from === satellite && edge.to === oldParent)
          );

          // Remove from old host's satellite chain
          if (oldHost && oldHost.satelliteChain) {
            oldHost.satelliteChain = oldHost.satelliteChain.filter(
              (s) => s !== satellite
            );
          }

          // Set new parent and host
          satellite.parent = otherNode;
          satellite.satelliteHost = newHost;
          otherNode.children.push(satellite);

          // Create new edge (wireless link already exists, create tree edge)
          const newEdge = {
            from: otherNode,
            to: satellite,
            isWirelessLink: true,
            pulseSeed: Math.random() * Math.PI * 2,
          };
          edges.push(newEdge);

          // Add to new host's satellite chain if it tracks them
          if (
            newHost.satelliteChain &&
            !newHost.satelliteChain.includes(satellite)
          ) {
            newHost.satelliteChain.push(satellite);
          }

          const adopterType = otherNode.isSatellite
            ? "satellite"
            : otherNode.isGroundStation
            ? "ground station"
            : "node";
          logEvent("custom", {
            message: `üõ∞Ô∏è Satellite adopted by nearby ${adopterType} - network resilience maintained!`,
          });
          return true;
        }

        return false;
      }

      function untetherSatellite(satellite) {
        if (!satellite || !satellite.isSatellite) return;
        if (satellite.state === "drifting") return;

        const host = satellite.satelliteHost;
        if (host && host.satelliteChain) {
          host.satelliteChain = host.satelliteChain.filter(
            (s) => s !== satellite
          );
        }
        if (host && host.satelliteEdges) {
          host.satelliteEdges = host.satelliteEdges.filter(
            (edge) => edge.from !== satellite && edge.to !== satellite
          );
        }

        const edgesToRemove = edges.filter(
          (edge) => edge.from === satellite || edge.to === satellite
        );
        edgesToRemove.forEach(unregisterSatelliteEdge);
        edges = edges.filter(
          (edge) => edge.from !== satellite && edge.to !== satellite
        );

        if (satellite.children && satellite.children.length > 0) {
          const children = [...satellite.children];
          satellite.children = [];
          children.forEach((child) => {
            if (!child) return;
            if (child.isSatellite) {
              if (child.state !== "drifting") {
                untetherSatellite(child);
              }
            } else {
              markBranchForRetraction(child, { allowGroundStation: true });
            }
          });
        }

        if (satellite.parent) {
          satellite.parent.children = satellite.parent.children.filter(
            (child) => child !== satellite
          );
        }

        satellite.satelliteHost = null;
        satellite.parent = null;
        satellite.isTethered = false;
        satellite.state = "drifting";
        satellite.isDrifting = true;

        const driftAngle = Math.random() * Math.PI * 2;
        const driftSpeed =
          SATELLITE_DRIFT_SPEED_MIN +
          Math.random() *
            (SATELLITE_DRIFT_SPEED_MAX - SATELLITE_DRIFT_SPEED_MIN);
        satellite.driftVelocityX = Math.cos(driftAngle) * driftSpeed;
        satellite.driftVelocityY = Math.sin(driftAngle) * driftSpeed;

        logEvent("satelliteUntethered", { node: satellite });

        if (host) {
          ensureSatelliteLongLinks(host);
        } else {
          refreshSatelliteLongLinks();
        }
      }

      function hasWirelessEdgeBetween(nodeA, nodeB) {
        return edges.some(
          (edge) =>
            edge.isWirelessLink &&
            ((edge.from === nodeA && edge.to === nodeB) ||
              (edge.from === nodeB && edge.to === nodeA))
        );
      }

      function hasAnyEdgeBetween(nodeA, nodeB) {
        return edges.some(
          (edge) =>
            (edge.from === nodeA && edge.to === nodeB) ||
            (edge.from === nodeB && edge.to === nodeA)
        );
      }

      function orientation(ax, ay, bx, by, cx, cy) {
        const value = (bx - ax) * (cy - ay) - (by - ay) * (cx - ax);
        if (Math.abs(value) < 1e-6) return 0;
        return value > 0 ? 1 : -1;
      }

      function onSegment(ax, ay, bx, by, cx, cy) {
        return (
          Math.min(ax, bx) - 1e-6 <= cx &&
          cx <= Math.max(ax, bx) + 1e-6 &&
          Math.min(ay, by) - 1e-6 <= cy &&
          cy <= Math.max(ay, by) + 1e-6
        );
      }

      function segmentsIntersect(ax, ay, bx, by, cx, cy, dx, dy) {
        const o1 = orientation(ax, ay, bx, by, cx, cy);
        const o2 = orientation(ax, ay, bx, by, dx, dy);
        const o3 = orientation(cx, cy, dx, dy, ax, ay);
        const o4 = orientation(cx, cy, dx, dy, bx, by);

        if (o1 !== o2 && o3 !== o4) return true;

        if (o1 === 0 && onSegment(ax, ay, bx, by, cx, cy)) return true;
        if (o2 === 0 && onSegment(ax, ay, bx, by, dx, dy)) return true;
        if (o3 === 0 && onSegment(cx, cy, dx, dy, ax, ay)) return true;
        if (o4 === 0 && onSegment(cx, cy, dx, dy, bx, by)) return true;

        return false;
      }

      function nodesHaveClearView(nodeA, nodeB) {
        if (!nodeA || !nodeB) return false;
        const ax = nodeA.x;
        const ay = nodeA.y;
        const bx = nodeB.x;
        const by = nodeB.y;
        const abx = bx - ax;
        const aby = by - ay;
        const abLengthSquared = abx * abx + aby * aby;
        if (abLengthSquared === 0) return false;

        for (const node of nodes) {
          if (node === nodeA || node === nodeB) continue;
          if (node.state !== "alive") continue;
          // Satellites pass through wireless links - ignore them in clear view checks
          if (node.isSatellite) continue;
          const apx = node.x - ax;
          const apy = node.y - ay;
          let t = (apx * abx + apy * aby) / abLengthSquared;
          t = Math.max(0, Math.min(1, t));
          const closestX = ax + abx * t;
          const closestY = ay + aby * t;
          const dx = node.x - closestX;
          const dy = node.y - closestY;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const clearance = node.radius + 12;
          if (distance < clearance) {
            return false;
          }
        }

        for (const edge of edges) {
          if (!edge || !edge.from || !edge.to) continue;
          if (
            edge.from === nodeA ||
            edge.from === nodeB ||
            edge.to === nodeA ||
            edge.to === nodeB
          )
            continue;
          // Skip wireless links - wireless can pass through wireless
          if (edge.isWirelessLink) continue;
          if (
            segmentsIntersect(
              ax,
              ay,
              bx,
              by,
              edge.from.x,
              edge.from.y,
              edge.to.x,
              edge.to.y
            )
          ) {
            return false;
          }
        }

        return true;
      }

      /**
       * Check if a botnet mesh edge crosses any healthy (uninfected) tree branches.
       * Returns true if the path is clear of healthy branches.
       */
      function botnetMeshHasClearPath(nodeA, nodeB) {
        if (!nodeA || !nodeB) return false;
        const ax = nodeA.x,
          ay = nodeA.y;
        const bx = nodeB.x,
          by = nodeB.y;

        for (const edge of edges) {
          if (!edge || !edge.from || !edge.to) continue;
          // Skip non-tree edges (mesh, VPN, wireless, DDOS)
          if (
            edge.isBotnetMesh ||
            edge.isGuardianVpnTunnel ||
            edge.isWirelessLink ||
            edge.isDDOSAttack
          )
            continue;
          // Skip edges involving the mesh endpoints
          if (
            edge.from === nodeA ||
            edge.from === nodeB ||
            edge.to === nodeA ||
            edge.to === nodeB
          )
            continue;
          // Skip if both endpoints of the tree edge are infected
          const fromInfected =
            edge.from.status === "malware" ||
            edge.from.status === "botnet" ||
            edge.from.status === "commandControl";
          const toInfected =
            edge.to.status === "malware" ||
            edge.to.status === "botnet" ||
            edge.to.status === "commandControl";
          if (fromInfected && toInfected) continue; // Infected branch, allow crossing

          // Check if mesh edge crosses this healthy branch
          if (
            segmentsIntersect(
              ax,
              ay,
              bx,
              by,
              edge.from.x,
              edge.from.y,
              edge.to.x,
              edge.to.y
            )
          ) {
            return false; // Blocked by healthy branch
          }
        }
        return true;
      }

      /**
       * Periodically clean up botnet mesh edges that cross healthy branches.
       */
      function cleanupBotnetMeshEdges() {
        edges = edges.filter((edge) => {
          if (!edge.isBotnetMesh) return true; // Keep non-mesh edges
          if (!edge.from || !edge.to) return false; // Remove broken edges
          if (edge.from.state !== "alive" || edge.to.state !== "alive")
            return false; // Remove dead node edges

          // Remove if crossing healthy branch
          return botnetMeshHasClearPath(edge.from, edge.to);
        });
      }

      function ensureSatelliteLongLinks(groundStation) {
        if (
          !groundStation ||
          !groundStation.isGroundStation ||
          !groundStation.satelliteChain
        )
          return;
        if (!groundStation.satelliteEdges) groundStation.satelliteEdges = [];

        // Calculate wireless link max distance as 25% of screen diagonal
        const screenDiagonal = Math.sqrt(
          canvas.width * canvas.width + canvas.height * canvas.height
        );
        const WIRELESS_LINK_MAX_DISTANCE =
          screenDiagonal * WIRELESS_LINK_MAX_DISTANCE_RATIO;

        const longEdgesToRemove = [];
        groundStation.satelliteEdges = groundStation.satelliteEdges.filter(
          (edge) => {
            if (!edge || !edge.isSatelliteLongLink) return edge !== null;
            const { from, to } = edge;
            const valid =
              from &&
              to &&
              from.isSatellite &&
              to.isSatellite &&
              from.state === "alive" &&
              to.state === "alive" &&
              from.isTethered &&
              to.isTethered &&
              nodesHaveClearView(from, to);
            if (!valid) {
              longEdgesToRemove.push(edge);
              return false;
            }
            return true;
          }
        );

        if (longEdgesToRemove.length > 0) {
          longEdgesToRemove.forEach(unregisterSatelliteEdge);
          edges = edges.filter((edge) => !longEdgesToRemove.includes(edge));
        }

        const chain = groundStation.satelliteChain.filter(
          (sat) =>
            (sat.state === "alive" || sat.state === "spawning") &&
            sat.isTethered
        );
        if (chain.length < 3) return;

        for (let i = 0; i < chain.length - 2; i++) {
          for (let j = i + 2; j < chain.length; j++) {
            const satA = chain[i];
            const satB = chain[j];
            if (!satA || !satB) continue;
            if (hasWirelessEdgeBetween(satA, satB)) continue;

            // Check distance - only link if within max wireless distance
            const dx = satB.x - satA.x;
            const dy = satB.y - satA.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance > WIRELESS_LINK_MAX_DISTANCE) continue;

            if (!nodesHaveClearView(satA, satB)) continue;

            const extendedEdge = {
              from: satA,
              to: satB,
              isWirelessLink: true,
              pulseSeed: Math.random() * Math.PI * 2,
              isSatelliteLongLink: true,
            };

            edges.push(extendedEdge);
            registerSatelliteEdge(groundStation, extendedEdge);
          }
        }
      }

      function refreshSatelliteLongLinks() {
        const groundStations = nodes.filter(
          (node) => node.isGroundStation && node.state === "alive"
        );
        groundStations.forEach((gs) => ensureSatelliteLongLinks(gs));
        ensureInterBranchSatelliteLinks(groundStations);
      }

      function ensureInterBranchSatelliteLinks(groundStations = null) {
        // Calculate wireless link max distance as 25% of screen diagonal
        const screenDiagonal = Math.sqrt(
          canvas.width * canvas.width + canvas.height * canvas.height
        );
        const WIRELESS_LINK_MAX_DISTANCE =
          screenDiagonal * WIRELESS_LINK_MAX_DISTANCE_RATIO;

        const activeGroundStations =
          groundStations ||
          nodes.filter(
            (node) => node.isGroundStation && node.state === "alive"
          );
        // Include satellites from ground stations AND orphan satellites from healthy nodes
        const eligibleSatellites = nodes.filter((node) => {
          if (
            !node.isSatellite ||
            node.state !== "alive" ||
            !node.isTethered ||
            !node.satelliteHost
          )
            return false;
          const hostIsGroundStation =
            node.satelliteHost.isGroundStation &&
            node.satelliteHost.state === "alive";
          const hostIsHealthyNode =
            !node.satelliteHost.isGroundStation &&
            node.satelliteHost.state === "alive" &&
            node.satelliteHost.status === "green";
          return hostIsGroundStation || hostIsHealthyNode;
        });

        for (let i = 0; i < eligibleSatellites.length - 1; i++) {
          const satA = eligibleSatellites[i];
          const hostA = satA.satelliteHost;
          for (let j = i + 1; j < eligibleSatellites.length; j++) {
            const satB = eligibleSatellites[j];
            const hostB = satB.satelliteHost;

            if (!hostA || !hostB || hostA === hostB) continue;
            // At least one must be from a ground station, or allow orphan-to-orphan/orphan-to-chain links
            const hasGroundStationHost =
              activeGroundStations.includes(hostA) ||
              activeGroundStations.includes(hostB);
            const bothAreOrphans =
              !hostA.isGroundStation && !hostB.isGroundStation;
            if (!hasGroundStationHost && !bothAreOrphans) continue;
            if (hasAnyEdgeBetween(satA, satB)) continue;

            // Check distance - only link if within max wireless distance
            const dx = satB.x - satA.x;
            const dy = satB.y - satA.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance > WIRELESS_LINK_MAX_DISTANCE) continue;

            if (!nodesHaveClearView(satA, satB)) continue;

            const longLink = {
              from: satA,
              to: satB,
              isWirelessLink: true,
              pulseSeed: Math.random() * Math.PI * 2,
              isSatelliteLongLink: true,
              isCrossBranchSatelliteLink: true,
            };

            edges.push(longLink);
            registerSatelliteEdge(hostA, longLink);
            registerSatelliteEdge(hostB, longLink);
          }
        }
      }

      function groundStationHasActiveSatellites(groundStation) {
        if (!groundStation || !groundStation.satelliteChain) return false;
        return groundStation.satelliteChain.some(
          (sat) => sat && sat.state === "alive" && sat.isTethered
        );
      }

      // OLD SATELLITE CHAIN MAINTENANCE - DISABLED
      // Satellites are now launched individually via groundStationsLaunchSatellites()
      function maintainGroundStationSatelliteChains() {
        // Disabled - satellites launch via groundStationsLaunchSatellites() instead
        return;
      }
      function getRootBranch(node) {
        if (!node || !node.parent) return null;
        let currentNode = node;
        while (currentNode.parent && currentNode.parent.parent !== null) {
          currentNode = currentNode.parent;
        }
        return currentNode;
      }

      /**
       * Apply spring forces ONLY for tree edges (parent-child relationships).
       * Mesh and VPN tunnel edges are purely visual - they don't affect node positions.
       * This creates a stable "betweenness centrality" layout where nodes are anchored
       * by their parent edge and won't be pulled around by mesh/bridge connections.
       */
      function applySpringForces() {
        const springStrength = 0.008; // Gentle spring for tree structure

        for (const edge of edges) {
          const p1 = edge.from;
          const p2 = edge.to;

          if (!p1 || !p2 || p1.state !== "alive" || p2.state !== "alive")
            continue;

          // Skip satellites - they use independent orbital mechanics
          if (p1.isSatellite || p2.isSatellite) continue;

          // CRITICAL: Skip all non-tree edges to maintain stable positions
          // Mesh, VPN tunnels, wireless links, and DDOS edges are visual only
          if (
            edge.isBotnetMesh ||
            edge.isGuardianVpnTunnel ||
            edge.isWirelessLink ||
            edge.isDDOSAttack
          ) {
            continue;
          }

          // Only apply forces if this is a parent-child relationship (tree edge)
          const isTreeEdge = p1.parent === p2 || p2.parent === p1;
          if (!isTreeEdge) continue;

          // Don't move central node
          if (p1.parent === null) continue;

          // Determine if this is a first generation edge (direct child of center)
          const childNode = p2.parent === p1 ? p2 : p1;
          const parentNode = childNode.parent;
          const isFirstGen = parentNode && parentNode.parent === null;
          const idealEdgeLength = isFirstGen ? 160 : 70; // 2x for first gen

          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance > 0) {
            const displacement = distance - idealEdgeLength;
            const force = displacement * springStrength;

            const forceX = (dx / distance) * force;
            const forceY = (dy / distance) * force;

            // Apply force to child node only (parent anchors child)
            // This maintains the "anchored to parent" behavior
            if (p2.parent === p1) {
              // p2 is child of p1
              p2.fx -= forceX * 0.3;
              p2.fy -= forceY * 0.3;
            } else if (p1.parent === p2) {
              // p1 is child of p2
              p1.fx += forceX * 0.3;
              p1.fy += forceY * 0.3;
            }
          }
        }
      }

      function applyEdgeRepulsion() {
        const edgeRepulsionStrength = 0.08;
        for (const edge of edges) {
          const p1 = edge.from;
          const p2 = edge.to;
          if (!p1 || !p2 || p1.state !== "alive" || p2.state !== "alive")
            continue;

          // Skip satellites - they use independent orbital mechanics
          if (p1.isSatellite || p2.isSatellite) continue;

          // Skip non-tree edges - they shouldn't push nodes around
          if (
            edge.isBotnetMesh ||
            edge.isGuardianVpnTunnel ||
            edge.isWirelessLink ||
            edge.isDDOSAttack
          ) {
            continue;
          }

          const l2 = (p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2;
          if (l2 === 0) continue;

          for (const node of nodes) {
            if (node === p1 || node === p2 || node.state !== "alive") continue;

            // Skip satellites - they use independent orbital mechanics
            if (node.isSatellite) continue;
            let t =
              ((node.x - p1.x) * (p2.x - p1.x) +
                (node.y - p1.y) * (p2.y - p1.y)) /
              l2;
            t = Math.max(0, Math.min(1, t));
            const closestX = p1.x + t * (p2.x - p1.x);
            const closestY = p1.y + t * (p2.y - p1.y);
            const dx = node.x - closestX;
            const dy = node.y - closestY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const minDistance = node.radius + 10;

            if (distance < minDistance && distance > 0.01) {
              const force = (minDistance - distance) * edgeRepulsionStrength;
              const forceX = (dx / distance) * force;
              const forceY = (dy / distance) * force;

              node.fx += forceX;
              node.fy += forceY;
              p1.fx -= forceX * (1 - t) * 0.5;
              p1.fy -= forceY * (1 - t) * 0.5;
              p2.fx -= forceX * t * 0.5;
              p2.fy -= forceY * t * 0.5;
            }
          }
        }
      }

      function applyBoundaryRepulsion(qtree) {
        const margin = Math.max(
          80,
          Math.min(canvas.width, canvas.height) * 0.08
        );
        const strength = 0.12;
        const leftBand = new Rectangle(
          margin / 2,
          canvas.height / 2,
          margin / 2,
          canvas.height / 2
        );
        const rightBand = new Rectangle(
          canvas.width - margin / 2,
          canvas.height / 2,
          margin / 2,
          canvas.height / 2
        );
        const topBand = new Rectangle(
          canvas.width / 2,
          margin / 2,
          canvas.width / 2,
          margin / 2
        );
        const bottomBand = new Rectangle(
          canvas.width / 2,
          canvas.height - margin / 2,
          canvas.width / 2,
          margin / 2
        );

        const applyForSide = (range, side) => {
          const list = qtree.query(range);
          for (const node of list) {
            if (node.state !== "alive") continue;

            // Skip satellites - they use independent orbital mechanics
            if (node.isSatellite) continue;
            let t = 0,
              fx = 0,
              fy = 0;
            if (side === "left") {
              const d = node.x;
              if (d < margin) {
                t = 1 - d / margin;
                fx = strength * t * t;
              }
            } else if (side === "right") {
              const d = canvas.width - node.x;
              if (d < margin) {
                t = 1 - d / margin;
                fx = -strength * t * t;
              }
            } else if (side === "top") {
              const d = node.y;
              if (d < margin) {
                t = 1 - d / margin;
                fy = strength * t * t;
              }
            } else if (side === "bottom") {
              const d = canvas.height - node.y;
              if (d < margin) {
                t = 1 - d / margin;
                fy = -strength * t * t;
              }
            }
            if (t > 0) {
              const effective = node.physicsMultiplier;
              node.fx += fx * effective;
              node.fy += fy * effective;
            }
          }
        };
        applyForSide(leftBand, "left");
        applyForSide(rightBand, "right");
        applyForSide(topBand, "top");
        applyForSide(bottomBand, "bottom");
      }

      function applyRepulsion(qtree) {
        // MODIFIED: Takes a quadtree as an argument
        const repulsionStrength = 0.25;
        const interBranchRepulsion = 0.7;

        for (const nodeA of nodes) {
          if (nodeA.state !== "alive") continue;

          // Skip satellites - they use independent orbital mechanics
          if (nodeA.isSatellite) continue;

          // Query the quadtree for nearby nodes to reduce calculations
          const range = new Circle(nodeA.x, nodeA.y, 100);
          const nearbyNodes = qtree.query(range);

          for (const nodeB of nearbyNodes) {
            // Ensure we don't compare a node to itself, and that we only process each pair once.
            if (nodeA.id >= nodeB.id || nodeB.state !== "alive") continue;

            // Skip satellites - they use independent orbital mechanics
            if (nodeB.isSatellite) continue;

            const dx = nodeB.x - nodeA.x;
            const dy = nodeB.y - nodeA.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            let minDistance = nodeA.radius + nodeB.radius + 25;
            let forceStrength = repulsionStrength;

            const rootBranchA = getRootBranch(nodeA);
            const rootBranchB = getRootBranch(nodeB);

            if (
              rootBranchA &&
              rootBranchB &&
              rootBranchA.id !== rootBranchB.id
            ) {
              minDistance = nodeA.radius + nodeB.radius + 50;
              forceStrength = interBranchRepulsion;
            }

            if (distance < minDistance && distance > 0) {
              const force = (minDistance - distance) * forceStrength;

              // IMPROVED: Scale forces by settling phase multipliers for gentler physics
              const effectiveMultiplier =
                nodeA.physicsMultiplier * nodeB.physicsMultiplier;
              const effectiveForce = force * effectiveMultiplier;

              const forceX = (dx / distance) * effectiveForce;
              const forceY = (dy / distance) * effectiveForce;

              nodeA.fx -= forceX * 0.5;
              nodeA.fy -= forceY * 0.5;
              nodeB.fx += forceX * 0.5;
              nodeB.fy += forceY * 0.5;
            }
          }
        }
      }

      function createPopParticles(x, y, color) {
        // Performance: Skip particles entirely at high node counts
        if (nodes.length > 250) return;

        const particleCount = 4; // Reduced from 8 to 4 for better performance
        for (let i = 0; i < particleCount; i++) {
          particles.push(new Particle(x, y, color));
        }
      }

      function promoteToGuardian(node, logKey, extraContext = {}) {
        if (
          !node ||
          node.parent === null ||
          node.state !== "alive" ||
          node.isGuardian ||
          node.isGroundStation ||
          node.isSatellite
        ) {
          return false;
        }

        node.isGuardian = true;
        node.hasFirewall = true;
        node.shieldStrength = Math.max(node.shieldStrength, 0.8);
        node.currentColor = { ...colors.white };
        node.targetRadius = node.baseRadius * 1.15;
        node.guardianStreamCount = 0;
        clearGuardianVpnTunnels(node);
        node.lastGuardianBridgeUpdate = 0;
        node.lastGuardianFirewallAttempt = 0;
        createPopParticles(node.x, node.y, colors.white);

        if (logKey) {
          logEvent(logKey, { node, ...extraContext });
        }

        return true;
      }

      function demoteGuardian(node, logKey, extraContext = {}) {
        if (!node || !node.isGuardian) return;

        clearGuardianVpnTunnels(node);
        node.isGuardian = false;
        node.guardianStreamCount = 0;
        node.guardianImmunityLastSpawn = 0;
        node.hasFirewall = false;

        if (logKey) {
          logEvent(logKey, { node, ...extraContext });
        }
      }

      function trySpawnGuardian(node) {
        if (
          !node ||
          node.parent === null ||
          node.state !== "alive" ||
          node.isGuardian ||
          node.isGroundStation ||
          node.isSatellite
        )
          return;

        const GUARDIAN_SPAWN_CHANCE = 0.25;
        if (Math.random() >= GUARDIAN_SPAWN_CHANCE) return;

        promoteToGuardian(node, "guardianPromotionPhishing");
      }

      function clearGuardianVpnTunnels(node) {
        if (!node || !node.guardianVpnTunnels) return;

        node.guardianVpnTunnels.forEach((tunnel) => {
          if (!tunnel || !tunnel.edge) return;
          const index = edges.indexOf(tunnel.edge);
          if (index !== -1) {
            edges.splice(index, 1);
          }
        });

        node.guardianVpnTunnels = [];
      }

      const GUARDIAN_VPN_TUNNEL_RANGE = 200;
      const GUARDIAN_VPN_TUNNEL_LIMIT = 3;

      function updateGuardianVpnTunnels() {
        const now = Date.now();
        const GUARDIAN_VPN_TUNNEL_REFRESH_INTERVAL = 6000 / healSpeedMultiplier;
        const GUARDIAN_FIREWALL_ATTEMPT_DURATION = 2000 / healSpeedMultiplier;

        nodes.forEach((node) => {
          if (!node.guardianVpnTunnels) {
            node.guardianVpnTunnels = [];
          }

          const isActiveGuardian = node.isGuardian && node.state === "alive";

          if (!isActiveGuardian) {
            clearGuardianVpnTunnels(node);
            return;
          }

          // Clean up stale VPN tunnels (target removed, dead, or no clear view)
          node.guardianVpnTunnels = node.guardianVpnTunnels.filter((tunnel) => {
            if (!tunnel || !tunnel.edge || !tunnel.target) {
              return false;
            }
            if (tunnel.target.state !== "alive") {
              const idx = edges.indexOf(tunnel.edge);
              if (idx !== -1) edges.splice(idx, 1);
              return false;
            }
            // Remove if line of sight is blocked
            if (!nodesHaveClearView(node, tunnel.target)) {
              const idx = edges.indexOf(tunnel.edge);
              if (idx !== -1) edges.splice(idx, 1);
              return false;
            }
            return true;
          });

          // Finalize firewall attempts
          node.guardianVpnTunnels.forEach((tunnel) => {
            if (!tunnel || !tunnel.firewallAttempt) return;
            const attempt = tunnel.firewallAttempt;
            if (attempt.completed) return;

            const elapsed = now - attempt.startTime;
            if (elapsed >= GUARDIAN_FIREWALL_ATTEMPT_DURATION) {
              attempt.completed = true;
              if (
                attempt.success &&
                tunnel.target &&
                tunnel.target.state === "alive" &&
                !tunnel.target.hasFirewall
              ) {
                tunnel.target.hasFirewall = true;
                tunnel.target.shieldStrength = Math.max(
                  tunnel.target.shieldStrength,
                  0.75
                );
                tunnel.target.shieldFlashTimer = 0;
                createPopParticles(
                  tunnel.target.x,
                  tunnel.target.y,
                  colors.neonGreen
                );
                logEvent("guardianFirewallSuccess", {
                  guardian: node,
                  target: tunnel.target,
                });
              }
            }
          });

          if (
            now - node.lastGuardianBridgeUpdate <
            GUARDIAN_VPN_TUNNEL_REFRESH_INTERVAL
          ) {
            return;
          }

          node.lastGuardianBridgeUpdate = now;
          clearGuardianVpnTunnels(node);

          const candidates = nodes
            .filter((target) => {
              if (!target || target === node) return false;
              if (target.state !== "alive") return false;
              if (target.parent === null) return false; // skip central node
              if (target.isSatellite) return false; // skip satellites - they don't need firewalls
              if (target.status !== "green") return false;
              const dx = target.x - node.x;
              const dy = target.y - node.y;
              const distance = Math.hypot(dx, dy);
              if (distance > GUARDIAN_VPN_TUNNEL_RANGE) return false;

              // Avoid duplicate edges (including existing guardian VPN tunnels)
              const alreadyConnected = edges.some((edge) => {
                if (!edge.from || !edge.to) return false;
                const sameDirection = edge.from === node && edge.to === target;
                const oppositeDirection =
                  edge.from === target && edge.to === node;
                return sameDirection || oppositeDirection;
              });
              if (alreadyConnected) return false;

              return true;
            })
            .sort((a, b) => {
              const da = Math.hypot(a.x - node.x, a.y - node.y);
              const db = Math.hypot(b.x - node.x, b.y - node.y);
              return da - db;
            })
            .slice(0, GUARDIAN_VPN_TUNNEL_LIMIT);

          candidates.forEach((target) => {
            // Skip if no clear line of sight
            if (!nodesHaveClearView(node, target)) return;

            const edge = {
              from: node,
              to: target,
              isGuardianVpnTunnel: true,
              guardianOwnerId: node.id,
              createdAt: now,
            };
            edges.push(edge);

            const tunnel = {
              edge,
              target,
              firewallAttempt: null,
            };

            if (!target.hasFirewall) {
              const success = Math.random() < 0.75;
              tunnel.firewallAttempt = {
                startTime: now,
                success,
                completed: false,
              };
              edge.guardianFirewallAttempt = tunnel.firewallAttempt;
              node.lastGuardianFirewallAttempt = now;
            } else {
              edge.guardianFirewallAttempt = null;
            }

            node.guardianVpnTunnels.push(tunnel);
            logEvent("guardianVpnCreated", { guardian: node, target });
          });
        });
      }

      function spawnGuardianImmunityStreams() {
        const now = Date.now();
        const GUARDIAN_STREAM_INTERVAL = 2500 / healSpeedMultiplier; // Reduced spawn rate (was 1200)
        const IMMUNITY_STREAM_SPEED = 0.006;

        nodes.forEach((node) => {
          if (!node.isGuardian || node.state !== "alive") return;

          if (now - node.guardianImmunityLastSpawn < GUARDIAN_STREAM_INTERVAL) {
            return;
          }

          node.guardianImmunityLastSpawn = now;

          const connectedEdges = edges.filter(
            (edge) => edge.from === node || edge.to === node
          );
          const outwardDirections =
            connectedEdges.length > 0
              ? connectedEdges
              : [{ from: node, to: node.parent }];

          outwardDirections.forEach((connection) => {
            if (!connection || (!connection.from && !connection.to)) return;

            let edge = connection;
            if (!edge.from || !edge.to) {
              const sibling = node.parent;
              if (!sibling) return;
              edge = { from: node, to: sibling };
            }

            if (
              !edge.from ||
              !edge.to ||
              edge.from.state !== "alive" ||
              edge.to.state !== "alive"
            )
              return;

            const direction = edge.from === node ? 1 : -1;
            const packet = new ImmunityPacket(edge, direction);
            node.guardianStreamCount = (node.guardianStreamCount + 1) % 10;

            if (node.guardianStreamCount === 0) {
              packet.isSupercharged = true;
              packet.radius = 3;
            }

            packet.baseSpeed = IMMUNITY_STREAM_SPEED;
            packet.speed = IMMUNITY_STREAM_SPEED * packetSpeedMultiplier;
            packet.opacity = 1;
            packet.lateralOffset = direction === 1 ? 6 : -6;
            immunityPackets.push(packet);
            incrementStat("totalImmunityPackets");
          });
        });
      }

      function manageParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.update();
          p.draw();
          if (p.life <= 0) {
            particles.splice(i, 1);
          }
        }
      }

      function spawnDataPackets() {
        // Spawn packets on healthy edges
        // Control spawn rate to avoid overwhelming the visualization
        const SPAWN_CHANCE = 0.015; // 1.5% chance per frame to spawn on any given edge

        edges.forEach((edge) => {
          if (
            !edge.from ||
            !edge.to ||
            edge.from.state !== "alive" ||
            edge.to.state !== "alive"
          ) {
            return;
          }

          // Skip spawning on edges connected to migrating botnet nodes (prevents trail artifacts)
          const now = Date.now();
          const MIGRATION_DURATION = 5000;
          const fromMigrating =
            edge.from.botnetFormationTime &&
            now - edge.from.botnetFormationTime < MIGRATION_DURATION;
          const toMigrating =
            edge.to.botnetFormationTime &&
            now - edge.to.botnetFormationTime < MIGRATION_DURATION;
          if (fromMigrating || toMigrating) {
            return;
          }

          // Higher spawn rate on healthy links, lower on compromised ones
          let spawnMultiplier = 1;
          if (edge.to.status === "green" && edge.from.status !== "red") {
            spawnMultiplier = 1.5;
          } else if (
            edge.to.status === "red" ||
            edge.to.status === "malware" ||
            edge.to.status === "botnet"
          ) {
            spawnMultiplier = 0.3;
          } else if (edge.to.status === "yellow") {
            spawnMultiplier = 0.7;
          }

          // Spawn packet traveling from parent to child (forward direction)
          if (Math.random() < SPAWN_CHANCE * spawnMultiplier) {
            const packet = new DataPacket(edge, 1);
            dataPackets.push(packet);
            // Track packet type for stats
            if (packet.type === "data") incrementStat("totalDataPackets");
            else if (packet.type === "control")
              incrementStat("totalControlPackets");
            else if (packet.type === "security")
              incrementStat("totalSecurityPackets");
          }

          // Spawn packet traveling from child to parent (backward direction)
          // Less frequent backward traffic
          if (Math.random() < SPAWN_CHANCE * spawnMultiplier * 0.6) {
            const packet = new DataPacket(edge, -1);
            dataPackets.push(packet);
            // Track packet type for stats
            if (packet.type === "data") incrementStat("totalDataPackets");
            else if (packet.type === "control")
              incrementStat("totalControlPackets");
            else if (packet.type === "security")
              incrementStat("totalSecurityPackets");
          }
        });
      }

      function manageDataPackets() {
        // Spawn new packets
        spawnDataPackets();

        // Update and draw existing packets
        for (let i = dataPackets.length - 1; i >= 0; i--) {
          const packet = dataPackets[i];
          packet.update();
          packet.draw();

          // Remove inactive packets
          if (!packet.active) {
            dataPackets.splice(i, 1);
          }
        }
      }

      function spawnImmunityPackets() {
        // Spawn immunity packets only from healthy firewalled nodes
        const SPAWN_CHANCE = 0.002; // Very rare spawn rate

        edges.forEach((edge) => {
          if (
            !edge.from ||
            !edge.to ||
            edge.from.state !== "alive" ||
            edge.to.state !== "alive"
          ) {
            return;
          }

          // Only spawn from edges where at least one node is healthy AND has firewall
          const fromIsHealthyFirewalled =
            edge.from.status === "green" && edge.from.hasFirewall;
          const toIsHealthyFirewalled =
            edge.to.status === "green" && edge.to.hasFirewall;

          if (fromIsHealthyFirewalled || toIsHealthyFirewalled) {
            // Spawn immunity packet in both directions (very rarely)
            if (Math.random() < SPAWN_CHANCE) {
              immunityPackets.push(new ImmunityPacket(edge, 1));
              incrementStat("totalImmunityPackets");
            }
            if (Math.random() < SPAWN_CHANCE) {
              immunityPackets.push(new ImmunityPacket(edge, -1));
              incrementStat("totalImmunityPackets");
            }
          }
        });
      }

      // --- Bot Defense Mode logic ---
      function evaluateBotDefenseMode() {
        const central = nodes[0];
        if (!central || central.parent !== null) return;
        const now = Date.now();
        // If central is compromised, disable mode and clear
        if (
          central.status === "malware" ||
          central.status === "botnet" ||
          central.status === "commandControl" ||
          central.state !== "alive"
        ) {
          central.botDefenseModeActive = false;
          central.botDefenseTargets = [];
          central.botDefenseLastBurst = 0;
          return;
        }
        // Count infected direct children (branches)
        const infectedBranches = (central.children || []).filter(
          (ch) =>
            ch &&
            ch.state === "alive" &&
            (ch.status === "malware" ||
              ch.status === "botnet" ||
              ch.status === "commandControl")
        );
        if (central.botDefenseModeActive) {
          // End if duration elapsed or not enough infected branches
          if (
            now - central.botDefenseModeStart >= BOT_DEFENSE_DURATION ||
            infectedBranches.length < 3
          ) {
            central.botDefenseModeActive = false;
            central.botDefenseTargets = [];
            central.botDefenseLastBurst = 0;
            central.botDefenseCooldownUntil = now + BOT_DEFENSE_COOLDOWN;
          } else {
            central.botDefenseTargets = infectedBranches;
          }
          return;
        }
        // Not active: can we start?
        if (
          infectedBranches.length >= 3 &&
          now >= (central.botDefenseCooldownUntil || 0) &&
          Math.random() < 0.5
        ) {
          central.botDefenseModeActive = true;
          central.botDefenseModeStart = now;
          central.botDefenseTargets = infectedBranches;
          central.botDefenseLastBurst = 0;
          // aura will render in draw()
        }
      }

      function getInfectedNodesUnder(branch) {
        const result = [];
        const stack = [branch];
        while (stack.length) {
          const n = stack.pop();
          if (!n || n.state !== "alive") continue;
          if (
            n !== branch &&
            (n.status === "malware" ||
              n.status === "botnet" ||
              n.status === "commandControl")
          ) {
            result.push(n);
          }
          if (n.children && n.children.length) {
            for (const c of n.children) stack.push(c);
          }
        }
        // If none deeper, allow branch itself if infected
        if (
          result.length === 0 &&
          (branch.status === "malware" ||
            branch.status === "botnet" ||
            branch.status === "commandControl")
        ) {
          result.push(branch);
        }
        return result;
      }

      function createBotDefensePacket(centralNode, branchNode, targetNode) {
        // Find direct edge between central and branch
        const connection = edges.find(
          (e) =>
            (e.from === centralNode && e.to === branchNode) ||
            (e.to === centralNode && e.from === branchNode)
        );
        if (!connection) return;
        const direction = connection.from === centralNode ? 1 : -1;
        const packet = new ImmunityPacket(connection, direction);
        packet.progress =
          direction === 1 ? Math.random() * 0.2 : 1 - Math.random() * 0.2;
        packet.lateralOffset = direction === 1 ? 6 : -6;
        packet.isSupercharged = true;
        packet.isSeeking = true;
        packet.targetNode = targetNode;
        packet.speed = packet.baseSpeed * 2.5 * packetSpeedMultiplier;
        packet.opacity = 1;
        packet.radius = 3;
        immunityPackets.push(packet);
        incrementStat("totalImmunityPackets");
      }

      function handleBotDefenseBursts() {
        // REMOVED: Supercharged immunity packet bursts from central node's Bot Defense Mode
        // Central node now only sends supercharged packets to first infected parent nodes in each branch
        // during recovery (unlimited) or via consumed packets for dispatch
        return;
      }

      function manageImmunityPackets() {
        handleBotDefenseBursts();
        // Spawn new immunity packets
        spawnImmunityPackets();
        spawnGuardianImmunityStreams();

        // Update and draw existing packets (except those attached to central node)
        for (let i = immunityPackets.length - 1; i >= 0; i--) {
          const packet = immunityPackets[i];
          packet.update();

          // Only draw if NOT attached to central node (will draw those later on top)
          const isAttachedToCentral =
            packet.isAttached &&
            packet.attachedNode &&
            packet.attachedNode.parent === null;
          if (!isAttachedToCentral) {
            packet.draw();
          }

          // Remove inactive packets
          if (!packet.active) {
            // Remove from attached node's list if it was attached
            if (packet.attachedNode) {
              const idx =
                packet.attachedNode.attachedImmunityPackets.indexOf(packet);
              if (idx !== -1) {
                packet.attachedNode.attachedImmunityPackets.splice(idx, 1);
              }
            }
            immunityPackets.splice(i, 1);
          }
        }
      }

      function managePingOfDeath() {
        // C&C nodes send ping of death packets to attack random nodes
        const ccNodes = nodes.filter(
          (n) =>
            n.status === "commandControl" &&
            n.state === "alive" &&
            n.parent !== null
        );

        ccNodes.forEach((ccNode) => {
          // Check if this C&C can send a ping (one at a time, with cooldown)
          const now = Date.now();

          // Find connected green nodes for aggressive targeting
          const connectedGreenNodes = [];
          edges.forEach((edge) => {
            if (edge.isBotnetMesh) {
              let otherNode = null;
              if (
                edge.from === ccNode &&
                edge.to.state === "alive" &&
                edge.to.status === "green"
              ) {
                otherNode = edge.to;
              } else if (
                edge.to === ccNode &&
                edge.from.state === "alive" &&
                edge.from.status === "green"
              ) {
                otherNode = edge.from;
              }
              if (
                otherNode &&
                !otherNode.isSatellite &&
                !otherNode.isGroundStation &&
                !connectedGreenNodes.includes(otherNode)
              ) {
                connectedGreenNodes.push(otherNode);
              }
            }
          });

          // Aggressive mode: shorter cooldown and higher attack rate for connected green nodes
          const hasConnectedGreenNodes = connectedGreenNodes.length > 0;

          // DDOS persistent attack: 2x faster pings during active DDOS
          const ddosSpeedBoost = ccNode.ddosState === "active" ? 2.0 : 1.0;
          const PING_COOLDOWN =
            (hasConnectedGreenNodes ? 4000 : 8000) /
            attackFreqMultiplier /
            ddosSpeedBoost;
          const baseAttackChance =
            (hasConnectedGreenNodes ? 0.4 : 0.15) * attackFreqMultiplier;
          const attackChance = baseAttackChance * ddosSpeedBoost;

          // If self-inflicted DDOS is active, disable pings
          if (ccNode.isSelfInflictedDDOS) return;

          if (
            ccNode.activePingOfDeath ||
            now - ccNode.lastPingTime < PING_COOLDOWN
          ) {
            return; // Already has active ping or on cooldown
          }

          // Higher chance to send ping if connected to green nodes
          if (Math.random() < Math.min(1, attackChance)) {
            let target;

            // During DDOS, ONLY target nodes in the affected branch
            if (ccNode.ddosState === "active" && ccNode.ddosTargetBranch) {
              const branchTargets = nodes.filter(
                (n) =>
                  n.state === "alive" &&
                  n.parent !== null &&
                  n !== ccNode &&
                  !n.isSatellite &&
                  !n.isGroundStation &&
                  isNodeInDDOSBranch(n)
              );
              if (branchTargets.length > 0) {
                target =
                  branchTargets[
                    Math.floor(Math.random() * branchTargets.length)
                  ];
              }
              // If no targets in DDOS branch, don't send ping at all during DDOS
            } else {
              // Aggressively prioritize connected green nodes (90% of the time)
              if (connectedGreenNodes.length > 0 && Math.random() < 0.9) {
                target =
                  connectedGreenNodes[
                    Math.floor(Math.random() * connectedGreenNodes.length)
                  ];
                logEvent("commandControlAggressiveAttack", { ccNode, target });
              } else {
                // Find all valid targets (alive nodes, not central node, not self)
                const validTargets = nodes.filter(
                  (n) =>
                    n.state === "alive" &&
                    n.parent !== null && // Not the central node
                    n !== ccNode && // Not self
                    !n.isCommandControl && // Don't target other C&C nodes
                    !n.isSatellite &&
                    !n.isGroundStation // Don't target ground stations
                );

                if (validTargets.length > 0) {
                  // Try to pick a node with children (non-leaf) 70% of the time
                  const nonLeafNodes = validTargets.filter(
                    (n) => n.children && n.children.length > 0
                  );
                  if (nonLeafNodes.length > 0 && Math.random() < 0.7) {
                    target =
                      nonLeafNodes[
                        Math.floor(Math.random() * nonLeafNodes.length)
                      ];
                  } else {
                    target =
                      validTargets[
                        Math.floor(Math.random() * validTargets.length)
                      ];
                  }
                }
              }
            }

            // Create ping of death packet if we have a target
            if (target) {
              const ping = new PingOfDeath(ccNode, target);

              if (ping.path && ping.path.length > 0) {
                pingOfDeathPackets.push(ping);
                ccNode.activePingOfDeath = ping;
                ccNode.lastPingTime = now;
                const targetType =
                  target.children && target.children.length > 0
                    ? "branch"
                    : "leaf";
                logEvent("pingOfDeathSent", {
                  ccNode,
                  target,
                  targetType,
                  pathLength: ping.path.length,
                });
                incrementStat("totalAttacks");
                incrementStat("totalPingPackets");
              } else {
                // Log failed pathfinding for debugging
                logEvent("pingOfDeathFailed", { ccNode });
              }
            }
          }
        });

        // Update all ping of death packets
        pingOfDeathPackets.forEach((ping) => {
          ping.update();
          ping.draw();
        });

        // Remove finished pings
        pingOfDeathPackets = pingOfDeathPackets.filter(
          (ping) => ping.state !== "finished"
        );
      }

      function managePhishPackets() {
        // C&C nodes send bursts of phishing packets to random targets
        const ccNodes = nodes.filter(
          (n) =>
            n.status === "commandControl" &&
            n.state === "alive" &&
            n.parent !== null
        );

        ccNodes.forEach((ccNode) => {
          // If self-inflicted DDOS is active, disable phishing
          if (ccNode.isSelfInflictedDDOS) return;

          // DDOS persistent attack: 2x faster phishing during active DDOS
          const ddosSpeedBoost = ccNode.ddosState === "active" ? 2.0 : 1.0;
          const PHISH_BURST_COOLDOWN =
            15000 / attackFreqMultiplier / ddosSpeedBoost;
          const now = Date.now();

          // Initialize phish burst tracking
          if (!ccNode.lastPhishBurstTime) {
            ccNode.lastPhishBurstTime = 0;
          }

          if (now - ccNode.lastPhishBurstTime < PHISH_BURST_COOLDOWN) {
            return; // Still on cooldown
          }

          // DDOS persistent attack: 2x higher chance during active DDOS
          const baseChance = 0.1 * attackFreqMultiplier;
          const attackChance = baseChance * ddosSpeedBoost;

          if (Math.random() < Math.min(1, attackChance)) {
            // Find all valid green targets
            let validTargets = nodes.filter(
              (n) =>
                n.state === "alive" &&
                n.parent !== null && // Not the central node
                n !== ccNode && // Not self
                n.status === "green" && // Only target green nodes
                !n.isCommandControl && // Don't target other C&C nodes
                !n.isSatellite &&
                !n.isGroundStation // Don't target ground stations
            );

            // During DDOS, ONLY target nodes in the affected branch
            if (ccNode.ddosState === "active" && ccNode.ddosTargetBranch) {
              const branchTargets = validTargets.filter((n) =>
                isNodeInDDOSBranch(n)
              );
              if (branchTargets.length > 0) {
                validTargets = branchTargets; // Exclusively target DDOS branch
              } else {
                validTargets = []; // No valid targets during DDOS - skip phishing
              }
            }

            if (validTargets.length > 0) {
              // Send burst of 1-3 phish packets
              const burstSize = Math.min(3, Math.floor(Math.random() * 3) + 1);

              for (let i = 0; i < burstSize; i++) {
                // Pick random target for each packet
                const target =
                  validTargets[Math.floor(Math.random() * validTargets.length)];
                const phish = new PhishPacket(ccNode, target);

                if (phish.path && phish.path.length > 0) {
                  phishPackets.push(phish);
                  incrementStat("totalAttacks");
                  incrementStat("totalPhishPackets");
                }
              }

              ccNode.lastPhishBurstTime = now;
              logEvent("commandControlPhishBurst", { ccNode, burstSize });
            }
          }
        });

        // Update all phish packets
        phishPackets.forEach((phish) => {
          phish.update();
          phish.draw();
        });

        // Remove finished phish packets
        phishPackets = phishPackets.filter(
          (phish) => phish.state !== "finished"
        );
      }

      function manageDDOSAttacks() {
        const now = Date.now();
        const DDOS_CHARGE_TIME = 6000 / attackFreqMultiplier;
        const DDOS_DURATION = 12000;
        const DDOS_COOLDOWN = 25000 / attackFreqMultiplier;

        // Find all C&C nodes
        const ccNodes = nodes.filter(
          (n) =>
            n.status === "commandControl" &&
            n.state === "alive" &&
            n.parent !== null
        );

        ccNodes.forEach((ccNode) => {
          // State machine for DDOS attack
          if (ccNode.ddosState === "charging") {
            const elapsed = now - ccNode.ddosChargeStart;
            if (elapsed >= DDOS_CHARGE_TIME) {
              // Charging complete - check if Central Node blocks it (50% chance)
              const centralNode = nodes[0];
              // Only block if central node is alive.
              const isBlocked =
                centralNode &&
                centralNode.state === "alive" &&
                Math.random() < 0.5;

              if (isBlocked) {
                // Attack Blocked - Reflect back to source!

                // Find the source branch (the branch containing the C&C node)
                let sourceBranch = ccNode;
                while (
                  sourceBranch.parent &&
                  sourceBranch.parent.parent !== null
                ) {
                  sourceBranch = sourceBranch.parent;
                }

                // Redirect attack to source branch
                ccNode.ddosState = "active";
                ccNode.ddosActiveStart = now;
                ccNode.ddosTargetBranch = sourceBranch;
                ccNode.isSelfInflictedDDOS = true;
                ccNode.ddosAttackPaths = null; // Force rebuild of attack paths

                // Mark target branch as under attack
                if (ccNode.ddosTargetBranch) {
                  ccNode.ddosTargetBranch.isUnderDDOS = true;
                  ccNode.ddosTargetBranch.ddosAttacker = ccNode;
                }

                logEvent("custom", {
                  message: `üõ°Ô∏è Central node REFLECTED DDOS attack from C&C ${ccNode.id}! Backfiring on source branch ${sourceBranch.id}!`,
                });
                incrementStat("totalDefenses");
              } else {
                // Attack Successful - Launch DDOS
                ccNode.ddosState = "active";
                ccNode.ddosActiveStart = now;

                // Mark target branch as under attack
                if (ccNode.ddosTargetBranch) {
                  ccNode.ddosTargetBranch.isUnderDDOS = true;
                  ccNode.ddosTargetBranch.ddosAttacker = ccNode;
                }

                logEvent("ddosLaunched", {
                  ccNode,
                  targetBranch: ccNode.ddosTargetBranch,
                  botnetCount: ccNode.ddosBotnets.length,
                });

                // Increment DDOS attack counter
                incrementStat("totalDDOSAttacks");
              }
            }
          } else if (ccNode.ddosState === "active") {
            const elapsed = now - ccNode.ddosActiveStart;

            // Create DDOS attack paths along existing network topology
            if (
              ccNode.ddosBotnets &&
              ccNode.ddosBotnets.length > 0 &&
              ccNode.ddosTargetBranch
            ) {
              // Initialize DDOS attack paths if not already created
              if (!ccNode.ddosAttackPaths) {
                ccNode.ddosAttackPaths = [];

                // Each botnet creates ONE attack path to the target branch node
                ccNode.ddosBotnets.forEach((botnet) => {
                  if (botnet.state !== "alive") return;

                  // Find path from botnet to target through existing network
                  // Path: botnet ‚Üí up to central ‚Üí target branch node
                  const path = [];

                  // Trace up from botnet to central node
                  let current = botnet;
                  while (
                    current &&
                    current.parent &&
                    current.parent.parent !== null
                  ) {
                    const edge = edges.find(
                      (e) =>
                        (e.from === current && e.to === current.parent) ||
                        (e.to === current && e.from === current.parent)
                    );
                    if (edge) {
                      path.push({
                        edge: edge,
                        direction: edge.from === current ? 1 : -1, // 1 = from->to, -1 = to->from
                        botnet: botnet,
                      });
                    }
                    current = current.parent;
                  }

                  // Add edge from main branch node to central
                  if (current && current.parent === nodes[0]) {
                    const edgeToCentral = edges.find(
                      (e) =>
                        (e.from === current && e.to === nodes[0]) ||
                        (e.to === current && e.from === nodes[0])
                    );
                    if (edgeToCentral) {
                      path.push({
                        edge: edgeToCentral,
                        direction: edgeToCentral.from === current ? 1 : -1,
                        botnet: botnet,
                      });
                    }
                  }

                  // Add edge from central to target branch
                  const edgeToTarget = edges.find(
                    (e) =>
                      (e.from === nodes[0] &&
                        e.to === ccNode.ddosTargetBranch) ||
                      (e.to === nodes[0] && e.from === ccNode.ddosTargetBranch)
                  );
                  if (edgeToTarget) {
                    path.push({
                      edge: edgeToTarget,
                      direction: edgeToTarget.from === nodes[0] ? 1 : -1,
                      botnet: botnet,
                    });
                  }

                  if (path.length > 0) {
                    const attackPath = {
                      botnet: botnet,
                      path: path,
                      startTime: now,
                      target: ccNode.ddosTargetBranch,
                    };
                    ccNode.ddosAttackPaths.push(attackPath);

                    // Performance: Cache DDOS data on edges for faster rendering
                    path.forEach((pathSegment) => {
                      pathSegment.edge.ddosAttackData = {
                        attackPath: attackPath,
                        edgeInPath: pathSegment,
                        startTime: now,
                      };
                    });
                  }
                });
              }
            }

            if (elapsed >= DDOS_DURATION) {
              // DDOS complete - enter cooldown
              ccNode.ddosState = "idle";
              ccNode.ddosCooldownUntil = now + DDOS_COOLDOWN;
              ccNode.isSelfInflictedDDOS = false;

              // Clear target branch DDOS status
              if (ccNode.ddosTargetBranch) {
                ccNode.ddosTargetBranch.isUnderDDOS = false;
                ccNode.ddosTargetBranch.ddosAttacker = null;

                logEvent("ddosEnded", {
                  ccNode,
                  targetBranch: ccNode.ddosTargetBranch,
                });
              }

              // Clean up DDOS attack paths and clear cached edge data
              if (ccNode.ddosAttackPaths) {
                ccNode.ddosAttackPaths.forEach((attackPath) => {
                  attackPath.path.forEach((pathSegment) => {
                    if (pathSegment.edge) {
                      delete pathSegment.edge.ddosAttackData;
                    }
                  });
                });
                ccNode.ddosAttackPaths = [];
              }

              ccNode.ddosTargetBranch = null;
              ccNode.ddosBotnets = [];
            }
          } else if (ccNode.ddosState === "idle") {
            // Check if we can start a new DDOS attack
            if (now < ccNode.ddosCooldownUntil) return; // Still on cooldown

            // Count connected botnet nodes
            const connectedBotnets = [];
            edges.forEach((edge) => {
              let otherNode = null;
              if (
                edge.from === ccNode &&
                edge.to &&
                edge.to.status === "botnet" &&
                edge.to.state === "alive"
              ) {
                otherNode = edge.to;
              } else if (
                edge.to === ccNode &&
                edge.from &&
                edge.from.status === "botnet" &&
                edge.from.state === "alive"
              ) {
                otherNode = edge.from;
              }
              if (otherNode && !connectedBotnets.includes(otherNode)) {
                connectedBotnets.push(otherNode);
              }
            });

            // Need at least 3 botnets to launch DDOS
            if (connectedBotnets.length < 3) return;

            // Find suitable target: a large branch (direct child of central node)
            const centralNode = nodes[0];
            if (!centralNode) return;

            // Find which branch the C&C node belongs to (walk up to find main branch)
            let ccBranch = ccNode;
            while (ccBranch.parent && ccBranch.parent.parent !== null) {
              ccBranch = ccBranch.parent;
            }
            // ccBranch is now the main branch (direct child of central) that contains the C&C

            const validBranches = centralNode.children.filter(
              (branch) =>
                branch &&
                branch.state === "alive" &&
                !branch.isSatellite &&
                !branch.isUnderDDOS && // Don't target already attacked branches
                branch !== ccBranch && // Don't target the C&C's own branch
                branch.hasFirewall // Only target firewalled nodes
            );

            if (validBranches.length === 0) return;

            // Prioritize large branches (most descendants)
            validBranches.sort((a, b) => {
              const aDesc = countDescendants(a);
              const bDesc = countDescendants(b);
              return bDesc - aDesc;
            });

            // 20% chance to initiate DDOS each check (affected by attack frequency multiplier)
            if (Math.random() < Math.min(1, 0.2 * attackFreqMultiplier)) {
              // Start charging DDOS
              ccNode.ddosState = "charging";
              ccNode.ddosChargeStart = now;
              ccNode.ddosTargetBranch = validBranches[0]; // Target largest branch
              ccNode.ddosBotnets = connectedBotnets;

              logEvent("ddosCharging", {
                ccNode,
                botnetCount: connectedBotnets.length,
                targetBranch: ccNode.ddosTargetBranch,
              });
            }
          }
        });
      }

      function manageCounterStrikes() {
        // Update and draw all counter-strike packets
        counterStrikePackets.forEach((strike) => {
          strike.update();
          strike.draw();
        });

        // Remove finished counter-strikes
        counterStrikePackets = counterStrikePackets.filter(
          (strike) => strike.state !== "finished"
        );
      }

      // Guardian Threat Hunting System
      let lastThreatScan = 0;
      const THREAT_SCAN_INTERVAL = 3000; // Scan every 3 seconds
      const GUARDIAN_DISPATCH_INTERVAL = 10000; // Guardians can send dispatch packets every 10 seconds
      const THREAT_SCAN_RADIUS = 200; // Detection radius

      function guardianThreatHunting() {
        const now = Date.now();
        if (now - lastThreatScan < THREAT_SCAN_INTERVAL) return;
        lastThreatScan = now;

        const guardians = nodes.filter(
          (n) => n.state === "alive" && n.isGuardian && n.status === "green"
        );

        guardians.forEach((guardian) => {
          // Guardian dispatch support ‚Äì send remediation to closest reachable infected node
          if (
            now - guardian.guardianDispatchLastSent >=
            GUARDIAN_DISPATCH_INTERVAL
          ) {
            const infectedCandidates = nodes.filter(
              (n) =>
                n &&
                n !== guardian &&
                n.state === "alive" &&
                (n.status === "malware" ||
                  n.status === "botnet" ||
                  n.status === "commandControl") &&
                !n.isTargeted &&
                n.remediationState === "none"
            );

            let bestTarget = null;
            let bestDistanceSq = Infinity;
            let bestPath = null;

            infectedCandidates.forEach((candidate) => {
              const path = buildNodePath(guardian, candidate);
              if (!path || path.length < 2) return;

              const intermediateNodes = path.slice(1, -1);
              const pathClear = intermediateNodes.every(
                (node) =>
                  node &&
                  node.state === "alive" &&
                  (node.status === "green" || node.status === "blue")
              );
              if (!pathClear) return;

              const dx = candidate.x - guardian.x;
              const dy = candidate.y - guardian.y;
              const distanceSq = dx * dx + dy * dy;
              if (distanceSq < bestDistanceSq) {
                bestDistanceSq = distanceSq;
                bestTarget = candidate;
                bestPath = path;
              }
            });

            if (bestTarget && bestPath) {
              const dispatch = new DispatchPacket(bestTarget, guardian);
              if (dispatch.state !== "finished") {
                dispatchPackets.push(dispatch);
                incrementStat("totalDispatchPackets");
                bestTarget.isTargeted = true;
                guardian.guardianDispatchLastSent = now;
                logEvent("custom", {
                  message: `üï∂ Guardian ${guardian.id} dispatched remediation to node ${bestTarget.id}.`,
                });
              }
            }
          }

          // Threat hunting: prioritize directly connected infected nodes
          const connectedInfected = nodes.filter((n) => {
            if (n.state !== "alive") return false;
            if (
              n.status !== "malware" &&
              n.status !== "botnet" &&
              n.status !== "commandControl"
            )
              return false;
            if (n.isTargeted) return false; // Skip if already being remediated

            // Check if directly connected to guardian
            const isDirectlyConnected = edges.some(
              (edge) =>
                (edge.from === guardian && edge.to === n) ||
                (edge.from === n && edge.to === guardian)
            );

            return isDirectlyConnected;
          });

          if (connectedInfected.length > 0) {
            // Target the first directly connected infected node
            const target = connectedInfected[0];

            // Build path to target for dispatch packet
            const path = buildNodePath(guardian, target);
            if (path && path.length >= 2) {
              // Visual scan pulse effect
              createPopParticles(guardian.x, guardian.y, {
                r: 96,
                g: 165,
                b: 250,
              });

              // Send dispatch packet for remediation
              const dispatch = new DispatchPacket(target, guardian);
              if (dispatch.state !== "finished") {
                dispatchPackets.push(dispatch);
                incrementStat("totalDispatchPackets");
                target.isTargeted = true;
                logEvent("custom", {
                  message: `üîç Guardian ${guardian.id} hunting threat: dispatched remediation to connected node ${target.id}!`,
                });
              }
            }
          }
        });
      }

      function manageDispatchPackets() {
        const rootNode = nodes[0];
        // If the central node is compromised, it cannot send out remediation pulses.
        if (
          rootNode &&
          (rootNode.status === "malware" ||
            rootNode.status === "botnet" ||
            rootNode.status === "commandControl")
        ) {
          // Update and draw any pulses that were already in flight before the infection.
          dispatchPackets.forEach((dispatchPacket) => {
            dispatchPacket.update();
            dispatchPacket.draw();
          });
          dispatchPackets = dispatchPackets.filter(
            (packet) => packet.state !== "finished"
          );
          return; // Stop here and don't create new pulses.
        }

        // Get all infected nodes that are eligible for dispatch
        const malwareNodes = nodes.filter(
          (n) =>
            (n.status === "malware" ||
              n.status === "botnet" ||
              n.status === "commandControl") &&
            n.infectedAt &&
            !n.isTargeted
        );

        // Prioritize directly connected infected nodes (children of central node)
        const directlyConnected = malwareNodes.filter(
          (n) => n.parent === rootNode
        );
        const indirectlyConnected = malwareNodes.filter(
          (n) => n.parent !== rootNode
        );

        // Process directly connected nodes first, then indirect ones
        const prioritizedNodes = [...directlyConnected, ...indirectlyConnected];

        for (const node of prioritizedNodes) {
          if (Date.now() > node.infectedAt + node.dispatchDelay) {
            // Build the path to the target node to check for obstructions
            const path = [];
            let currentNode = node;
            while (currentNode) {
              path.push(currentNode);
              currentNode = currentNode.parent;
            }
            path.reverse(); // Path is now [root, ..., target]

            // A path is clear if all intermediate nodes are green.
            // The root is blue, and the final node is malware, so we check the nodes in between.
            const isPathClear = path
              .slice(1, -1)
              .every((pathNode) => pathNode.status === "green");

            // Only send a pulse if the path is not blocked by a red/yellow node
            if (isPathClear) {
              // Check if central node has supercharged immunity packets (unless self-healing = unlimited)
              if (rootNode.isSelfHealing) {
                // During recovery, central node has unlimited supercharged packets
                dispatchPackets.push(new DispatchPacket(node));
                incrementStat("totalDispatchPackets");
                node.isTargeted = true;
              } else {
                // Check for available supercharged immunity packets
                const superchargedPackets =
                  rootNode.attachedImmunityPackets.filter(
                    (p) => p && p.isSupercharged
                  );

                if (superchargedPackets.length > 0) {
                  // Consume one supercharged immunity packet (1:1 ratio)
                  const consumedPacket = superchargedPackets[0];
                  consumedPacket.active = false;
                  rootNode.attachedImmunityPackets =
                    rootNode.attachedImmunityPackets.filter(
                      (p) => p !== consumedPacket
                    );

                  // Send dispatch packet
                  dispatchPackets.push(new DispatchPacket(node));
                  incrementStat("totalDispatchPackets");
                  node.isTargeted = true;
                } else {
                  // No supercharged packets available - cannot send dispatch
                  // Stop processing to prevent checking more nodes when resources are depleted
                  break;
                }
              }
            }
          }
        }

        dispatchPackets.forEach((dispatchPacket) => {
          dispatchPacket.update();
          dispatchPacket.draw();
        });

        dispatchPackets = dispatchPackets.filter(
          (packet) => packet.state !== "finished"
        );
      }

      function animate() {
        const now = Date.now();
        const GUARDIAN_FIREWALL_ATTEMPT_DURATION = 2000 / healSpeedMultiplier;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGalaxyBackground(now);
        gradientOffset = (gradientOffset + 0.005) % 1;

        // Update Ticker
        TickerSystem.update();

        // Performance: Pre-calculate common animation values once per frame
        const animValues = {
          pulse005: Math.sin(now * 0.005),
          pulse008: Math.sin(now * 0.008),
          pulse01: Math.sin(now * 0.01),
          pulse02: Math.sin(now * 0.02),
          pulse001: Math.sin(now * 0.001),
          nowMod10: (now * 0.02) % 10,
          nowMod9: (now * 0.00125) % 9,
        };

        // Performance: Viewport culling helper (with generous margin for large nodes/effects)
        const viewportMargin = 100;
        const isInViewport = (x, y, radius = 0) => {
          return (
            x + radius > -viewportMargin &&
            x - radius < canvas.width + viewportMargin &&
            y + radius > -viewportMargin &&
            y - radius < canvas.height + viewportMargin
          );
        };

        // Performance: Cache commonly used color strings to avoid repeated string concatenation
        const cachedColors = {
          green015: `rgba(${colors.green.r}, ${colors.green.g}, ${colors.green.b}, 0.15)`,
          green03: `rgba(${colors.green.r}, ${colors.green.g}, ${colors.green.b}, 0.3)`,
          malware: `rgba(${colors.malware.r}, ${colors.malware.g}, ${colors.malware.b}, 1)`,
          line05: `rgba(${colors.line.r}, ${colors.line.g}, ${colors.line.b}, 0.5)`,
          red: `rgba(220, 38, 38, 1)`,
          neonGreen: `rgba(${colors.neonGreen.r}, ${colors.neonGreen.g}, ${colors.neonGreen.b}, 1)`,
          blue04: `rgba(${colors.blue.r}, ${colors.blue.g}, ${colors.blue.b}, 0.4)`,
        };

        // MODIFIED: Build and use the Quadtree for physics calculations
        const overscan = Math.max(
          60,
          Math.min(canvas.width, canvas.height) * 0.05
        );
        let boundary = new Rectangle(
          canvas.width / 2,
          canvas.height / 2,
          canvas.width / 2 + overscan,
          canvas.height / 2 + overscan
        );
        let qtree = new Quadtree(boundary, 4);
        for (const node of nodes) {
          if (node.state === "alive") {
            qtree.insert(node);
          }
        }

        applyBoundaryRepulsion(qtree);
        applyRepulsion(qtree);
        applyEdgeRepulsion();
        applySpringForces();
        updateGuardianVpnTunnels();

        // NEW: Update Camera Zoom
        updateCamera();

        // Apply Camera Transform
        const panelOffset = viewState.isSidePanelOpen
          ? viewState.sidePanelWidth
          : 0;
        const visualCx = (canvas.width - panelOffset) / 2;
        const visualCy = canvas.height / 2;
        const worldCx = canvas.width / 2;
        const worldCy = canvas.height / 2;

        ctx.save();
        ctx.translate(visualCx, visualCy);
        ctx.scale(viewState.scale, viewState.scale);
        ctx.translate(-worldCx, -worldCy);

        edges.forEach((edge) => {
          const fromNode = edge.from,
            toNode = edge.to;
          if (!fromNode || !toNode) return;

          const edgeOpacity = Math.min(fromNode.opacity, toNode.opacity);
          if (edgeOpacity <= 0) return;

          // Performance: Viewport culling for edges - skip if both endpoints are off-screen
          // Need to account for zoom in culling logic if strictly optimizing,
          // but for now relying on simple margin is okay or we can skip culling for simplicity
          // since zoom changes viewport bounds.
          // Let's disable strict culling for edges temporarily or update it to be zoom-aware.
          // For simplicity, we'll just draw them.

          ctx.lineWidth = 4;

          const forwardInfection = fromNode.spreadingInfections?.find(
            (i) => i.target === toNode
          );
          const backwardInfection = toNode.spreadingInfections?.find(
            (i) => i.target === fromNode
          );

          // Performance: Check if this edge is part of an active DDOS attack path
          // Use edge property to cache DDOS state instead of searching all nodes
          let ddosAttackOnEdge = edge.ddosAttackData || null;

          if (ddosAttackOnEdge) {
            // DDOS attack on this edge: dark red base with bright red flowing animation
            ctx.setLineDash([]);
            const elapsed = now - ddosAttackOnEdge.startTime;
            const DDOS_ADVANCE_SPEED = 4000; // 4 seconds to traverse the entire network

            // Calculate overall progress (0 to 1) across the entire path
            const pathProgress = Math.min(1, elapsed / DDOS_ADVANCE_SPEED);

            // Determine this edge's position in the path
            const pathLength = ddosAttackOnEdge.attackPath.path.length;
            const edgeIndex = ddosAttackOnEdge.attackPath.path.indexOf(
              ddosAttackOnEdge.edgeInPath
            );
            const edgeStartProgress = edgeIndex / pathLength;
            const edgeEndProgress = (edgeIndex + 1) / pathLength;

            // Calculate this edge's local progress (0 to 1)
            let localProgress = 0;
            if (
              pathProgress >= edgeStartProgress &&
              pathProgress <= edgeEndProgress
            ) {
              localProgress =
                (pathProgress - edgeStartProgress) /
                (edgeEndProgress - edgeStartProgress);
            } else if (pathProgress > edgeEndProgress) {
              localProgress = 1; // Attack has passed through
            }

            // Create gradient based on direction
            const direction = ddosAttackOnEdge.edgeInPath.direction;
            const startNode = direction === 1 ? fromNode : toNode;
            const endNode = direction === 1 ? toNode : fromNode;

            const gradient = ctx.createLinearGradient(
              startNode.x,
              startNode.y,
              endNode.x,
              endNode.y
            );
            const darkRedColor = `rgba(139, 0, 0, ${edgeOpacity})`; // Dark red base
            const brightRedColor = `rgba(255, 50, 50, ${edgeOpacity})`; // Bright red flow

            if (localProgress > 0) {
              gradient.addColorStop(0, brightRedColor);
              gradient.addColorStop(Math.min(1, localProgress), brightRedColor);
              gradient.addColorStop(
                Math.min(1, localProgress + 0.01),
                darkRedColor
              );
              gradient.addColorStop(1, darkRedColor);
            } else {
              gradient.addColorStop(0, darkRedColor);
              gradient.addColorStop(1, darkRedColor);
            }

            ctx.strokeStyle = gradient;
            ctx.lineWidth = 5; // Thicker to emphasize attack
          } else if (edge.isWirelessLink) {
            ctx.setLineDash([4, 6]);
            const pulse =
              0.45 + 0.35 * Math.sin(now * 0.005 + (edge.pulseSeed || 0));
            ctx.lineDashOffset = -animValues.nowMod10;
            ctx.strokeStyle = `rgba(170, 170, 170, ${pulse * edgeOpacity})`; // Medium light grey
          } else if (forwardInfection || backwardInfection) {
            ctx.setLineDash([]);
            const infection = forwardInfection || backwardInfection;
            const infector = forwardInfection ? fromNode : toNode;
            const target = forwardInfection ? toNode : fromNode;

            const elapsed = now - infection.startTime;
            let progress;

            // Special animation for central node attack
            if (target.parent === null) {
              const ATTACK_ADVANCE_TIME = 1500;
              const ATTACK_RETREAT_TIME = 1000;

              if (elapsed < ATTACK_ADVANCE_TIME) {
                // Line moves towards center, but stops at 90% of the way
                progress = (elapsed / ATTACK_ADVANCE_TIME) * 0.9;
              } else {
                // Line retracts as the defense pulse fires
                const retreatElapsed = elapsed - ATTACK_ADVANCE_TIME;
                progress =
                  0.9 * (1 - Math.min(1, retreatElapsed / ATTACK_RETREAT_TIME));
              }
              progress = Math.max(0, progress); // prevent negative progress
            } else {
              // Normal downstream infection
              progress = Math.min(1, elapsed / 4000);
            }

            // Draw the underlying connection (faded)
            ctx.beginPath();
            ctx.moveTo(infector.x, infector.y);
            ctx.lineTo(target.x, target.y);
            ctx.strokeStyle = `rgba(${colors.line.r}, ${colors.line.g}, ${
              colors.line.b
            }, ${0.15 * edgeOpacity})`;
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw the organic "tentacle" infection
            if (progress > 0.01) {
              const dx = target.x - infector.x;
              const dy = target.y - infector.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              const angle = Math.atan2(dy, dx);
              const currentDist = dist * progress;

              // Number of segments for the organic curve
              const segments = Math.max(4, Math.floor(currentDist / 8));

              ctx.beginPath();
              ctx.moveTo(infector.x, infector.y);

              for (let i = 1; i <= segments; i++) {
                const t = i / segments; // 0 to 1 along the tentacle
                const pointDist = currentDist * t;

                // Base position on the line
                const bx = infector.x + Math.cos(angle) * pointDist;
                const by = infector.y + Math.sin(angle) * pointDist;

                // Organic wiggle calculation
                // Phase shifts over time for movement
                const wavePhase = now * 0.015 - t * 8;
                // Amplitude tapers at the start (attached to node) and is steady towards tip
                const taper = Math.min(1, t * 3);
                const amplitude = 3 * taper;

                // Perpendicular offset
                const px = -Math.sin(angle);
                const py = Math.cos(angle);

                const offsetX = px * Math.sin(wavePhase) * amplitude;
                const offsetY = py * Math.sin(wavePhase) * amplitude;

                ctx.lineTo(bx + offsetX, by + offsetY);
              }

              // Styling for the tentacle
              ctx.lineCap = "round";
              ctx.lineJoin = "round";
              ctx.lineWidth = 3;
              ctx.strokeStyle = `rgba(${colors.malware.r}, ${colors.malware.g}, ${colors.malware.b}, ${edgeOpacity})`;
              ctx.shadowColor = `rgba(${colors.malware.r}, ${colors.malware.g}, ${colors.malware.b}, 0.8)`;
              ctx.shadowBlur = 8;
              ctx.stroke();
              ctx.shadowBlur = 0; // Reset shadow

              // Draw a glowing "head" at the tip
              const tipX = infector.x + Math.cos(angle) * currentDist;
              const tipY = infector.y + Math.sin(angle) * currentDist;
              // Add slight wiggle to tip too
              const tipWavePhase = now * 0.015 - 8;
              const tipPx = -Math.sin(angle);
              const tipPy = Math.cos(angle);
              const tipOffsetX = tipPx * Math.sin(tipWavePhase) * 3;
              const tipOffsetY = tipPy * Math.sin(tipWavePhase) * 3;

              ctx.beginPath();
              ctx.arc(
                tipX + tipOffsetX,
                tipY + tipOffsetY,
                3.5,
                0,
                Math.PI * 2
              );
              ctx.fillStyle = `rgba(${colors.malware.r}, ${colors.malware.g}, ${colors.malware.b}, ${edgeOpacity})`;
              ctx.shadowColor = `rgba(${colors.malware.r}, ${colors.malware.g}, ${colors.malware.b}, 1)`;
              ctx.shadowBlur = 12;
              ctx.fill();
              ctx.shadowBlur = 0;
            }

            return; // Skip default drawing
          } else if (edge.isGuardianVpnTunnel) {
            ctx.setLineDash([6, 3]);
            ctx.lineDashOffset = -animValues.nowMod9;

            const attempt = edge.guardianFirewallAttempt;
            const guardianColor = `rgba(${colors.neonGreen.r}, ${colors.neonGreen.g}, ${colors.neonGreen.b}, ${edgeOpacity})`;
            const baseColor = `rgba(${colors.blue.r}, ${colors.blue.g}, ${
              colors.blue.b
            }, ${0.4 * edgeOpacity})`;
            const highlightColor = `rgba(${colors.white.r}, ${
              colors.white.g
            }, ${colors.white.b}, ${0.6 * edgeOpacity})`;
            const gradient = ctx.createLinearGradient(
              fromNode.x,
              fromNode.y,
              toNode.x,
              toNode.y
            );

            if (attempt && !attempt.completed) {
              const elapsed = now - attempt.startTime;
              const progress = Math.min(
                1,
                elapsed / GUARDIAN_FIREWALL_ATTEMPT_DURATION
              );
              const halfSpan = Math.min(0.5, progress * 0.5);
              const innerStart = Math.max(0, 0.5 - halfSpan);
              const innerEnd = Math.min(1, 0.5 + halfSpan);

              gradient.addColorStop(0, guardianColor);
              gradient.addColorStop(innerStart, guardianColor);
              gradient.addColorStop(Math.min(1, innerStart + 0.02), baseColor);
              gradient.addColorStop(Math.max(0, innerEnd - 0.02), baseColor);
              gradient.addColorStop(innerEnd, guardianColor);
              gradient.addColorStop(1, guardianColor);
            } else {
              const pulse = (now * 0.001) % 1;
              const mirrored = (pulse + 0.5) % 1;
              const width = 0.08;
              const stops = [];

              const pushStop = (pos, color) => {
                while (pos < 0) pos += 1;
                while (pos > 1) pos -= 1;
                stops.push({ pos, color });
              };

              const addPulse = (center) => {
                pushStop(center - width * 2, baseColor);
                pushStop(center - width, highlightColor);
                pushStop(center, guardianColor);
                pushStop(center + width, highlightColor);
                pushStop(center + width * 2, baseColor);
              };

              pushStop(0, baseColor);
              pushStop(1, baseColor);
              addPulse(pulse);
              addPulse(mirrored);

              stops.sort((a, b) => a.pos - b.pos);

              let lastPos = -1;
              stops.forEach((stop) => {
                const clampedPos = Math.max(0, Math.min(1, stop.pos));
                if (clampedPos !== lastPos) {
                  gradient.addColorStop(clampedPos, stop.color);
                  lastPos = clampedPos;
                }
              });
            }

            ctx.strokeStyle = gradient;
          } else if (
            toNode.status === "red" ||
            toNode.status === "yellow" ||
            toNode.status === "malware" ||
            toNode.status === "botnet" ||
            toNode.status === "commandControl"
          ) {
            ctx.setLineDash([5, 5]);
            let color;
            if (toNode.status === "malware") {
              color = colors.malware;
              // Scrolling effect for malware (purple) lines
              ctx.lineDashOffset = -(Date.now() * 0.025) % 10;
            } else if (toNode.status === "botnet") {
              color = colors.botnet;
              // Scrolling effect for botnet (red) lines
              ctx.lineDashOffset = -(Date.now() * 0.025) % 10;
            } else if (toNode.status === "commandControl") {
              color = colors.commandControl;
              // Scrolling effect for C&C (dark red) lines
              ctx.lineDashOffset = -(Date.now() * 0.025) % 10;
            } else {
              color = colors.red;
              ctx.lineDashOffset = 0; // No scroll for regular red/yellow lines
            }
            const pulse = 0.6 + animValues.pulse005 * 0.4;
            ctx.strokeStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${
              pulse * edgeOpacity
            })`;
          } else {
            ctx.setLineDash([]);

            // Performance: Use simple color for normal edges at high node counts
            // Only use gradient animation for small networks
            if (nodes.length <= 150) {
              const gradient = ctx.createLinearGradient(
                fromNode.x,
                fromNode.y,
                toNode.x,
                toNode.y
              );
              const baseColor = `rgba(${colors.green.r}, ${colors.green.g}, ${
                colors.green.b
              }, ${0.15 * edgeOpacity})`;
              const highlightColor = `rgba(${colors.green.r}, ${
                colors.green.g
              }, ${colors.green.b}, ${0.85 * edgeOpacity})`;

              const pulseWidth = 0.18;
              const pulseSpacing = 0.35; // Distance between pulses
              const numPulses = 4; // Number of pulses visible on the line

              // Build gradient with multiple pulses
              let stops = [];
              for (let i = 0; i < numPulses; i++) {
                const pulseCenter = (gradientOffset + i * pulseSpacing) % 1;
                stops.push({ pos: pulseCenter - pulseWidth, color: baseColor });
                stops.push({ pos: pulseCenter, color: highlightColor });
                stops.push({ pos: pulseCenter + pulseWidth, color: baseColor });
              }

              // Sort stops and add them to gradient
              stops.sort((a, b) => a.pos - b.pos);

              // Add initial base color
              gradient.addColorStop(0, baseColor);

              stops.forEach((stop) => {
                const clampedPos = Math.max(0, Math.min(1, stop.pos));
                if (clampedPos >= 0 && clampedPos <= 1) {
                  gradient.addColorStop(clampedPos, stop.color);
                }
              });

              // Add final base color
              gradient.addColorStop(1, baseColor);

              ctx.strokeStyle = gradient;
            } else {
              // Simple static color for performance
              ctx.strokeStyle = `rgba(${colors.green.r}, ${colors.green.g}, ${
                colors.green.b
              }, ${0.3 * edgeOpacity})`;
            }
          }

          ctx.beginPath();
          ctx.moveTo(fromNode.x, fromNode.y);
          ctx.lineTo(toNode.x, toNode.y);
          ctx.stroke();

          // Draw flashing X on central-to-target edge during DDOS
          if (ddosAttackOnEdge) {
            // Check if this is the edge from central node to target branch
            const isCentralToTarget =
              (fromNode.parent === null &&
                toNode === ddosAttackOnEdge.attackPath.target) ||
              (toNode.parent === null &&
                fromNode === ddosAttackOnEdge.attackPath.target);

            if (isCentralToTarget) {
              // Calculate midpoint of edge
              const midX = (fromNode.x + toNode.x) / 2;
              const midY = (fromNode.y + toNode.y) / 2;

              // Flashing effect (2 Hz = 500ms period)
              const flashCycle = (now % 500) / 500; // 0 to 1
              const flashAlpha = flashCycle < 0.5 ? 1 : 0.3; // On/off flash

              // Draw stop emoji symbol
              ctx.save();
              ctx.globalAlpha = flashAlpha * edgeOpacity;
              ctx.font = "bold 24px sans-serif";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.fillText("‚õî", midX, midY);
              ctx.restore();
            }
          }
        });
        ctx.setLineDash([]);
        ctx.lineDashOffset = 0;

        // Draw DDOS visual effects
        // Performance: Only iterate C&C nodes with active DDOS (charging or active)
        const activeDDOSNodes = nodes.filter(
          (n) =>
            n.status === "commandControl" &&
            n.state === "alive" &&
            (n.ddosState === "charging" || n.ddosState === "active")
        );

        activeDDOSNodes.forEach((ccNode) => {
          // Charging phase: red lightning between C&C and botnets
          if (
            ccNode.ddosState === "charging" &&
            ccNode.ddosBotnets.length > 0
          ) {
            const chargeProgress =
              (now - ccNode.ddosChargeStart) / (6000 / attackFreqMultiplier);

            ccNode.ddosBotnets.forEach((botnet) => {
              if (botnet.state !== "alive") return;

              // Lightning effect with increasing intensity
              const pulseIntensity = 0.3 + 0.5 * chargeProgress;
              const lightningPulse = animValues.pulse01 * 0.2 + 0.8;
              const alpha = pulseIntensity * lightningPulse;

              ctx.strokeStyle = `rgba(220, 38, 38, ${alpha})`;
              ctx.lineWidth = 2 + chargeProgress * 2;
              ctx.setLineDash([5, 5]);

              // Add zigzag to simulate lightning
              ctx.beginPath();
              const dx = botnet.x - ccNode.x;
              const dy = botnet.y - ccNode.y;
              const steps = 8;
              for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const x = ccNode.x + dx * t + Math.sin(now * 0.02 + i) * 5;
                const y = ccNode.y + dy * t + Math.cos(now * 0.02 + i) * 5;
                if (i === 0) {
                  ctx.moveTo(x, y);
                } else {
                  ctx.lineTo(x, y);
                }
              }
              ctx.stroke();
            });

            ctx.setLineDash([]);
          }

          // Active phase: Draw warning on targeted branch node and affected edges
          if (ccNode.ddosState === "active" && ccNode.ddosTargetBranch) {
            const targetBranch = ccNode.ddosTargetBranch;

            // Pulsing red warning ring on target branch node
            const warningPulse = animValues.pulse008 * 0.3 + 0.7;
            ctx.strokeStyle = `rgba(139, 0, 0, ${warningPulse * 0.8})`;
            ctx.lineWidth = 3;
            const warningRadius =
              targetBranch.radius + 15 + animValues.pulse005 * 5;

            ctx.beginPath();
            ctx.arc(
              targetBranch.x,
              targetBranch.y,
              warningRadius,
              0,
              Math.PI * 2
            );
            ctx.stroke();

            // Static/interference particles around the branch
            for (let i = 0; i < 8; i++) {
              const angle = (now * 0.001 + (i * Math.PI) / 4) % (Math.PI * 2);
              const distance = warningRadius + 10;
              const px = targetBranch.x + Math.cos(angle) * distance;
              const py = targetBranch.y + Math.sin(angle) * distance;

              ctx.fillStyle = `rgba(220, 38, 38, ${Math.random() * 0.6})`;
              ctx.fillRect(px - 1, py - 1, 2, 2);
            }
            // Draw pulsing red glow on participating botnet nodes
            if (ccNode.ddosBotnets && ccNode.ddosBotnets.length > 0) {
              ccNode.ddosBotnets.forEach((botnet) => {
                if (botnet.state !== "alive") return;

                const botnetPulse = animValues.pulse01 * 0.3 + 0.5;
                ctx.strokeStyle = `rgba(220, 38, 38, ${botnetPulse * 0.6})`;
                ctx.lineWidth = 2;
                const glowRadius = botnet.radius + 8 + animValues.pulse008 * 3;

                ctx.beginPath();
                ctx.arc(botnet.x, botnet.y, glowRadius, 0, Math.PI * 2);
                ctx.stroke();
              });
            }
          }
        });

        manageDataPackets();
        manageImmunityPackets();
        managePingOfDeath();
        managePhishPackets();
        manageDDOSAttacks();
        manageCounterStrikes();
        guardianThreatHunting();
        manageDispatchPackets();
        manageParticles();

        nodes.forEach((node) => {
          node.update();

          // Don't draw drifting satellites - they're being cleaned up
          if (node.state === "drifting" && node.isSatellite) {
            return; // Skip drawing entirely
          }

          // Performance: Viewport culling - skip drawing off-screen nodes (except central node)
          if (
            node.parent === null ||
            isInViewport(node.x, node.y, node.radius + 50)
          ) {
            node.draw();
          }
        });

        // Redraw the central node to ensure it's on top of all other elements
        const rootNode = nodes[0];
        if (rootNode) {
          rootNode.draw();

          // Draw immunity packets attached to central node on top of its glow
          immunityPackets.forEach((packet) => {
            const isAttachedToCentral =
              packet.isAttached &&
              packet.attachedNode &&
              packet.attachedNode.parent === null;
            if (isAttachedToCentral && packet.active) {
              packet.draw();
            }
          });
        }

        const nodesToRemove = nodes.filter(
          (node) => node.opacity <= 0 && node.state !== "spawning"
        );
        if (nodesToRemove.length > 0) {
          if (nodesToRemove.some((n) => n.parent === nodes[0])) {
            nodes[0].pulseEffect = 1;
          }

          nodesToRemove.forEach((node) => {
            if (node.parent) {
              node.parent.children = node.parent.children.filter(
                (child) => child.id !== node.id
              );
            }
          });

          // Count packets on removed branches as received (natural decay)
          const removedNodeIds = new Set(nodesToRemove.map((n) => n.id));
          dataPackets.forEach((packet) => {
            if (
              packet.active &&
              packet.edge &&
              (removedNodeIds.has(packet.edge.from?.id) ||
                removedNodeIds.has(packet.edge.to?.id))
            ) {
              incrementStat("packetsReceived");
            }
          });

          nodes = nodes.filter((node) => !nodesToRemove.includes(node));
          const nodeIds = new Set(nodes.map((n) => n.id));
          edges = edges.filter(
            (edge) => nodeIds.has(edge.from.id) && nodeIds.has(edge.to.id)
          );
        }

        // Update stats display
        updateStatsDisplay();

        // Draw particles (pops, explosions)
        manageParticles();

        // Restore Camera Transform
        ctx.restore();

        // Draw HUD/UI elements (on top of everything, unaffected by zoom)
        // (If there were any canvas-drawn UI elements, they would go here)

        requestAnimationFrame(animate);
      }

      // NEW: Dynamic Camera Logic
      function updateCamera() {
        if (nodes.length === 0) return;

        const cx = canvas.width / 2;
        const cy = canvas.height / 2;

        // Calculate network bounds
        let maxNetworkDistSq = 0;
        let maxTotalDistSq = 0;

        for (const node of nodes) {
          if (node.state !== "alive") continue;

          const dx = node.x - cx;
          const dy = node.y - cy;
          const distSq = dx * dx + dy * dy;

          // Track total bounds (including satellites) for camera zoom
          if (distSq > maxTotalDistSq) maxTotalDistSq = distSq;

          // Track network bounds (excluding satellites) for orbit calculations
          if (!node.isSatellite) {
            if (distSq > maxNetworkDistSq) maxNetworkDistSq = distSq;
          }
        }

        const maxNetworkDist = Math.sqrt(maxNetworkDistSq);
        const maxTotalDist = Math.sqrt(maxTotalDistSq);

        // Update global state for satellites to use
        viewState.maxNetworkRadius = maxNetworkDist;

        // Determine target scale
        let targetScale = 1.0;

        if (viewState.isAutoZoom) {
          // AUTO ZOOM: Fit main network to screen
          // We want the furthest NON-SATELLITE node to be at most 85% of the way to the edge
          const panelOffset = viewState.isSidePanelOpen
            ? viewState.sidePanelWidth
            : 0;
          const effectiveWidth = canvas.width - panelOffset;
          const minDimension = Math.min(effectiveWidth, canvas.height) / 2;
          const fitRadius = minDimension * 0.85;

          if (maxNetworkDist > 0) {
            targetScale = fitRadius / maxNetworkDist;
          }

          // Clamp scale
          targetScale = Math.max(
            viewState.minScale,
            Math.min(viewState.maxScale, targetScale)
          );

          // Update slider to reflect auto value (visual feedback only)
          const zoomSlider = document.getElementById("zoomSlider");
          const zoomValue = document.getElementById("zoomValue");
          if (zoomSlider && zoomValue) {
            zoomSlider.value = viewState.scale.toFixed(2);
            zoomValue.textContent = viewState.scale.toFixed(1) + "x";
          }
        } else {
          // MANUAL ZOOM: Use slider value
          const zoomSlider = document.getElementById("zoomSlider");
          if (zoomSlider) {
            targetScale = parseFloat(zoomSlider.value);
          }
        }

        // Smoothly interpolate
        viewState.targetScale = targetScale;
        viewState.scale += (viewState.targetScale - viewState.scale) * 0.05;
      }

      window.addEventListener("resize", () => {
        resizeCanvas();
        initializeGalaxy();
        createGraph();
      });

      resizeCanvas();
      initializeGalaxy();
      createGraph();
      animate();
      initializeToolButtons();
      initializeStatsPaneToggle();
      initializeTabs();
      initializeTabs();
      initializeSliders();
      initializeZoomControls();
      TickerSystem.init();

      // Initialize Zoom Controls
      function initializeZoomControls() {
        const zoomSlider = document.getElementById("zoomSlider");
        const autoZoomCheckbox = document.getElementById("autoZoomCheckbox");
        const zoomValue = document.getElementById("zoomValue");

        if (zoomSlider) {
          zoomSlider.addEventListener("input", function () {
            // User interaction disables auto-zoom
            viewState.isAutoZoom = false;
            if (autoZoomCheckbox) autoZoomCheckbox.checked = false;

            // Update value display
            if (zoomValue)
              zoomValue.textContent = parseFloat(this.value).toFixed(1) + "x";

            // Apply zoom immediately
            viewState.targetScale = parseFloat(this.value);
          });
        }

        if (autoZoomCheckbox) {
          autoZoomCheckbox.addEventListener("change", function () {
            viewState.isAutoZoom = this.checked;
            if (this.checked) {
              // If re-enabling auto-zoom, let the updateCamera loop handle the smooth transition
              // But we can update the slider visual immediately to show we're handing over control
            }
          });
        }
      }

      // Simulation tick intervals (multipliers affect behavior within functions)
      setInterval(simulateNetworkEvents, 500);
      setInterval(updateNetworkTopology, 500);
    </script>
  </body>
</html>
