<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IT Infrastructure Network Animation</title>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            background-color: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100vh;
        }
        
        /* Stats Pane Styling */
        #statsPane {
            position: fixed;
            top: 0;
            right: 0;
            width: 320px;
            height: 100vh;
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.95) 0%, rgba(30, 41, 59, 0.95) 100%);
            border-left: 2px solid rgba(59, 130, 246, 0.3);
            box-shadow: -4px 0 20px rgba(0, 0, 0, 0.5);
            color: #e2e8f0;
            overflow-y: auto;
            z-index: 1000;
            backdrop-filter: blur(10px);
            font-family: 'Consolas', 'Courier New', 'Monaco', 'Lucida Console', monospace;
            transform: translateX(0);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        #statsPane.collapsed {
            transform: translateX(100%);
        }
        
        #statsPaneToggle {
            position: fixed;
            top: 50%;
            right: 320px;
            transform: translateY(-50%);
            width: 32px;
            height: 80px;
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.95) 0%, rgba(30, 41, 59, 0.95) 100%);
            border: 2px solid rgba(59, 130, 246, 0.3);
            border-right: none;
            border-radius: 8px 0 0 8px;
            cursor: pointer;
            z-index: 999;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #60a5fa;
            font-size: 18px;
            backdrop-filter: blur(10px);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: -4px 0 20px rgba(0, 0, 0, 0.3);
        }
        
        #statsPaneToggle:hover {
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.95) 0%, rgba(51, 65, 85, 0.95) 100%);
            color: #93c5fd;
            box-shadow: -4px 0 20px rgba(59, 130, 246, 0.4);
        }
        
        #statsPane.collapsed ~ #statsPaneToggle {
            right: 0;
            border-right: 2px solid rgba(59, 130, 246, 0.3);
            border-radius: 8px 0 0 8px;
        }
        
        #statsPane::-webkit-scrollbar {
            width: 8px;
        }
        
        #statsPane::-webkit-scrollbar-track {
            background: rgba(15, 23, 42, 0.3);
        }
        
        #statsPane::-webkit-scrollbar-thumb {
            background: rgba(59, 130, 246, 0.5);
            border-radius: 4px;
        }
        
        #statsPane::-webkit-scrollbar-thumb:hover {
            background: rgba(59, 130, 246, 0.7);
        }
        
        .stats-header {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.2) 0%, rgba(147, 51, 234, 0.2) 100%);
            border-bottom: 2px solid rgba(59, 130, 246, 0.4);
            padding: 20px 20px 0 20px;
        }
        
        .stats-title {
            margin: 0 0 16px 0;
            font-size: 20px;
            font-weight: 700;
            color: #60a5fa;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        /* Tab Navigation */
        .tab-navigation {
            display: flex;
            gap: 4px;
            margin-bottom: 0;
        }
        
        .tab-btn {
            flex: 1;
            padding: 10px 16px;
            background: rgba(15, 23, 42, 0.5);
            border: none;
            border-top: 2px solid transparent;
            border-bottom: 2px solid rgba(71, 85, 105, 0.3);
            color: #94a3b8;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .tab-btn:hover {
            background: rgba(30, 41, 59, 0.7);
            color: #cbd5e1;
        }
        
        .tab-btn.active {
            background: rgba(59, 130, 246, 0.15);
            border-top-color: #60a5fa;
            border-bottom-color: transparent;
            color: #60a5fa;
        }
        
        .tab-content {
            display: none;
            animation: fadeIn 0.3s ease;
        }
        
        .tab-content.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .stats-section {
            padding: 16px 20px;
            border-bottom: 1px solid rgba(71, 85, 105, 0.3);
        }
        
        .stats-section-title {
            font-size: 14px;
            font-weight: 600;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin: 0 0 12px 0;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            font-size: 13px;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }
        
        .stat-label {
            color: #cbd5e1;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .stat-value {
            font-weight: 600;
            font-size: 14px;
            min-width: 50px;
            text-align: right;
        }
        
        /* Color coding for different stat types */
        .stat-green { color: #16a34a; text-shadow: 0 0 8px rgba(22, 163, 74, 0.4); }
        .stat-red { color: #f87171; text-shadow: 0 0 8px rgba(248, 113, 113, 0.4); }
        .stat-yellow { color: #facc15; text-shadow: 0 0 8px rgba(250, 204, 21, 0.4); }
        .stat-purple { color: #a855f7; text-shadow: 0 0 8px rgba(168, 85, 247, 0.4); }
        .stat-blue { color: #3b82f6; text-shadow: 0 0 8px rgba(59, 130, 246, 0.4); }
        .stat-sky { color: #60a5fa; text-shadow: 0 0 8px rgba(96, 165, 250, 0.4); }
        .stat-darkred { color: #dc2626; text-shadow: 0 0 8px rgba(220, 38, 38, 0.4); }
        .stat-neongreen { color: #39ff14; text-shadow: 0 0 8px rgba(57, 255, 20, 0.4); }
        .stat-white { color: #ffffff; text-shadow: 0 0 8px rgba(255, 255, 255, 0.4); }
        .stat-gold { color: #fbbf24; text-shadow: 0 0 8px rgba(251, 191, 36, 0.4); }
        
        /* Event Logs Section */
        #eventLogs {
            min-height: 50vh;
            padding: 16px 20px;
            font-size: 12px;
            color: #94a3b8;
        }
        
        #eventLogs .logs-title {
            font-size: 14px;
            font-weight: 600;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin: 0 0 12px 0;
        }
        
        .log-section {
            margin-bottom: 16px;
        }
        
        .log-section-header {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
            padding: 4px 8px;
            border-radius: 3px;
            display: inline-block;
        }
        
        .log-section-header.critical { background: rgba(220, 38, 38, 0.2); color: #fca5a5; }
        .log-section-header.attack { background: rgba(239, 68, 68, 0.2); color: #fca5a5; }
        .log-section-header.defense { background: rgba(139, 92, 246, 0.2); color: #c4b5fd; }
        .log-section-header.success { background: rgba(16, 185, 129, 0.2); color: #6ee7b7; }
        .log-section-header.warning { background: rgba(245, 158, 11, 0.2); color: #fcd34d; }
        .log-section-header.info { background: rgba(59, 130, 246, 0.2); color: #93c5fd; }
        
        .log-entries-container {
            max-height: 200px;
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        .log-entries-container::-webkit-scrollbar {
            width: 4px;
        }
        
        .log-entries-container::-webkit-scrollbar-track {
            background: rgba(15, 23, 42, 0.3);
        }
        
        .log-entries-container::-webkit-scrollbar-thumb {
            background: rgba(59, 130, 246, 0.3);
            border-radius: 2px;
        }
        
        .log-entry {
            padding: 6px 8px;
            margin: 3px 0;
            background: rgba(15, 23, 42, 0.5);
            border-left: 3px solid;
            border-radius: 3px;
            font-size: 10px;
            line-height: 1.4;
            animation: slideIn 0.4s ease-out;
            opacity: 0.9;
            word-wrap: break-word;
        }
        
        .log-entry:hover {
            opacity: 1;
            background: rgba(15, 23, 42, 0.7);
        }
        
        @keyframes slideIn {
            from {
                transform: translateY(-10px);
                opacity: 0;
                max-height: 0;
            }
            to {
                transform: translateY(0);
                opacity: 0.9;
                max-height: 100px;
            }
        }
        
        .log-timestamp {
            color: #64748b;
            font-size: 10px;
            margin-right: 8px;
        }
        
        .log-critical { border-left-color: #dc2626; }
        .log-warning { border-left-color: #f59e0b; }
        .log-success { border-left-color: #10b981; }
        .log-info { border-left-color: #3b82f6; }
        .log-defense { border-left-color: #8b5cf6; }
        .log-attack { border-left-color: #ef4444; }
        
        /* Interactive Control Panel */
        #controlPanel {
            padding: 16px 20px;
        }
        
        .control-panel-title {
            font-size: 13px;
            font-weight: 600;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin: 0 0 12px 0;
        }
        
        .tool-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .tool-btn {
            flex: 1;
            min-width: 50px;
            padding: 10px 8px;
            background: rgba(30, 41, 59, 0.8);
            border: 2px solid rgba(71, 85, 105, 0.5);
            border-radius: 6px;
            color: #cbd5e1;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }
        
        .tool-btn:hover {
            background: rgba(51, 65, 85, 0.9);
            border-color: rgba(59, 130, 246, 0.6);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }
        
        .tool-btn.active {
            background: rgba(59, 130, 246, 0.2);
            border-color: #3b82f6;
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.5), inset 0 0 20px rgba(59, 130, 246, 0.2);
            color: #60a5fa;
        }
        
        .tool-btn-label {
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            opacity: 0.8;
        }
        
        /* Simulation Controls */
        .sim-controls {
            margin-top: 24px;
            padding: 24px 20px 0 20px;
            border-top: 2px solid rgba(59, 130, 246, 0.2);
        }
        
        .slider-control {
            margin-bottom: 20px;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 12px;
            color: #94a3b8;
        }
        
        .slider-name {
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .slider-value {
            color: #60a5fa;
            font-weight: 700;
            font-size: 13px;
            min-width: 50px;
            text-align: right;
        }
        
        .slider {
            -webkit-appearance: none;
            appearance: none;
            width: 92%;
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(to right, rgba(59, 130, 246, 0.3), rgba(59, 130, 246, 0.6));
            outline: none;
            transition: opacity 0.2s;
        }
        
        .slider:hover {
            opacity: 1;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, #3b82f6 0%, #60a5fa 100%);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.5);
            transition: all 0.2s ease;
        }
        
        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.8);
        }
        
        .slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, #3b82f6 0%, #60a5fa 100%);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.5);
            transition: all 0.2s ease;
        }
        
        .slider::-moz-range-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.8);
        }
        
        .reset-btn {
            width: 100%;
            padding: 10px 16px;
            margin-top: 16px;
            background: rgba(30, 41, 59, 0.8);
            border: 2px solid rgba(71, 85, 105, 0.5);
            border-radius: 6px;
            color: #cbd5e1;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .reset-btn:hover {
            background: rgba(51, 65, 85, 0.9);
            border-color: rgba(59, 130, 246, 0.6);
            color: #60a5fa;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }
        
        .reset-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 6px rgba(59, 130, 246, 0.4);
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body>
    <canvas id="networkCanvas"></canvas>
    
    <!-- Stats Pane -->
    <div id="statsPane">
        <div class="stats-header">
            <h1 class="stats-title">üìä NodeNet NOC</h1>
            <div class="tab-navigation">
                <button class="tab-btn active" data-tab="stats">üìä Stats</button>
                <button class="tab-btn" data-tab="logs">üìã Logs</button>
                <button class="tab-btn" data-tab="tools">üõ†Ô∏è Tools</button>
            </div>
        </div>
        
        <!-- Stats Tab Content -->
        <div id="tab-stats" class="tab-content active">
        <!-- Node Counts -->
        <div class="stats-section">
            <h3 class="stats-section-title">üñ•Ô∏è Node Status</h3>
            <div class="stat-item">
                <span class="stat-label">Total Nodes</span>
                <span class="stat-value stat-blue" id="stat-totalNodes">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">‚úÖ Healthy</span>
                <span class="stat-value stat-green" id="stat-healthyNodes">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">‚ö†Ô∏è Warning/Down</span>
                <span class="stat-value stat-red" id="stat-downNodes">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">‚ò£Ô∏è Malware</span>
                <span class="stat-value stat-purple" id="stat-malwareNodes">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">ü§ñ Botnet</span>
                <span class="stat-value stat-darkred" id="stat-botnetNodes">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">‚ò†Ô∏è Command & Control</span>
                <span class="stat-value stat-darkred" id="stat-ccNodes">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">üåü Guardian</span>
                <span class="stat-value stat-sky" id="stat-guardianNodes">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">üõ°Ô∏è Firewall</span>
                <span class="stat-value stat-neongreen" id="stat-firewallNodes">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">üì° Ground Stations</span>
                <span class="stat-value stat-sky" id="stat-groundStations">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">üõ∞Ô∏è Satellites</span>
                <span class="stat-value stat-sky" id="stat-satellites">0</span>
            </div>
        </div>
        
        <!-- Attack/Defense Statistics -->
        <div class="stats-section">
            <h3 class="stats-section-title">‚öîÔ∏è Combat Statistics</h3>
            <div class="stat-item">
                <span class="stat-label">‚öîÔ∏è Total Attacks</span>
                <span class="stat-value stat-red" id="stat-totalAttacks">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">üõ°Ô∏è Total Defenses</span>
                <span class="stat-value stat-green" id="stat-totalDefenses">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">‚ò£Ô∏è Total Infections</span>
                <span class="stat-value stat-purple" id="stat-totalInfections">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">‚ú® Total Recoveries</span>
                <span class="stat-value stat-green" id="stat-totalRecoveries">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">üíÄ Ping Deaths</span>
                <span class="stat-value stat-darkred" id="stat-pingDeaths">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">üé£ Phish Success</span>
                <span class="stat-value stat-yellow" id="stat-phishSuccess">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">üö® Total DDOS Attacks</span>
                <span class="stat-value stat-darkred" id="stat-totalDDOSAttacks">0</span>
            </div>
        </div>
        
        <!-- Packet Counts -->
        <div class="stats-section">
            <h3 class="stats-section-title">üì¶ Packet Counts</h3>
            <div class="stat-item">
                <span class="stat-label">üìä Data Packets</span>
                <span class="stat-value stat-blue" id="stat-dataPackets">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">üéõÔ∏è Control Packets</span>
                <span class="stat-value stat-green" id="stat-controlPackets">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">üîí Security Packets</span>
                <span class="stat-value stat-gold" id="stat-securityPackets">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">üõ°Ô∏è Immunity Packets</span>
                <span class="stat-value stat-white" id="stat-immunityPackets">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">üíÄ Ping of Death</span>
                <span class="stat-value stat-darkred" id="stat-pingPackets">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">üé£ Phishing Packets</span>
                <span class="stat-value stat-yellow" id="stat-phishPackets">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">üöÄ Dispatch Packets</span>
                <span class="stat-value stat-gold" id="stat-dispatchPackets">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">‚úÖ Packets Received</span>
                <span class="stat-value stat-green" id="stat-packetsReceived">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">‚ùå Packets Dropped</span>
                <span class="stat-value stat-red" id="stat-packetsDropped">0</span>
            </div>
        </div>
        </div>
        
        <!-- Logs Tab Content -->
        <div id="tab-logs" class="tab-content">
        <!-- Event Logs Section -->
        <div id="eventLogs">
            <h3 class="logs-title">üìã Event Logs</h3>
            
            <div class="log-section" id="log-section-critical" style="display:none;">
                <div class="log-section-header critical">üö® Critical</div>
                <div class="log-entries-container" id="logs-critical"></div>
            </div>
            
            <div class="log-section" id="log-section-attack" style="display:none;">
                <div class="log-section-header attack">‚öîÔ∏è Attacks</div>
                <div class="log-entries-container" id="logs-attack"></div>
            </div>
            
            <div class="log-section" id="log-section-defense" style="display:none;">
                <div class="log-section-header defense">üõ°Ô∏è Defense</div>
                <div class="log-entries-container" id="logs-defense"></div>
            </div>
            
            <div class="log-section" id="log-section-success" style="display:none;">
                <div class="log-section-header success">‚úÖ Success</div>
                <div class="log-entries-container" id="logs-success"></div>
            </div>
            
            <div class="log-section" id="log-section-warning" style="display:none;">
                <div class="log-section-header warning">‚ö†Ô∏è Warnings</div>
                <div class="log-entries-container" id="logs-warning"></div>
            </div>
            
            <div class="log-section" id="log-section-info" style="display:none;">
                <div class="log-section-header info">‚ÑπÔ∏è Info</div>
                <div class="log-entries-container" id="logs-info"></div>
            </div>
        </div>
        </div>
        
        <!-- Tools Tab Content -->
        <div id="tab-tools" class="tab-content">
        <!-- Interactive Control Panel -->
        <div id="controlPanel">
            <h3 class="control-panel-title">üõ†Ô∏è Interactive Tools</h3>
            <div class="tool-buttons">
                <button class="tool-btn" data-tool="sprout" title="Sprout Node">
                    <span>üå±</span>
                    <span class="tool-btn-label">Sprout</span>
                </button>
                <button class="tool-btn" data-tool="infect" title="Infect Node">
                    <span>‚ò£Ô∏è</span>
                    <span class="tool-btn-label">Infect</span>
                </button>
                <button class="tool-btn" data-tool="cure" title="Cure Node">
                    <span>üíä</span>
                    <span class="tool-btn-label">Cure</span>
                </button>
                <button class="tool-btn" data-tool="harden" title="Harden Node">
                    <span>üõ°Ô∏è</span>
                    <span class="tool-btn-label">Harden</span>
                </button>
                <button class="tool-btn" data-tool="link" title="Link Nodes">
                    <span>üîó</span>
                    <span class="tool-btn-label">Link</span>
                </button>
            </div>
        </div>
        
        <!-- Simulation Controls -->
        <div class="sim-controls">
            <h2 class="control-panel-title">‚öôÔ∏è Simulation Controls</h2>
            
            <div class="slider-control">
                <div class="slider-label">
                    <span class="slider-name">Simulation Speed</span>
                    <span class="slider-value" id="simSpeed-value">1.0x</span>
                </div>
                <input type="range" min="10" max="200" value="100" class="slider" id="simSpeed">
            </div>
            
            <div class="slider-control">
                <div class="slider-label">
                    <span class="slider-name">Packet Speed</span>
                    <span class="slider-value" id="packetSpeed-value">1.0x</span>
                </div>
                <input type="range" min="25" max="300" value="100" class="slider" id="packetSpeed">
            </div>
            
            <div class="slider-control">
                <div class="slider-label">
                    <span class="slider-name">Attack Frequency</span>
                    <span class="slider-value" id="attackFreq-value">1.0x</span>
                </div>
                <input type="range" min="10" max="300" value="100" class="slider" id="attackFreq">
            </div>
            
            <div class="slider-control">
                <div class="slider-label">
                    <span class="slider-name">Healing Speed</span>
                    <span class="slider-value" id="healSpeed-value">1.0x</span>
                </div>
                <input type="range" min="25" max="400" value="100" class="slider" id="healSpeed">
            </div>

            <div class="slider-control">
                <div class="slider-label">
                    <span class="slider-name">Central Branches</span>
                    <span class="slider-value" id="branchCount-value">6</span>
                </div>
                <input type="range" min="3" max="12" value="6" class="slider" id="branchCount">
            </div>
            
            <button class="reset-btn" id="resetSliders">üîÑ Reset to Defaults</button>
        </div>
        </div>
    </div>
    
    <!-- Stats Pane Toggle Button -->
    <div id="statsPaneToggle" title="Toggle Stats Panel">
        <span id="toggleIcon">¬ª</span>
    </div>

    <script>
        const canvas = document.getElementById('networkCanvas');
        const ctx = canvas.getContext('2d');

        let nodes = [];
        let edges = [];
        let dispatchPackets = [];
        let pulses = [];
        let particles = []; // To store "pop" particles
        let dataPackets = []; // To store data flow packets
        let immunityPackets = []; // To store white immunity packets
        let pingOfDeathPackets = []; // To store C&C ping of death packets
        let phishPackets = []; // To store C&C phishing packets
        let counterStrikePackets = []; // To store guardian counter-strike packets
        let galaxyStars = [];
        let galaxyNebulae = [];
        let galaxyComets = [];
        let galaxyNovas = [];
        let galaxyCometExplosions = [];
        let centralImpactShake = 0;
        let centralImpactShakePhase = 0;
        let centralImpactShakeOffsetX = 0;
        let centralImpactShakeOffsetY = 0;
        // Bot Defense Mode configuration
        const BOT_DEFENSE_DURATION = 10000; // 10s active
        const BOT_DEFENSE_COOLDOWN = 20000; // 20s cooldown
        const BOT_DEFENSE_BURST_INTERVAL = 4000; // burst every 4s
        let gradientOffset = 0;
        const padding = 40; // Padding from the border
        let lastCrossingCheck = 0; // Throttles the line crossing check
        // Galaxy background state (populated on startup and resize)
        const GALAXY_STAR_COUNT = 480;
        const GALAXY_NEBULA_COUNT = 5;
        const GALAXY_COMET_CAP = 2;
        let lastBackgroundTime = Date.now();
        let lastNovaSpawn = 0;
        
        // Simulation speed multipliers (controlled by sliders)
        let simSpeedMultiplier = 1.0;
        let packetSpeedMultiplier = 1.0;
        let attackFreqMultiplier = 1.0;
        let healSpeedMultiplier = 1.0;
        const DEFAULT_BRANCH_COUNT = 6;
        let desiredBranchCount = DEFAULT_BRANCH_COUNT;

        // Statistics tracking object
        const stats = {
            // Packet counts (cumulative)
            totalDataPackets: 0,
            totalControlPackets: 0,
            totalSecurityPackets: 0,
            totalImmunityPackets: 0,
            totalPingPackets: 0,
            totalPhishPackets: 0,
            totalDispatchPackets: 0,
            // Packet delivery stats
            packetsReceived: 0,
            packetsDropped: 0,
            // Combat stats
            totalAttacks: 0,
            totalDefenses: 0,
            totalInfections: 0,
            totalRecoveries: 0,
            pingDeaths: 0,
            phishSuccess: 0,
            // DDOS stats
            totalDDOSAttacks: 0,
            activeDDOSAttacks: 0
        };

        // Stats increment functions
        function incrementStat(statName) {
            if (stats.hasOwnProperty(statName)) {
                stats[statName]++;
            }
        }

        // Format large numbers for display
        function formatStatNumber(value) {
            if (value > 999999) {
                return (value / 1000000).toFixed(2) + 'M';
            }
            return value.toLocaleString();
        }

        // Sort stat items within a section by their values (highest first)
        function sortStatsInSection(sectionElement, pinFirstItem = false) {
            const statItems = Array.from(sectionElement.querySelectorAll('.stat-item'));
            if (statItems.length === 0) return;
            
            // Get items to sort (exclude first if pinned)
            const itemsToSort = pinFirstItem ? statItems.slice(1) : statItems;
            const pinnedItem = pinFirstItem ? statItems[0] : null;
            
            // Extract values and sort
            const itemsWithValues = itemsToSort.map(item => {
                const valueElement = item.querySelector('.stat-value');
                const valueText = valueElement.textContent;
                
                // Parse value (handle 'M' suffix for millions)
                let numericValue = 0;
                if (valueText.includes('M')) {
                    numericValue = parseFloat(valueText.replace('M', '')) * 1000000;
                } else {
                    numericValue = parseFloat(valueText.replace(/,/g, '')) || 0;
                }
                
                return { element: item, value: numericValue };
            });
            
            // Sort by value descending
            itemsWithValues.sort((a, b) => b.value - a.value);
            
            // Reorder DOM elements smoothly
            const fragment = document.createDocumentFragment();
            if (pinnedItem) {
                fragment.appendChild(pinnedItem);
            }
            itemsWithValues.forEach(item => {
                fragment.appendChild(item.element);
            });
            
            // Clear and re-append in sorted order
            sectionElement.querySelectorAll('.stat-item').forEach(item => item.remove());
            sectionElement.appendChild(fragment);
        }

        // Update stats display in HUD
        function updateStatsDisplay() {
            // Packet counts (cumulative totals with formatting)
            document.getElementById('stat-dataPackets').textContent = formatStatNumber(stats.totalDataPackets);
            document.getElementById('stat-controlPackets').textContent = formatStatNumber(stats.totalControlPackets);
            document.getElementById('stat-securityPackets').textContent = formatStatNumber(stats.totalSecurityPackets);
            document.getElementById('stat-immunityPackets').textContent = formatStatNumber(stats.totalImmunityPackets);
            document.getElementById('stat-pingPackets').textContent = formatStatNumber(stats.totalPingPackets);
            document.getElementById('stat-phishPackets').textContent = formatStatNumber(stats.totalPhishPackets);
            document.getElementById('stat-dispatchPackets').textContent = formatStatNumber(stats.totalDispatchPackets);
            document.getElementById('stat-packetsReceived').textContent = formatStatNumber(stats.packetsReceived);
            document.getElementById('stat-packetsDropped').textContent = formatStatNumber(stats.packetsDropped);
            
            // Node counts (filter by status and type)
            const aliveNodes = nodes.filter(n => n.state === 'alive');
            const totalNodes = aliveNodes.length;
            const healthyNodes = aliveNodes.filter(n => n.status === 'green' || n.status === 'blue').length;
            const downNodes = aliveNodes.filter(n => n.status === 'red' || n.status === 'yellow').length;
            const malwareNodes = aliveNodes.filter(n => n.status === 'malware').length;
            const botnetNodes = aliveNodes.filter(n => n.status === 'botnet').length;
            const ccNodes = aliveNodes.filter(n => n.status === 'commandControl').length;
            const guardianNodes = aliveNodes.filter(n => n.isGuardian).length;
            const firewallNodes = aliveNodes.filter(n => n.hasFirewall).length;
            const groundStations = aliveNodes.filter(n => n.isGroundStation).length;
            const satellites = aliveNodes.filter(n => n.isSatellite).length;
            
            document.getElementById('stat-totalNodes').textContent = totalNodes;
            document.getElementById('stat-healthyNodes').textContent = healthyNodes;
            document.getElementById('stat-downNodes').textContent = downNodes;
            document.getElementById('stat-malwareNodes').textContent = malwareNodes;
            document.getElementById('stat-botnetNodes').textContent = botnetNodes;
            document.getElementById('stat-ccNodes').textContent = ccNodes;
            document.getElementById('stat-guardianNodes').textContent = guardianNodes;
            document.getElementById('stat-firewallNodes').textContent = firewallNodes;
            document.getElementById('stat-groundStations').textContent = groundStations;
            document.getElementById('stat-satellites').textContent = satellites;
            
            // Combat statistics (cumulative)
            document.getElementById('stat-totalAttacks').textContent = stats.totalAttacks;
            document.getElementById('stat-totalDefenses').textContent = stats.totalDefenses;
            document.getElementById('stat-totalInfections').textContent = stats.totalInfections;
            document.getElementById('stat-totalRecoveries').textContent = stats.totalRecoveries;
            document.getElementById('stat-pingDeaths').textContent = stats.pingDeaths;
            document.getElementById('stat-phishSuccess').textContent = stats.phishSuccess;
            
            // DDOS statistics
            document.getElementById('stat-totalDDOSAttacks').textContent = stats.totalDDOSAttacks;
            // Count active DDOS attacks in real-time (kept for future alert system)
            const activeDDOS = nodes.filter(n => n.status === 'commandControl' && n.ddosState === 'active').length;
            stats.activeDDOSAttacks = activeDDOS;
            
            // Sort stats within each section (but keep Total Nodes at top of Node Status)
            const sections = document.querySelectorAll('.stats-section');
            sections.forEach((section, index) => {
                const sectionTitle = section.querySelector('.stats-section-title');
                if (sectionTitle) {
                    const title = sectionTitle.textContent;
                    if (title.includes('Node Status')) {
                        // Keep "Total Nodes" pinned at the top
                        sortStatsInSection(section, true);
                    } else if (title.includes('Combat Statistics') || title.includes('Packet Counts')) {
                        // Sort all items in these sections
                        sortStatsInSection(section, false);
                    }
                }
            });
        }

        const colors = {
            green: { r: 22, g: 163, b: 74 },
            red: { r: 248, g: 113, b: 113 },
            yellow: { r: 250, g: 204, b: 21 },
            malware: { r: 168, g: 85, b: 247 }, // purple-500
            botnet: { r: 220, g: 38, b: 38 }, // red-600 for botnet
            commandControl: { r: 139, g: 0, b: 0 }, // dark red for C&C nodes
            blue: { r: 59, g: 130, b: 246 },    // blue-500 for the central node
            gold: { r: 251, g: 191, b: 36 },    // amber-400 for pulses
            groundStation: { r: 96, g: 165, b: 250 }, // sky-400 for ground station towers
            satellite: { r: 147, g: 197, b: 253 }, // lighter sky blue for satellites
            line: { r: 209, g: 213, b: 219 }, // Light Gray (gray-300)
            white: { r: 255, g: 255, b: 255 }, // white for immunity packets
            neonGreen: { r: 57, g: 255, b: 20 }, // neon green for firewall nodes
        };

        const LOG_MESSAGES = {
            recoveryShieldExpired: ({ node }) => `üõ°Ô∏è Recovery shield expired on ${node?.parent === null ? 'the central node' : `node ${node?.id ?? '?'}`} after 15 seconds.`,
            recoveryShieldActivated: ({ node }) => `üõ°Ô∏è Recovery shield activated on ${node?.parent === null ? 'the central node' : `node ${node?.id ?? '?'}`}! Duration: 15s, Resistance: 99%.`,
            recoveryShieldAttack: ({ target }) => `‚öîÔ∏è Attack on ${target?.parent === null ? 'the central node' : `node ${target?.id ?? '?'}`} while the recovery shield was active! Resistance: 99%.`,
            firewallBlockedPing: ({ firewallNode }) => `üõ°Ô∏è Node ${firewallNode?.id ?? '?'} blocked a Ping of Death!`,
            phishingSuccess: ({ target }) => `üé£ Phishing attack successful on node ${target?.id ?? '?'}.`,
            centralCompromised: ({ node }) => `üö® CRITICAL ALERT: CENTRAL NODE ${node?.id ?? '?'} COMPROMISED!`,
            firewallGained: ({ node }) => `üõ°Ô∏è Node ${node?.id ?? '?'} gained firewall capability during recovery!`,
            commandControlDetected: ({ node, clusterSize }) => `‚ò†Ô∏è A C&C Server has been detected at node ${node?.id ?? '?'} (cluster size: ${clusterSize ?? '?'}).`,
            ccMeshBridged: ({ node, count }) => `üï∏Ô∏è C&C node ${node?.id ?? '?'} bridged to ${count} botnet node${count === 1 ? '' : 's'} in cluster`,
            botnetBridged: () => 'ü¶æ Botnet clusters bridged - mesh network expanding.',
            centralUnderAttack: () => '‚ö†Ô∏è WARNING: Network core is under attack! Immediate defense required!',
            groundStationEstablished: ({ node }) => `üì° Ground station established on node ${node?.id ?? '?'}.`,
            guardianPromotionDispatch: ({ node }) => `üåü Dispatch packet inspired a new Guardian defender at node ${node?.id ?? '?'}!`,
            guardianPromotionPingRecovery: ({ node }) => `üõ°Ô∏è Resilient node ${node?.id ?? '?'} recovered from Ping of Death and revealed a Guardian!`,
            guardianPromotionPhishing: ({ node }) => `üï∂ A failed phishing attack exposed a Guardian node ${node?.id ?? '?'}!`,
            guardianDemoted: ({ node }) => `üõ°Ô∏è Guardian node ${node?.id ?? '?'} corrupted and reverted to malware.`,
            guardianFirewallSuccess: ({ guardian, target }) => `üõ°Ô∏è Guardian ${guardian?.id ?? '?'} configured a firewall on node ${target?.id ?? '?'}!`,
            commandControlAggressiveAttack: ({ ccNode, target }) => `‚öîÔ∏è C&C node ${ccNode?.id ?? '?'} aggressively attacking connected green node ${target?.id ?? '?'}!`,
            pingOfDeathSent: ({ ccNode, target, targetType, pathLength }) => `üíÄ Ping of Death sent from C&C ${ccNode?.id ?? '?'} to ${targetType ?? 'node'} ${target?.id ?? '?'} (path length: ${pathLength ?? '?'}).`,
            pingOfDeathFailed: ({ ccNode }) => `‚ö†Ô∏è Ping of Death from C&C ${ccNode?.id ?? '?'} failed: no path found to target node.`,
            commandControlPhishBurst: ({ ccNode, burstSize }) => `üé£ C&C node ${ccNode?.id ?? '?'} launched phishing burst (${burstSize} packet${burstSize === 1 ? '' : 's'})!`,
            satelliteChainEstablished: ({ node, count }) => `üõ∞Ô∏è Ground station ${node?.id ?? '?'} deployed ${count ?? 0} satellite${count === 1 ? '' : 's'} in a wireless chain.`,
            satelliteUntethered: ({ node }) => `üõ∞Ô∏è Satellite ${node?.id ?? '?'} lost its ground station tether and is drifting into space.`,
            nodeDefended: ({ node }) => `üõ°Ô∏è Node ${node?.id ?? '?'} successfully defended against an attack.`,
            nodeInfected: ({ node }) => `‚ò£Ô∏è Node ${node?.id ?? '?'} succumbed to infection.`,
            statusDown: ({ node, previousStatus, isGroundStation }) => `${isGroundStation ? 'üü• Ground station' : 'üü• Node'} ${node?.id ?? '?'} went DOWN (from ${previousStatus ?? 'unknown'}).`,
            statusMalware: ({ node, previousStatus, isGroundStation }) => `${isGroundStation ? '‚ò£Ô∏è Ground station' : '‚ò£Ô∏è Node'} ${node?.id ?? '?'} became infected (from ${previousStatus ?? 'unknown'}).`,
            statusBotnet: ({ node, previousStatus }) => `ü§ñ Node ${node?.id ?? '?'} joined a botnet cluster (from ${previousStatus ?? 'unknown'}).`,
            statusRecovered: ({ node, previousStatus }) => `‚úÖ Node ${node?.id ?? '?'} restored to healthy status (from ${previousStatus ?? 'unknown'}).`,
            statusWarning: ({ node, previousStatus }) => `‚ö†Ô∏è Node ${node?.id ?? '?'} entered warning state (from ${previousStatus ?? 'unknown'}).`,
            statusCommandControl: ({ node, previousStatus }) => `‚ò†Ô∏è Node ${node?.id ?? '?'} elevated to Command & Control (from ${previousStatus ?? 'unknown'}).`,
            statusBlue: ({ node, previousStatus }) => `üåê Central node restored (from ${previousStatus ?? 'unknown'}).`,
            phishingBlocked: ({ node, defender }) => `üõ°Ô∏è ${defender ?? 'Defender'} ${node?.id ?? '?'} blocked a phishing attack!`,
            phishingDefended: ({ node }) => `üõ°Ô∏è Node ${node?.id ?? '?'} successfully defended against phishing.`,
            dispatchBlocked: ({ target }) => `‚ö†Ô∏è Remediation packet to node ${target?.id ?? '?'} was intercepted by infected nodes.`,
            dispatchSuccessful: ({ target }) => `‚ú® Remediation packet reached node ${target?.id ?? '?'} - cleanup initiated.`,
            immunityHealingStarted: ({ node, packetCount }) => `üíä Immunity healing started on node ${node?.id ?? '?'} (${packetCount} packet${packetCount === 1 ? '' : 's'} attached).`,
            immunityHealingCompleted: ({ node }) => `‚úÖ Node ${node?.id ?? '?'} fully healed by immunity packets!`,
            pingOfDeathHit: ({ target, targetType }) => `üíÄ Ping of Death struck ${targetType ?? 'node'} ${target?.id ?? '?'}!`,
            guardianVpnCreated: ({ guardian, target }) => `üîí Guardian ${guardian?.id ?? '?'} established VPN tunnel to node ${target?.id ?? '?'}.`,
            remediationStarted: ({ node }) => `üîÑ Node ${node?.id ?? '?'} beginning remediation process...`,
            immunitySupercharged: ({ packetCount }) => `‚ö° Central node supercharged ${packetCount} immunity packet${packetCount === 1 ? '' : 's'}!`,
            satelliteRespawning: ({ groundStation }) => `üõ∞Ô∏è Ground station ${groundStation?.id ?? '?'} relaunched satellite chain...`,
            ddosCharging: ({ ccNode, botnetCount, targetBranch }) => `‚ö° C&C node ${ccNode?.id ?? '?'} charging DDOS with ${botnetCount} botnet${botnetCount === 1 ? '' : 's'}, targeting branch ${targetBranch?.id ?? '?'}...`,
            ddosLaunched: ({ ccNode, targetBranch, botnetCount }) => `üö® DDOS ATTACK! C&C ${ccNode?.id ?? '?'} and ${botnetCount} botnet${botnetCount === 1 ? '' : 's'} overwhelming branch ${targetBranch?.id ?? '?'}!`,
            ddosEnded: ({ ccNode, targetBranch }) => `‚úÖ DDOS attack from C&C ${ccNode?.id ?? '?'} on branch ${targetBranch?.id ?? '?'} ended - network recovering.`,
            custom: ({ message }) => message ?? ''
        };

        const SATELLITE_CHAIN_MAX_LENGTH = 5;
        const SATELLITE_CHAIN_MIN_LENGTH = 3;
        const SATELLITE_CHAIN_SEGMENT_LENGTH = 85;
        const WIRELESS_SPRING_STRENGTH = 0.0007;
        const WIRELESS_IDEAL_LENGTH = SATELLITE_CHAIN_SEGMENT_LENGTH;
        const SATELLITE_DRIFT_FADE_RATE = 0.02; // Increased from 0.008 for faster cleanup
        const SATELLITE_DRIFT_GRAVITY = 0.0006;
        const SATELLITE_DRIFT_SPEED_MIN = 0.25;
        const SATELLITE_DRIFT_SPEED_MAX = 0.55;
        const SATELLITE_RESPAWN_INTERVAL = 12000;

        // Event log buffers for UI display (separate by type)
        const eventLogBuffers = {
            critical: [],
            attack: [],
            defense: [],
            success: [],
            warning: [],
            info: []
        };
        const MAX_LOG_ENTRIES_PER_TYPE = 10;

        function logEvent(key, context = {}) {
            const template = LOG_MESSAGES[key];
            if (!template) {
                console.warn(`[logEvent] Missing log message for key: ${key}`, context);
                return;
            }

            const message = typeof template === 'function' ? template(context) : template;
            if (message) {
                console.log(message);
                
                // Add to UI event log
                addEventToLog(message, key);
            }
        }
        
        function addEventToLog(message, eventKey) {
            const timestamp = new Date().toLocaleTimeString('en-US', { 
                hour12: false, 
                hour: '2-digit', 
                minute: '2-digit', 
                second: '2-digit' 
            });
            
            // Determine log type based on event key or message content
            let logType = 'info';
            if (eventKey.includes('central') || eventKey.includes('critical') || message.includes('üö®')) {
                logType = 'critical';
            } else if (eventKey.includes('attack') || eventKey.includes('infected') || eventKey.includes('malware') || message.includes('‚öîÔ∏è') || message.includes('‚ò£Ô∏è') || message.includes('üíÄ')) {
                logType = 'attack';
            } else if (eventKey.includes('defend') || eventKey.includes('blocked') || eventKey.includes('shield') || message.includes('üõ°Ô∏è') || message.includes('üåü')) {
                logType = 'defense';
            } else if (eventKey.includes('recovered') || eventKey.includes('healed') || eventKey.includes('success') || message.includes('‚úÖ') || message.includes('‚ú®')) {
                logType = 'success';
            } else if (eventKey.includes('warning') || eventKey.includes('down') || message.includes('‚ö†Ô∏è')) {
                logType = 'warning';
            }
            
            // Add to appropriate buffer
            const buffer = eventLogBuffers[logType];
            if (!buffer) return;
            
            const logEntry = {
                timestamp,
                message,
                type: logType
            };
            
            // Add to start of buffer
            buffer.unshift(logEntry);
            
            // Keep buffer size limited
            if (buffer.length > MAX_LOG_ENTRIES_PER_TYPE) {
                buffer.pop();
            }
            
            // Show the section if hidden
            const section = document.getElementById(`log-section-${logType}`);
            if (section) {
                section.style.display = 'block';
            }
            
            // Add entry to DOM with animation
            addLogEntryToDOM(logEntry);
        }
        
        function addLogEntryToDOM(log) {
            const container = document.getElementById(`logs-${log.type}`);
            if (!container) return;
            
            // Create log entry element
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${log.type}`;
            logEntry.innerHTML = `<span class="log-timestamp">${log.timestamp}</span>${log.message}`;
            
            // Insert at the top
            container.insertBefore(logEntry, container.firstChild);
            
            // Remove excess entries
            while (container.children.length > MAX_LOG_ENTRIES_PER_TYPE) {
                container.removeChild(container.lastChild);
            }
        }

        // Interactive Tools System
        let activeTool = null;
        let linkSourceNode = null; // For linking tool

        // Initialize tool button handlers
        function initializeToolButtons() {
            const toolButtons = document.querySelectorAll('.tool-btn');
            toolButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const tool = btn.dataset.tool;
                    
                    // Toggle tool selection
                    if (activeTool === tool) {
                        activeTool = null;
                        linkSourceNode = null;
                        btn.classList.remove('active');
                    } else {
                        // Deactivate all other tools
                        toolButtons.forEach(b => b.classList.remove('active'));
                        activeTool = tool;
                        linkSourceNode = null;
                        btn.classList.add('active');
                    }
                    
                    // Update cursor style
                    canvas.style.cursor = activeTool ? 'crosshair' : 'default';
                });
            });
        }

        // Stats Pane Toggle
        function initializeStatsPaneToggle() {
            const statsPane = document.getElementById('statsPane');
            const toggleBtn = document.getElementById('statsPaneToggle');
            const toggleIcon = document.getElementById('toggleIcon');
            
            toggleBtn.addEventListener('click', () => {
                statsPane.classList.toggle('collapsed');
                
                // Update toggle icon
                if (statsPane.classList.contains('collapsed')) {
                    toggleIcon.textContent = '¬´'; // Point toward center when collapsed
                } else {
                    toggleIcon.textContent = '¬ª'; // Point toward edge when expanded
                }
            });
        }

        // Tab System
        function initializeTabs() {
            const tabButtons = document.querySelectorAll('.tab-btn');
            const tabContents = document.querySelectorAll('.tab-content');
            
            tabButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const targetTab = btn.dataset.tab;
                    
                    // Remove active class from all buttons and contents
                    tabButtons.forEach(b => b.classList.remove('active'));
                    tabContents.forEach(content => content.classList.remove('active'));
                    
                    // Add active class to clicked button and corresponding content
                    btn.classList.add('active');
                    document.getElementById(`tab-${targetTab}`).classList.add('active');
                });
            });
        }
        
        // Simulation Control Sliders
        function initializeSliders() {
            // Simulation Speed Slider
            const simSpeedSlider = document.getElementById('simSpeed');
            const simSpeedValue = document.getElementById('simSpeed-value');
            simSpeedSlider.addEventListener('input', (e) => {
                simSpeedMultiplier = e.target.value / 100;
                simSpeedValue.textContent = `${simSpeedMultiplier.toFixed(1)}x`;
            });
            
            // Packet Speed Slider
            const packetSpeedSlider = document.getElementById('packetSpeed');
            const packetSpeedValue = document.getElementById('packetSpeed-value');
            packetSpeedSlider.addEventListener('input', (e) => {
                packetSpeedMultiplier = e.target.value / 100;
                packetSpeedValue.textContent = `${packetSpeedMultiplier.toFixed(1)}x`;
            });
            
            // Attack Frequency Slider
            const attackFreqSlider = document.getElementById('attackFreq');
            const attackFreqValue = document.getElementById('attackFreq-value');
            attackFreqSlider.addEventListener('input', (e) => {
                attackFreqMultiplier = e.target.value / 100;
                attackFreqValue.textContent = `${attackFreqMultiplier.toFixed(1)}x`;
            });
            
            // Healing Speed Slider
            const healSpeedSlider = document.getElementById('healSpeed');
            const healSpeedValue = document.getElementById('healSpeed-value');
            healSpeedSlider.addEventListener('input', (e) => {
                healSpeedMultiplier = e.target.value / 100;
                healSpeedValue.textContent = `${healSpeedMultiplier.toFixed(1)}x`;
            });

            // Central Branches Slider
            const branchSlider = document.getElementById('branchCount');
            const branchValue = document.getElementById('branchCount-value');
            if (branchSlider && branchValue) {
                branchSlider.addEventListener('input', (e) => {
                    desiredBranchCount = parseInt(e.target.value, 10);
                    branchValue.textContent = desiredBranchCount;
                });
                branchSlider.value = desiredBranchCount;
                branchValue.textContent = desiredBranchCount;
            }

            // Reset Button
            const resetBtn = document.getElementById('resetSliders');
            resetBtn.addEventListener('click', () => {
                // Reset all sliders to default value (100 = 1.0x)
                simSpeedSlider.value = 100;
                packetSpeedSlider.value = 100;
                attackFreqSlider.value = 100;
                healSpeedSlider.value = 100;
                if (branchSlider) branchSlider.value = DEFAULT_BRANCH_COUNT;

                // Update multipliers
                simSpeedMultiplier = 1.0;
                packetSpeedMultiplier = 1.0;
                attackFreqMultiplier = 1.0;
                healSpeedMultiplier = 1.0;
                desiredBranchCount = DEFAULT_BRANCH_COUNT;

                // Update display values
                simSpeedValue.textContent = '1.0x';
                packetSpeedValue.textContent = '1.0x';
                attackFreqValue.textContent = '1.0x';
                healSpeedValue.textContent = '1.0x';
                if (branchValue) branchValue.textContent = DEFAULT_BRANCH_COUNT;
            });
        }

        // Tool implementations
        function sproutNode(parentNode) {
            if (parentNode.state !== 'alive') return;
            
            // Create a new child node
            const angle = Math.random() * Math.PI * 2;
            const distance = 80 + Math.random() * 40;
            const targetX = parentNode.x + Math.cos(angle) * distance;
            const targetY = parentNode.y + Math.sin(angle) * distance;
            
            const newNode = new Node(Date.now() + Math.random(), targetX, targetY, parentNode);
            parentNode.children.push(newNode);
            nodes.push(newNode);
            edges.push({
                from: parentNode,
                to: newNode,
                natural: true
            });
            
            // Visual feedback
            createPopParticles(newNode.x, newNode.y, colors.green);
            logEvent('custom', { message: `üå± New node ${newNode.id} sprouted from node ${parentNode.id}!` });
        }

        function infectNode(node) {
            if (node.state !== 'alive') return;
            
            const previousStatus = node.status;
            let message = '';
            let particleColor = colors.malware;
            
            // Remove any immunity packets attached to the node
            if (node.attachedImmunityPackets && node.attachedImmunityPackets.length > 0) {
                const packetCount = node.attachedImmunityPackets.length;
                node.attachedImmunityPackets.forEach(packet => {
                    if (packet.active) {
                        packet.active = false;
                        packet.isAttached = false;
                        packet.attachedNode = null;
                        createPopParticles(packet.x, packet.y, colors.red);
                    }
                });
                node.attachedImmunityPackets = [];
                node.isImmunityHealing = false;
                node.immunityHealingStartTime = 0;
                message = `‚ò£Ô∏è Stripped ${packetCount} immunity packet(s) from node ${node.id}! `;
            }
            
            // Escalate infection based on current status
            if (node.status === 'commandControl') {
                // Already at max infection level
                message += `Node ${node.id} is already a Command & Control node!`;
            } else if (node.status === 'botnet') {
                // Escalate to C&C
                node.status = 'commandControl';
                node.statusChangeTime = Date.now();
                message += `Botnet ${node.id} escalated to Command & Control!`;
                particleColor = colors.commandControl;
                incrementStat('totalInfections');
            } else if (node.status === 'malware') {
                // Escalate to botnet
                node.status = 'botnet';
                node.statusChangeTime = Date.now();
                message += `Malware ${node.id} escalated to Botnet!`;
                particleColor = colors.botnet;
                incrementStat('totalInfections');
            } else if (node.status === 'green' || node.status === 'blue' || node.status === 'red' || node.status === 'yellow') {
                // Initial infection
                node.status = 'malware';
                node.statusChangeTime = Date.now();
                message += `Node ${node.id} forcibly infected with malware!`;
                particleColor = colors.malware;
                incrementStat('totalInfections');
            } else {
                return; // Unknown status, do nothing
            }
            
            logEvent('custom', { message });
            
            // Visual feedback
            createPopParticles(node.x, node.y, particleColor);
        }

        function cureNode(node) {
            if (node.state !== 'alive') return;

            const isInfected = node.status === 'malware' || node.status === 'botnet' || node.status === 'commandControl' || node.status === 'red';
            const isHealthy = node.status === 'green';

            if (!isInfected && !isHealthy) return;

            if (isInfected) {
                const previousStatus = node.status;
                node.status = 'green';
                node.statusChangeTime = Date.now();
                node.isImmunityHealing = false;
                node.attachedImmunityPackets = [];
                node.remediationState = 'none';

                logEvent('custom', { message: `üíä Node ${node.id} instantly cured from ${previousStatus}!` });

                // Visual feedback
                createPopParticles(node.x, node.y, colors.green);
                incrementStat('totalRecoveries');
                return;
            }

            // Healthy node reinforcement: grant firewall or promote to guardian if already fortified
            if (!node.hasFirewall) {
                node.hasFirewall = true;
                node.shieldActive = true;
                node.shieldOpacity = Math.min(1, node.shieldOpacity + 0.5);
                logEvent('custom', { message: `üõ°Ô∏è Cure tool reinforced node ${node.id} with a firewall!` });
                createPopParticles(node.x, node.y, colors.blue);
                return;
            }

            if (!node.isGuardian) {
                const promoted = promoteToGuardian(node, null);
                if (promoted) {
                    logEvent('custom', { message: `üï∂ Cure tool elevated node ${node.id} to Guardian status!` });
                } else {
                    logEvent('custom', { message: `‚ÑπÔ∏è Node ${node.id} could not be promoted to Guardian.` });
                }
            } else {
                logEvent('custom', { message: `‚ÑπÔ∏è Node ${node.id} is already a Guardian defender.` });
            }
        }

        function hardenNode(node) {
            if (node.state !== 'alive') return;
            
            if (!node.hasFirewall) {
                node.hasFirewall = true;
                logEvent('custom', { message: `üõ°Ô∏è Firewall activated on node ${node.id}!` });
            } else if (!node.isGuardian) {
                node.isGuardian = true;
                logEvent('custom', { message: `üåü Node ${node.id} promoted to Guardian status!` });
            } else {
                logEvent('custom', { message: `‚ö†Ô∏è Node ${node.id} is already fully hardened!` });
                return;
            }
            
            // Visual feedback
            createPopParticles(node.x, node.y, colors.blue);
        }

        function linkNodes(node) {
            if (node.state !== 'alive') return;
            
            if (!linkSourceNode) {
                // First node selected
                linkSourceNode = node;
                logEvent('custom', { message: `üîó Link source set to node ${node.id}. Click another node to complete the link.` });
                
                // Visual feedback
                createPopParticles(node.x, node.y, colors.blue);
            } else {
                // Second node selected - create link
                if (linkSourceNode === node) {
                    logEvent('custom', { message: `‚ö†Ô∏è Cannot link a node to itself!` });
                    linkSourceNode = null;
                    return;
                }
                
                // Check if edge already exists
                const edgeExists = edges.some(e => 
                    (e.from === linkSourceNode && e.to === node) || 
                    (e.from === node && e.to === linkSourceNode)
                );
                
                if (edgeExists) {
                    logEvent('custom', { message: `‚ö†Ô∏è Nodes ${linkSourceNode.id} and ${node.id} are already connected!` });
                } else {
                    edges.push({
                        from: linkSourceNode,
                        to: node,
                        natural: false,
                        userCreated: true
                    });
                    logEvent('custom', { message: `üîó Created link between node ${linkSourceNode.id} and node ${node.id}!` });
                    
                    // Visual feedback
                    createPopParticles(linkSourceNode.x, linkSourceNode.y, colors.blue);
                    createPopParticles(node.x, node.y, colors.blue);
                }
                
                linkSourceNode = null;
            }
        }

        // Get node at mouse position
        function getNodeAtPosition(x, y) {
            for (let i = nodes.length - 1; i >= 0; i--) {
                const node = nodes[i];
                if (node.state !== 'alive') continue;
                
                const dx = x - node.x;
                const dy = y - node.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < node.radius + 5) {
                    return node;
                }
            }
            return null;
        }

        // Canvas click handler for tools
        canvas.addEventListener('click', (e) => {
            if (!activeTool) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const clickedNode = getNodeAtPosition(x, y);
            if (clickedNode) {
                applyTool(clickedNode);
            }
        });

        const STATUS_LOG_KEYS = {
            red: 'statusDown',
            malware: 'statusMalware',
            botnet: 'statusBotnet',
            green: 'statusRecovered',
            yellow: 'statusWarning',
            commandControl: 'statusCommandControl',
            blue: 'statusBlue'
        };

        // --- Canvas and Node Setup ---
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        // --- Geometric utility for resolving crossed lines ---
        function linesIntersect(p1, q1, p2, q2) {
            // Helper to find orientation of ordered triplet (p, q, r)
            function orientation(p, q, r) {
                if (!p || !q || !r) return 0; // Prevent errors on missing nodes
                const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
                if (val === 0) return 0; // Collinear
                return (val > 0) ? 1 : 2; // Clockwise or Counterclockwise
            }

            // Helper to check if point q lies on segment pr
            function onSegment(p, q, r) {
                if (!p || !q || !r) return false;
                return (q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) &&
                        q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y));
            }

            const o1 = orientation(p1, q1, p2);
            const o2 = orientation(p1, q1, q2);
            const o3 = orientation(p2, q2, p1);
            const o4 = orientation(p2, q2, q1);

            // General case of intersection
            if (o1 !== o2 && o3 !== o4) return true;

            // Special Cases for collinear points on a segment
            if (o1 === 0 && onSegment(p1, p2, q1)) return true;
            if (o2 === 0 && onSegment(p1, q2, q1)) return true;
            if (o3 === 0 && onSegment(p2, p1, q2)) return true;
            if (o4 === 0 && onSegment(p2, q1, q2)) return true;

            return false;
        }

        function segmentCrossesExistingEdges(a, b) {
            const toPoint = (obj) => ({ x: (obj && obj.baseX !== undefined) ? obj.baseX : obj.x, y: (obj && obj.baseY !== undefined) ? obj.baseY : obj.y });
            const A = toPoint(a);
            const B = toPoint(b);
            for (const e of edges) {
                const p1n = e.from, p2n = e.to;
                if (!p1n || !p2n) continue;
                if (e.isWirelessLink || e.isGuardianVpnTunnel) continue;
                if (p1n === a || p2n === a) continue; // share endpoint with start
                if (p1n.state !== 'alive' || p2n.state !== 'alive') continue;
                const P1 = toPoint(p1n);
                const P2 = toPoint(p2n);
                if (linesIntersect(A, B, P1, P2)) return true;
            }
            return false;
        }

        function nudgeEndpointToAvoidCrossing(parent, endpoint) {
            const MAX_SHIFT = 80;
            const STEP = 6;
            const vx = endpoint.x - parent.x;
            const vy = endpoint.y - parent.y;
            const len = Math.max(1e-6, Math.sqrt(vx * vx + vy * vy));
            const nx = -vy / len; // perpendicular
            const ny = vx / len;
            for (let s = STEP; s <= MAX_SHIFT; s += STEP) {
                const candidates = [
                    { x: endpoint.x + nx * s, y: endpoint.y + ny * s },
                    { x: endpoint.x - nx * s, y: endpoint.y - ny * s },
                ];
                for (const c of candidates) {
                    c.x = Math.max(padding, Math.min(canvas.width - padding, c.x));
                    c.y = Math.max(padding, Math.min(canvas.height - padding, c.y));
                    if (!segmentCrossesExistingEdges(parent, c)) return c;
                }
            }
            return null;
        }

        // --- NEW: Quadtree Implementation for Performance Optimization ---
        
        // Represents a circular area for querying the quadtree
        class Circle {
            constructor(x, y, r) {
                this.x = x;
                this.y = y;
                this.r = r;
                this.rSquared = this.r * this.r;
            }

            // Check if a node is inside this circle
            contains(node) {
                let d = Math.pow(node.x - this.x, 2) + Math.pow(node.y - this.y, 2);
                return d <= this.rSquared;
            }

            // Check if this circle intersects with a rectangular boundary
            intersects(range) {
                let xDist = Math.abs(range.x - this.x);
                let yDist = Math.abs(range.y - this.y);
                let r = this.r;
                let w = range.w;
                let h = range.h;

                if (xDist > w + r || yDist > h + r) return false;
                if (xDist <= w || yDist <= h) return true;

                let cornerDistSq = Math.pow(xDist - w, 2) + Math.pow(yDist - h, 2);
                return cornerDistSq <= this.rSquared;
            }
        }
        
        // Represents a rectangular boundary for a quadtree quadrant
        class Rectangle {
            constructor(x, y, w, h) {
                this.x = x; // center x
                this.y = y; // center y
                this.w = w; // half-width
                this.h = h; // half-height
            }

            // Check if a node is within this boundary
            contains(node) {
                return (
                    node.x >= this.x - this.w &&
                    node.x < this.x + this.w &&
                    node.y >= this.y - this.h &&
                    node.y < this.y + this.h
                );
            }

            // Check if another rectangular boundary intersects with this one
            intersects(range) {
                return !(
                    range.x - range.w > this.x + this.w ||
                    range.x + range.w < this.x - this.w ||
                    range.y - range.h > this.y + this.h ||
                    range.y + range.h < this.y - this.h
                );
            }
        }

        // The Quadtree class for spatial partitioning
        class Quadtree {
            constructor(boundary, capacity) {
                this.boundary = boundary;
                this.capacity = capacity; // Max number of nodes in a quadrant before it subdivides
                this.nodes = [];
                this.divided = false;
            }

            // Create four sub-quadrants
            subdivide() {
                let { x, y, w, h } = this.boundary;
                let hw = w / 2;
                let hh = h / 2;

                let nw = new Rectangle(x - hw, y - hh, hw, hh);
                this.northwest = new Quadtree(nw, this.capacity);
                let ne = new Rectangle(x + hw, y - hh, hw, hh);
                this.northeast = new Quadtree(ne, this.capacity);
                let sw = new Rectangle(x - hw, y + hh, hw, hh);
                this.southwest = new Quadtree(sw, this.capacity);
                let se = new Rectangle(x + hw, y + hh, hw, hh);
                this.southeast = new Quadtree(se, this.capacity);
                
                this.divided = true;
            }

            // Insert a node into the quadtree
            insert(node) {
                if (!this.boundary.contains(node)) {
                    return false;
                }

                if (this.nodes.length < this.capacity) {
                    this.nodes.push(node);
                    return true;
                }
                
                if (!this.divided) {
                    this.subdivide();
                }

                // Pass the node down to the correct sub-quadrant
                return (
                    this.northeast.insert(node) ||
                    this.northwest.insert(node) ||
                    this.southeast.insert(node) ||
                    this.southwest.insert(node)
                );
            }

            // Find all nodes within a given range (a Circle)
            query(range, found) {
                if (!found) {
                    found = [];
                }

                if (!range.intersects(this.boundary)) {
                    return found;
                }

                for (let n of this.nodes) {
                    if (range.contains(n)) {
                        found.push(n);
                    }
                }

                if (this.divided) {
                    this.northwest.query(range, found);
                    this.northeast.query(range, found);
                    this.southwest.query(range, found);
                    this.southeast.query(range, found);
                }
                
                return found;
            }
        }


        class Node {
            constructor(id, x, y, parent = null) {
                this.id = id;
                this.x = parent ? parent.x : x;
                this.y = parent ? parent.y : y;
                this.baseX = x;
                this.baseY = y;
                this.baseRadius = Math.random() * 8 + 7;
                this.radius = 0;
                this.targetRadius = this.baseRadius;
                this.status = 'green';
                this.parent = parent;
                this.children = [];
                this.fx = 0;
                this.fy = 0;
                this.time = Math.random() * 100;
                this.createdAt = Date.now();
                this.currentColor = { ...colors.green };
                this.state = 'spawning';
                this.opacity = 0;
                this.spawnProgress = 0;
                this.infectedAt = null;
                this.pulseDelay = 0;
                this.isTargeted = false;
                this.remediationState = 'none';
                this.remediationStart = 0;
                this.spinnerAngle = 0;
                this.pulseEffect = 0;
                this.isHealing = false; // Flag to indicate a node is being healed
                this.statusChangedAt = 0; // Timestamp for status changes
                this.spreadingInfections = []; // Array of objects: { target, startTime }
                this.isBeingInfected = false;
                this.isDefending = false;
                this.defenseStartTime = 0;
                this.isSelfHealing = false;
                this.selfHealingStartTime = 0;
                this.heartbeatRate = 0.025; // Base heartbeat speed
                this.heartbeatIntensity = 0.4; // How much the node pulses
                this.breathingPhase = Math.random() * Math.PI * 2; // Random starting phase for organic feel
                this.spreadDelay = 0; // Delay before an infected node tries to spread
                this.canSpread = true; // Whether this node will attempt to spread (90% yes, 10% no)
                this.pendingDispatchPromotionCheck = false; // Flag to evaluate guardian promotion after remediation
                
                // Immunity system properties
                this.attachedImmunityPackets = []; // Array of immunity packets attached to this node
                this.immunityHealingStartTime = 0; // When immunity healing started
                this.isImmunityHealing = false; // Whether this node is being healed by immunity packets
                
                // Guardian properties
                this.isGuardian = false; // Threat-hunter designation
                this.guardianImmunityLastSpawn = 0; // Cooldown tracker for immunity streams
                this.guardianStreamCount = 0; // Counts emitted immunity packets for cadence control
                this.guardianDispatchLastSent = 0; // Tracks last guardian dispatch packet timing
                this.guardianVpnTunnels = []; // Active guardian VPN tunnels
                this.lastGuardianBridgeUpdate = 0; // Timestamp for VPN tunnel refresh cadence
                this.lastGuardianFirewallAttempt = 0; // Tracks last attempt to configure a firewall
                this.selfHealingDispatchAllowance = 0; // Extra dispatches allowed during self-healing
                this.selfHealingPacketsCreated = 0; // Tracks packets spawned during central self-healing
                this.selfHealingPacketCap = 0; // Maximum packets allowed per self-heal
                this.botDefenseBurstCounts = {}; // Track bot defense bursts per branch
                this.isGroundStation = false; // Tower nodes anchoring sparse branches
                this.groundStationEstablishedAt = 0; // Timestamp when promoted to ground station
                this.satelliteChain = [];
                this.satelliteEdges = [];

                // Satellite node properties
                this.isSatellite = false;
                this.satelliteHost = null;
                this.isTethered = false;
                this.isDrifting = false;
                this.driftVelocityX = 0;
                this.driftVelocityY = 0;
                this.lastSatelliteChainCheck = 0;

                // Shield properties
                this.hasFirewall = Math.random() < 0.25; // 25% of nodes have firewall capability (increased from 10%)
                this.shieldActive = false; // Whether shield is currently visible
                this.shieldOpacity = 0; // Current shield opacity (0-1)
                this.shieldStrength = 1.0; // Shield strength (0-1), affects size and opacity
                this.shieldFlashTimer = Math.random() * 10000; // Time until next shield flash
                this.shieldCracking = false; // Whether shield is cracking/shattering
                this.shieldCrackProgress = 0; // Progress of cracking animation (0-1)
                this.shieldFragments = []; // Fragments for shatter animation
                
                // Recovery shield (central node only)
                this.hasRecoveryShield = false; // Blue immunity shield after recovering from infection
                this.recoveryShieldStartTime = 0; // When the recovery shield was activated
                this.recoveryShieldDuration = 15000; // 15 seconds of protection
                
                // Command & Control (C&C) node properties
                this.isCommandControl = false; // Whether this is a C&C node
                this.ccRotation = 0; // Rotation angle for C&C visual effects
                this.activePingOfDeath = null; // Track active ping of death packet (one at a time)
                this.lastPingTime = 0; // Cooldown for ping of death
                // Bot Defense Mode state (central node only)
                this.botDefenseModeActive = false;
                this.botDefenseModeStart = 0;
                this.botDefenseCooldownUntil = 0;
                this.botDefenseTargets = []; // direct infected child branches
                this.botDefenseLastBurst = 0;
                
                // DDOS Attack state (C&C nodes only)
                this.ddosState = 'idle'; // 'idle', 'charging', 'active'
                this.ddosChargeStart = 0;
                this.ddosActiveStart = 0;
                this.ddosTargetBranch = null; // The main branch node being attacked
                this.ddosBotnets = []; // Botnet nodes participating in the attack
                this.ddosCooldownUntil = 0;
                
                // DDOS victim state (branch nodes under attack)
                this.isUnderDDOS = false;
                this.ddosAttacker = null; // The C&C node coordinating the attack
                
                // Settling phase for organic physics (new nodes settle in gradually)
                this.settlingPhase = 2000; // 2 seconds to "settle in"
                this.physicsMultiplier = 0.3; // Start with 30% physics influence
            }

            draw() {
                if (this.opacity <= 0 && this.state !== 'spawning') return;

                const mainColorRgba = `rgba(${Math.round(this.currentColor.r)}, ${Math.round(this.currentColor.g)}, ${Math.round(this.currentColor.b)}, ${this.opacity})`;
                
                // Performance: Disable shadows at high node counts
                const enableShadows = nodes.length <= 150;

                if (this.parent === null) {
                    ctx.save();
                    ctx.translate(centralImpactShakeOffsetX, centralImpactShakeOffsetY);
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = mainColorRgba;
                    if (enableShadows) {
                        ctx.shadowColor = `rgba(${Math.round(this.currentColor.r)}, ${Math.round(this.currentColor.g)}, ${Math.round(this.currentColor.b)}, 0.7)`;
                        ctx.shadowBlur = 30;
                    }
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    
                    if (this.status === 'malware') {
                        this.drawMalwareIcon();
                    } else {
                        this.drawGlobe(); // Also handles its own defense pulse
                    }
                    // Offensive security aura during Bot Defense Mode
                    if (this.botDefenseModeActive) {
                        this.drawBotDefenseMode();
                    }
                    if (this.isSelfHealing) {
                        this.drawAntibodySpinner();
                    }
                    
                    // Draw shields for central node
                    if (this.shieldCracking) {
                        this.drawCrackingShield();
                    } else if (this.shieldActive && this.shieldOpacity > 0) {
                        this.drawShield();
                    }
                    
                    ctx.restore();
                    return;
                }

                // Performance: Skip pulse effect at high node counts (barely visible in crowds)
                if (nodes.length <= 200) {
                    const pulseRadius = this.radius * (1.8 + Math.sin(this.time * 0.1) * 0.4);
                    const pulseAlpha = 0.2 * (1 - (pulseRadius / (this.radius * 2.2) - 0.5));
                    const pulseColorRgba = `rgba(${Math.round(this.currentColor.r)}, ${Math.round(this.currentColor.g)}, ${Math.round(this.currentColor.b)}, ${pulseAlpha * this.opacity})`;

                    ctx.beginPath();
                    ctx.arc(this.x, this.y, pulseRadius, 0, Math.PI * 2);
                    ctx.fillStyle = pulseColorRgba;
                    ctx.fill();
                }

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = mainColorRgba;

                if (enableShadows) {
                    if (this.status === 'red' || this.status === 'malware' || this.status === 'botnet' || this.status === 'commandControl') {
                        const flashBlur = 15 + (Math.sin(this.time * 0.3) * 10);
                        let flashColor = this.currentColor;
                        if (this.status === 'malware' || this.status === 'botnet') {
                            flashColor = this.isGroundStation ? colors.malware : colors.red;
                        }
                        if (this.status === 'commandControl') flashColor = colors.commandControl;
                        ctx.shadowColor = `rgba(${flashColor.r}, ${flashColor.g}, ${flashColor.b}, ${this.opacity})`;
                        ctx.shadowBlur = Math.max(0, flashBlur);
                    } else {
                        ctx.shadowColor = mainColorRgba;
                        ctx.shadowBlur = 15;
                    }
                }
                
                ctx.fill();
                ctx.shadowBlur = 0;

                // Performance: Skip icon drawing at high node counts, except for important nodes
                const drawIcons = nodes.length <= 200 || this.isGuardian || this.isGroundStation || this.status === 'commandControl';
                
                if (drawIcons) {
                    if (this.isGuardian) {
                        this.drawGuardianIcon();
                    } else if (this.isGroundStation) {
                        this.drawGroundStationIcon();
                    } else if (this.isSatellite) {
                        this.drawSatelliteIcon();
                    } else if (this.status === 'commandControl') {
                        this.drawSkullIcon();
                    } else if (this.status === 'malware' || this.status === 'botnet') {
                        this.drawMalwareIcon();
                    } else if (this.status === 'green') {
                        this.drawCheckmarkIcon();
                    } else if (this.status === 'red') {
                        this.drawStopIcon();
                    } else if (this.status === 'yellow') {
                        this.drawTriangleIcon();
                    }
                }
                
                if (this.remediationState === 'spinning') {
                    this.drawSpinner();
                }
                if (this.isBeingInfected) {
                    this.drawInfectionSpinner();
                }
                
                // Draw shields
                if (this.shieldCracking) {
                    this.drawCrackingShield();
                } else if (this.shieldActive && this.shieldOpacity > 0) {
                    this.drawShield();
                }

                // Draw defense pulse for regular nodes
                if (this.isDefending) {
                    const defenseDuration = 1000;
                    const elapsed = Date.now() - this.defenseStartTime;
                    if (elapsed < defenseDuration) {
                        const progress = elapsed / defenseDuration;
                        const pulseRadius = this.radius * (1 + progress * 2);
                        const pulseOpacity = 1 - progress;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, pulseRadius, 0, Math.PI * 2);
                        ctx.strokeStyle = `rgba(${colors.red.r}, ${colors.red.g}, ${colors.red.b}, ${pulseOpacity})`;
                        ctx.lineWidth = 4 * (1 - progress);
                        ctx.stroke();
                    } else {
                        this.isDefending = false;
                    }
                }
                
                // Draw immunity healing progress
                if (this.isImmunityHealing && this.attachedImmunityPackets.length > 0) {
                    const BASE_HEAL_TIME = 120000 / healSpeedMultiplier; // 120 seconds for 1 packet
                    
                    // Count regular and supercharged packets
                    // Supercharged packets count as 2 regular packets
                    let regularCount = 0;
                    let superchargedCount = 0;
                    this.attachedImmunityPackets.forEach(packet => {
                        if (packet.isSupercharged) {
                            superchargedCount++;
                        } else {
                            regularCount++;
                        }
                    });
                    
                    // Calculate effective packet count (supercharged = 2x regular)
                    // Reduced recovery modifier by half for slower healing (must match healing completion logic)
                    const effectivePackets = (regularCount + (superchargedCount * 2)) / 2;
                    const healTime = BASE_HEAL_TIME / effectivePackets;
                    
                    const elapsed = Date.now() - this.immunityHealingStartTime;
                    const progress = Math.min(1, elapsed / healTime);
                    
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    const progressBarRadius = this.radius + 12;
                    const lineWidth = 3;
                    
                    // Draw background circle
                    ctx.beginPath();
                    ctx.arc(0, 0, progressBarRadius, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(255, 255, 255, ${this.opacity * 0.2})`;
                    ctx.lineWidth = lineWidth;
                    ctx.stroke();
                    
                    // Draw progress arc - gold if any supercharged packets, white otherwise
                    ctx.beginPath();
                    const startAngle = -Math.PI / 2; // Start from the top
                    const endAngle = startAngle + (progress * Math.PI * 2);
                    ctx.arc(0, 0, progressBarRadius, startAngle, endAngle);
                    
                    if (superchargedCount > 0) {
                        // Gold progress bar for supercharged healing
                        ctx.strokeStyle = `rgba(${colors.gold.r}, ${colors.gold.g}, ${colors.gold.b}, ${this.opacity})`;
                        ctx.shadowColor = `rgba(${colors.gold.r}, ${colors.gold.g}, ${colors.gold.b}, 1)`;
                    } else {
                        // White progress bar for normal healing
                        ctx.strokeStyle = `rgba(255, 255, 255, ${this.opacity})`;
                        ctx.shadowColor = 'rgba(255, 255, 255, 1)';
                    }
                    
                    ctx.lineWidth = lineWidth;
                    ctx.lineCap = 'round';
                    ctx.shadowBlur = 8;
                    ctx.stroke();
                    
                    ctx.restore();
                }
            }

            drawMalwareIcon() {
                const iconSize = this.radius * 1.2;
                if (iconSize < 4) return;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = `bold ${iconSize}px sans-serif`;
                // Show ü§ñ for botnet, üëæ for regular malware
                const icon = this.status === 'botnet' ? 'ü§ñ' : 'üëæ';
                ctx.fillText(icon, 0, iconSize * 0.1);
                ctx.restore();
            }

            drawGuardianIcon() {
                const iconSize = this.radius * 1.3;
                if (iconSize < 4) return;

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.fillStyle = '#000000';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = `bold ${iconSize}px sans-serif`;
                ctx.fillText('üï∂', 0, iconSize * 0.05);
                ctx.restore();
            }

            drawGroundStationIcon() {
                const iconSize = this.radius * 1.1;
                if (iconSize < 4) return;

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = `bold ${iconSize}px sans-serif`;
                ctx.fillText('üì°', 0, iconSize * 0.05);
                ctx.restore();
            }

            drawSatelliteIcon() {
                const iconSize = this.radius * 1.0;
                if (iconSize < 3) return;

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = `bold ${iconSize}px sans-serif`;
                ctx.fillText('üõ∞Ô∏è', 0, 0);
                ctx.restore();
            }

            drawCheckmarkIcon() {
                const iconSize = this.radius * 1.2;
                if (iconSize < 4) return;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                // Black shield for firewall nodes, white checkmark for regular nodes
                ctx.fillStyle = this.hasFirewall ? `rgba(0, 0, 0, ${this.opacity})` : `rgba(255, 255, 255, ${this.opacity})`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = `bold ${iconSize}px sans-serif`;
                const icon = this.hasFirewall ? 'üõ°Ô∏è' : '‚úì';
                ctx.fillText(icon, 0, iconSize * 0.1);
                ctx.restore();
            }

            drawStopIcon() {
                const iconSize = this.radius * 1.2;
                if (iconSize < 4) return;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.fillStyle = `rgba(0, 0, 0, ${this.opacity})`; // Black X for down nodes
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = `bold ${iconSize}px sans-serif`;
                ctx.fillText('X', 0, iconSize * 0.1);
                ctx.restore();
            }

            drawTriangleIcon() {
                const iconSize = this.radius * 1.2;
                if (iconSize < 4) return;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.fillStyle = `rgba(0, 0, 0, ${this.opacity})`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = `bold ${iconSize}px sans-serif`;
                ctx.fillText('‚ö†Ô∏è', 0, 0);
                ctx.restore();
            }

            drawSkullIcon() {
                const iconSize = this.radius * 1.2;
                if (iconSize < 4) return;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = `bold ${iconSize}px sans-serif`;
                ctx.fillText('‚ò†Ô∏è', 0, iconSize * 0.1);
                ctx.restore();
                
                // Draw rotating danger ring around C&C node
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.ccRotation);
                
                const ringRadius = this.radius * 1.8;
                const segments = 8;
                
                for (let i = 0; i < segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;
                    const nextAngle = ((i + 1) / segments) * Math.PI * 2;
                    
                    // Alternate between solid and transparent segments
                    if (i % 2 === 0) {
                        ctx.beginPath();
                        ctx.arc(0, 0, ringRadius, angle, nextAngle);
                        ctx.strokeStyle = `rgba(${colors.commandControl.r}, ${colors.commandControl.g}, ${colors.commandControl.b}, ${this.opacity * 0.8})`;
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    }
                }
                
                ctx.restore();
            }

            drawSpinner() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.spinnerAngle);
                ctx.strokeStyle = `rgba(255, 255, 255, ${this.opacity * 0.9})`;
                ctx.lineWidth = Math.max(1.5, this.radius * 0.2);
                ctx.beginPath();
                ctx.arc(0, 0, this.radius + 4, 0, Math.PI * 1.5);
                ctx.stroke();
                ctx.restore();
            }

            drawAntibodySpinner() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                const elapsed = Date.now() - this.selfHealingStartTime;
                const duration = 5000;
                const progress = Math.min(1, elapsed / duration);
                const opacity = this.opacity;

                const progressBarRadius = this.radius + 10;
                const lineWidth = 4;

                // Draw the background of the progress circle
                ctx.beginPath();
                ctx.arc(0, 0, progressBarRadius, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 0.2})`;
                ctx.lineWidth = lineWidth;
                ctx.stroke();

                // Draw the filling progress bar
                ctx.beginPath();
                const startAngle = -Math.PI / 2; // Start from the top
                const endAngle = startAngle + (progress * Math.PI * 2);
                ctx.arc(0, 0, progressBarRadius, startAngle, endAngle);
                ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
                ctx.lineWidth = lineWidth;
                ctx.lineCap = 'round';
                ctx.stroke();
                
                ctx.restore();
            }
            
            drawInfectionSpinner() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(-this.spinnerAngle); // Rotate counter-clockwise
                ctx.strokeStyle = `rgba(${colors.malware.r}, ${colors.malware.g}, ${colors.malware.b}, ${this.opacity * 0.9})`;
                ctx.lineWidth = Math.max(1.5, this.radius * 0.2);
                ctx.beginPath();
                ctx.arc(0, 0, this.radius + 5, 0, Math.PI * 0.8);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(0, 0, this.radius + 5, Math.PI, Math.PI * 1.8);
                ctx.stroke();
                ctx.restore();
            }

            drawGlobe() {
                ctx.save();
                
                const rotation = this.time * 0.008; // Slower rotation for elegance
                const tilt = Math.PI / 6; // 30 degree tilt for 3D effect
                
                // Atmospheric glow (outer layer)
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, this.radius * 0.8,
                    this.x, this.y, this.radius * 1.4
                );
                gradient.addColorStop(0, `rgba(${this.currentColor.r}, ${this.currentColor.g}, ${this.currentColor.b}, 0)`);
                gradient.addColorStop(0.5, `rgba(${this.currentColor.r}, ${this.currentColor.g}, ${this.currentColor.b}, ${0.15 * this.opacity})`);
                gradient.addColorStop(1, `rgba(${this.currentColor.r}, ${this.currentColor.g}, ${this.currentColor.b}, 0)`);
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 1.4, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Inner glow for depth
                const innerGlow = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, this.radius
                );
                innerGlow.addColorStop(0, `rgba(255, 255, 255, ${0.3 * this.opacity})`);
                innerGlow.addColorStop(0.5, `rgba(${this.currentColor.r}, ${this.currentColor.g}, ${this.currentColor.b}, ${0.1 * this.opacity})`);
                innerGlow.addColorStop(1, `rgba(${this.currentColor.r}, ${this.currentColor.g}, ${this.currentColor.b}, 0)`);
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = innerGlow;
                ctx.fill();
                
                // Draw latitude lines (horizontal circles)
                const latitudes = 7;
                for (let i = 1; i < latitudes; i++) {
                    const lat = (i / latitudes) * Math.PI - Math.PI / 2;
                    const y = Math.sin(lat);
                    const radiusAtLat = Math.cos(lat);
                    
                    ctx.beginPath();
                    ctx.ellipse(
                        this.x, 
                        this.y + y * this.radius * Math.cos(tilt),
                        radiusAtLat * this.radius,
                        radiusAtLat * this.radius * Math.sin(tilt),
                        0, 0, Math.PI * 2
                    );
                    ctx.strokeStyle = `rgba(255, 255, 255, ${this.opacity * 0.15})`;
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                }
                
                // Equator (brighter)
                ctx.beginPath();
                ctx.ellipse(
                    this.x, this.y,
                    this.radius,
                    this.radius * Math.sin(tilt),
                    0, 0, Math.PI * 2
                );
                ctx.strokeStyle = `rgba(255, 255, 255, ${this.opacity * 0.4})`;
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Draw longitude meridians (rotating vertical ellipses)
                const longitudes = 12;
                for (let i = 0; i < longitudes; i++) {
                    const angle = (i / longitudes) * Math.PI + rotation;
                    
                    // Calculate visibility (fade lines on the back side)
                    const visibility = Math.cos(angle);
                    const opacity = visibility > 0 ? 
                        this.opacity * 0.3 * visibility : 
                        this.opacity * 0.08 * Math.abs(visibility);
                    
                    ctx.beginPath();
                    ctx.ellipse(
                        this.x, this.y,
                        this.radius * Math.abs(Math.sin(angle)),
                        this.radius,
                        0, 0, Math.PI * 2
                    );
                    ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
                    ctx.lineWidth = visibility > 0 ? 1 : 0.5;
                    ctx.stroke();
                }
                
                // Prime meridian (highlighted, rotating)
                const primeMeridianAngle = rotation;
                const primeVisibility = Math.cos(primeMeridianAngle);
                if (primeVisibility > 0) {
                    ctx.beginPath();
                    ctx.ellipse(
                        this.x, this.y,
                        this.radius * Math.abs(Math.sin(primeMeridianAngle)),
                        this.radius,
                        0, 0, Math.PI * 2
                    );
                    ctx.strokeStyle = `rgba(${this.currentColor.r}, ${this.currentColor.g}, ${this.currentColor.b}, ${this.opacity * 0.6 * primeVisibility})`;
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                }
                
                // Data nodes/continents (simplified dots rotating with globe)
                const dataPoints = [
                    { lat: 0.3, lon: 0 },
                    { lat: -0.2, lon: 0.8 },
                    { lat: 0.5, lon: 1.5 },
                    { lat: -0.4, lon: 2.2 },
                    { lat: 0.1, lon: 3.0 },
                    { lat: 0.6, lon: 4.0 },
                ];
                
                dataPoints.forEach(point => {
                    const lon = point.lon + rotation;
                    const lat = point.lat;
                    
                    // 3D position calculation
                    const x3d = Math.cos(lat) * Math.sin(lon);
                    const y3d = Math.sin(lat);
                    const z3d = Math.cos(lat) * Math.cos(lon);
                    
                    // Only draw points on the visible hemisphere
                    if (z3d > 0) {
                        const screenX = this.x + x3d * this.radius;
                        const screenY = this.y + y3d * this.radius * Math.cos(tilt);
                        const size = 2 + z3d * 2; // Larger when closer
                        const pointOpacity = this.opacity * z3d * 0.8;
                        
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(${this.currentColor.r}, ${this.currentColor.g}, ${this.currentColor.b}, ${pointOpacity})`;
                        ctx.fill();
                        
                        // Subtle glow for data points
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, size * 2, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(${this.currentColor.r}, ${this.currentColor.g}, ${this.currentColor.b}, ${pointOpacity * 0.2})`;
                        ctx.fill();
                    }
                });
                
                // Defense pulse effect
                if (this.isDefending) {
                    const defenseDuration = 1000;
                    const elapsed = Date.now() - this.defenseStartTime;
                    if (elapsed < defenseDuration) {
                        const progress = elapsed / defenseDuration;
                        const pulseRadius = this.radius * (1 + progress * 2);
                        const pulseOpacity = (1 - progress) * this.opacity;
                        
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, pulseRadius, 0, Math.PI * 2);
                        ctx.strokeStyle = `rgba(${colors.green.r}, ${colors.green.g}, ${colors.green.b}, ${pulseOpacity})`;
                        ctx.lineWidth = 5 * (1 - progress);
                        ctx.stroke();
                    } else {
                        this.isDefending = false;
                    }
                }
                
                ctx.restore();
            }

            drawBotDefenseMode() {
                // Spinning dual-ring with spokes (offensive security vibe)
                const elapsed = Date.now() - this.botDefenseModeStart;
                const spin = elapsed * 0.003;
                const pulse = 0.5 + Math.sin(elapsed * 0.01) * 0.5;
                const outerRadius = this.radius * (1.9 + 0.2 * Math.sin(elapsed * 0.002));
                const innerRadius = outerRadius * 0.6;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(spin);
                // Outer ring (gold)
                ctx.beginPath();
                ctx.arc(0, 0, outerRadius, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(${colors.gold.r}, ${colors.gold.g}, ${colors.gold.b}, ${0.4 + 0.4 * pulse})`;
                ctx.lineWidth = 3;
                ctx.stroke();
                // Inner ring (white)
                ctx.beginPath();
                ctx.arc(0, 0, innerRadius, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(${colors.white.r}, ${colors.white.g}, ${colors.white.b}, ${0.25 + 0.35 * pulse})`;
                ctx.lineWidth = 2;
                ctx.stroke();
                // Spokes (blue)
                const spokes = 8;
                for (let i = 0; i < spokes; i++) {
                    const a = (i / spokes) * Math.PI * 2;
                    const len = innerRadius + (outerRadius - innerRadius) * (0.55 + 0.15 * Math.sin(elapsed * 0.004 + i));
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(Math.cos(a) * len, Math.sin(a) * len);
                    ctx.strokeStyle = `rgba(${colors.blue.r}, ${colors.blue.g}, ${colors.blue.b}, ${0.3 + 0.3 * pulse})`;
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                }
                ctx.restore();
            }

            drawShield() {
                if (this.shieldOpacity <= 0 && !this.shieldCracking) return;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Recovery shield for central node has enhanced appearance
                const isRecoveryShield = this.parent === null && this.hasRecoveryShield;
                
                // Base shield size scales with node size and strength
                let shieldRadius = this.radius * (1.8 + this.shieldStrength * 0.4);
                let shieldOpacity = this.shieldOpacity * this.shieldStrength * this.opacity;
                
                // Recovery shield is larger and more visible
                if (isRecoveryShield) {
                    shieldRadius = this.radius * 2.2;
                    shieldOpacity = Math.min(1.0, shieldOpacity * 1.5);
                }
                
                // Hexagonal shield pattern
                const sides = 6;
                const angleStep = (Math.PI * 2) / sides;
                const rotation = this.time * 0.01; // Slow rotation
                
                // Outer hexagon (main shield)
                ctx.beginPath();
                for (let i = 0; i <= sides; i++) {
                    const angle = i * angleStep + rotation;
                    const x = Math.cos(angle) * shieldRadius;
                    const y = Math.sin(angle) * shieldRadius;
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.closePath();
                
                // Shield color - blue for recovery shield, otherwise based on status
                const shieldColor = isRecoveryShield ? colors.blue : (this.status === 'green' ? colors.green : colors.blue);
                const lineWidth = isRecoveryShield ? 3 : 2;
                const shadowBlur = isRecoveryShield ? 20 : 10;
                
                ctx.strokeStyle = `rgba(${shieldColor.r}, ${shieldColor.g}, ${shieldColor.b}, ${shieldOpacity * 0.8})`;
                ctx.lineWidth = lineWidth;
                ctx.shadowColor = `rgba(${shieldColor.r}, ${shieldColor.g}, ${shieldColor.b}, ${shieldOpacity})`;
                ctx.shadowBlur = shadowBlur;
                ctx.stroke();
                
                // Inner hexagon (detail)
                const innerRadius = shieldRadius * 0.7;
                ctx.beginPath();
                for (let i = 0; i <= sides; i++) {
                    const angle = i * angleStep - rotation * 0.5; // Counter-rotate
                    const x = Math.cos(angle) * innerRadius;
                    const y = Math.sin(angle) * innerRadius;
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.closePath();
                ctx.strokeStyle = `rgba(${shieldColor.r}, ${shieldColor.g}, ${shieldColor.b}, ${shieldOpacity * 0.5})`;
                ctx.lineWidth = isRecoveryShield ? 2 : 1;
                ctx.shadowBlur = isRecoveryShield ? 10 : 5;
                ctx.stroke();
                
                // Connecting lines between hexagons
                ctx.shadowBlur = 0;
                for (let i = 0; i < sides; i++) {
                    const angle = i * angleStep + rotation;
                    const outerX = Math.cos(angle) * shieldRadius;
                    const outerY = Math.sin(angle) * shieldRadius;
                    const innerX = Math.cos(angle - rotation * 0.5) * innerRadius;
                    const innerY = Math.sin(angle - rotation * 0.5) * innerRadius;
                    
                    ctx.beginPath();
                    ctx.moveTo(innerX, innerY);
                    ctx.lineTo(outerX, outerY);
                    ctx.strokeStyle = `rgba(${shieldColor.r}, ${shieldColor.g}, ${shieldColor.b}, ${shieldOpacity * 0.3})`;
                    ctx.lineWidth = isRecoveryShield ? 1.5 : 1;
                    ctx.stroke();
                }
                
                // Recovery shield gets extra energy pulses
                if (isRecoveryShield) {
                    const pulseProgress = (Date.now() % 2000) / 2000;
                    const pulseRadius = shieldRadius * (1 + pulseProgress * 0.3);
                    const pulseOpacity = (1 - pulseProgress) * shieldOpacity * 0.5;
                    
                    ctx.beginPath();
                    for (let i = 0; i <= sides; i++) {
                        const angle = i * angleStep + rotation;
                        const x = Math.cos(angle) * pulseRadius;
                        const y = Math.sin(angle) * pulseRadius;
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.closePath();
                    ctx.strokeStyle = `rgba(${shieldColor.r}, ${shieldColor.g}, ${shieldColor.b}, ${pulseOpacity})`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                
                ctx.restore();
            }

            drawCrackingShield() {
                if (this.shieldCrackProgress <= 0) return;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                
                const shieldRadius = this.radius * (1.8 + this.shieldStrength * 0.4);
                const crackedOpacity = (1 - this.shieldCrackProgress) * this.opacity;
                const shieldColor = this.status === 'green' ? colors.green : colors.blue;
                
                // Draw cracks
                const numCracks = 6;
                for (let i = 0; i < numCracks; i++) {
                    const angle = (i / numCracks) * Math.PI * 2 + this.time * 0.01;
                    const crackLength = shieldRadius * this.shieldCrackProgress * 1.5;
                    
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    
                    // Jagged crack line
                    const segments = 5;
                    for (let j = 1; j <= segments; j++) {
                        const t = j / segments;
                        const distance = crackLength * t;
                        const jitter = (Math.random() - 0.5) * 10 * this.shieldCrackProgress;
                        const x = Math.cos(angle) * distance + jitter;
                        const y = Math.sin(angle) * distance + jitter;
                        ctx.lineTo(x, y);
                    }
                    
                    ctx.strokeStyle = `rgba(255, 100, 100, ${crackedOpacity * 0.8})`;
                    ctx.lineWidth = 2;
                    ctx.shadowColor = `rgba(255, 100, 100, ${crackedOpacity})`;
                    ctx.shadowBlur = 8;
                    ctx.stroke();
                }
                
                // Draw fragmenting shield pieces
                if (this.shieldFragments.length > 0) {
                    this.shieldFragments.forEach(fragment => {
                        ctx.save();
                        ctx.translate(fragment.x, fragment.y);
                        ctx.rotate(fragment.rotation);
                        
                        ctx.beginPath();
                        ctx.moveTo(fragment.points[0].x, fragment.points[0].y);
                        fragment.points.slice(1).forEach(point => {
                            ctx.lineTo(point.x, point.y);
                        });
                        ctx.closePath();
                        
                        const fragOpacity = (1 - this.shieldCrackProgress) * this.opacity * 0.6;
                        ctx.fillStyle = `rgba(${shieldColor.r}, ${shieldColor.g}, ${shieldColor.b}, ${fragOpacity * 0.3})`;
                        ctx.fill();
                        ctx.strokeStyle = `rgba(${shieldColor.r}, ${shieldColor.g}, ${shieldColor.b}, ${fragOpacity})`;
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        
                        ctx.restore();
                        
                        // Update fragment position
                        fragment.x += fragment.vx;
                        fragment.y += fragment.vy;
                        fragment.rotation += fragment.vr;
                        fragment.vy += 0.2; // Gravity
                    });
                }
                
                ctx.restore();
            }

            createShieldFragments() {
                this.shieldFragments = [];
                const shieldRadius = this.radius * 1.8;
                const numFragments = 8;
                
                for (let i = 0; i < numFragments; i++) {
                    const angle = (i / numFragments) * Math.PI * 2;
                    const distance = shieldRadius * 0.7;
                    
                    this.shieldFragments.push({
                        x: Math.cos(angle) * distance,
                        y: Math.sin(angle) * distance,
                        vx: Math.cos(angle) * (1 + Math.random() * 2),
                        vy: Math.sin(angle) * (1 + Math.random() * 2) - 1,
                        vr: (Math.random() - 0.5) * 0.2,
                        rotation: angle,
                        points: [
                            { x: 0, y: 0 },
                            { x: Math.random() * 10 + 5, y: (Math.random() - 0.5) * 10 },
                            { x: Math.random() * 5, y: Math.random() * 10 + 5 },
                            { x: -(Math.random() * 5), y: Math.random() * 5 }
                        ]
                    });
                }
            }

            updateShield() {
                const deltaTime = 16.67; // Approximate time per frame (60fps)
                
                // Check if recovery shield for central node should expire
                if (this.parent === null && this.hasRecoveryShield) {
                    const elapsed = Date.now() - this.recoveryShieldStartTime;
                    if (elapsed >= this.recoveryShieldDuration) {
                        // Shield duration complete - mark as expired and start fade
                        logEvent('recoveryShieldExpired', { node: this });
                        this.hasRecoveryShield = false;
                    } else {
                        // Recovery shield stays active and visible
                        this.shieldActive = true;
                        this.shieldStrength = 1.0;
                        // Maintain full opacity
                        if (this.shieldOpacity < 1) {
                            this.shieldOpacity += 0.1;
                            if (this.shieldOpacity > 1) this.shieldOpacity = 1;
                        }
                        return;
                    }
                }
                
                // Handle shield fade-out after recovery shield expires
                if (this.parent === null && !this.hasRecoveryShield && this.shieldOpacity > 0) {
                    this.shieldOpacity -= 0.05;
                    if (this.shieldOpacity <= 0) {
                        this.shieldOpacity = 0;
                        this.shieldActive = false;
                    }
                    return;
                }
                
                // Shield behavior based on node status
                if (this.status === 'green' || (this.parent === null && this.status !== 'malware' && this.status !== 'botnet' && this.status !== 'commandControl')) {
                    // Central node should NOT show regular shield flashes, only recovery shield
                    if (this.parent === null) {
                        // Central node without recovery shield has no shields
                        return;
                    }
                    
                    // Only regular nodes with firewall capability can show shields
                    if (!this.hasFirewall) {
                        // Node doesn't have firewall capability
                        return;
                    }
                    
                    // Healthy nodes have occasional shield flashes
                    
                    if (this.shieldCracking) {
                        // Complete any cracking animation
                        this.shieldCrackProgress += 0.05;
                        if (this.shieldCrackProgress >= 1) {
                            this.shieldCracking = false;
                            this.shieldCrackProgress = 0;
                            this.shieldFragments = [];
                            this.shieldActive = false;
                            this.shieldOpacity = 0;
                        }
                    } else {
                        // Decrement flash timer
                        this.shieldFlashTimer -= deltaTime;
                        
                        if (this.shieldFlashTimer <= 0) {
                            // Start shield flash
                            this.shieldActive = true;
                            this.shieldStrength = 0.8 + Math.random() * 0.2; // Random strength 80-100%
                            this.shieldFlashTimer = 8000 + Math.random() * 7000; // Next flash in 8-15 seconds
                        }
                        
                        // Shield opacity fade in/out
                        if (this.shieldActive) {
                            if (this.shieldOpacity < 1) {
                                this.shieldOpacity += 0.08; // Fade in
                                if (this.shieldOpacity >= 1) {
                                    this.shieldOpacity = 1;
                                }
                            } else {
                                // Hold at full opacity briefly, then fade out
                                this.shieldFlashTimer -= deltaTime;
                                if (this.shieldFlashTimer < -500) { // Hold for 0.5 seconds
                                    this.shieldOpacity -= 0.04; // Fade out slower
                                    if (this.shieldOpacity <= 0) {
                                        this.shieldOpacity = 0;
                                        this.shieldActive = false;
                                    }
                                }
                            }
                        }
                    }
                    
                    // If node is being infected, trigger shield crack
                    if (this.isBeingInfected && this.shieldActive && !this.shieldCracking) {
                        this.shieldCracking = true;
                        this.shieldCrackProgress = 0;
                        this.createShieldFragments();
                    }
                    
                } else if (this.status === 'malware' || this.status === 'botnet' || this.status === 'red' || this.status === 'yellow') {
                    // Infected or compromised nodes have no shields
                    if (this.shieldActive || this.shieldOpacity > 0) {
                        // Immediately shatter shield if it was active
                        if (!this.shieldCracking && this.shieldOpacity > 0.5) {
                            this.shieldCracking = true;
                            this.shieldCrackProgress = 0;
                            this.createShieldFragments();
                        }
                        
                        // Fast fade/crack
                        if (this.shieldCracking) {
                            this.shieldCrackProgress += 0.08;
                            if (this.shieldCrackProgress >= 1) {
                                this.shieldCracking = false;
                                this.shieldCrackProgress = 0;
                                this.shieldFragments = [];
                                this.shieldActive = false;
                                this.shieldOpacity = 0;
                            }
                        } else {
                            this.shieldOpacity -= 0.1;
                            if (this.shieldOpacity <= 0) {
                                this.shieldOpacity = 0;
                                this.shieldActive = false;
                            }
                        }
                    }
                }
                
                // During remediation, shields gradually rebuild
                if (this.remediationState === 'spinning') {
                    this.shieldStrength = Math.min(1.0, this.shieldStrength + 0.01);
                }
            }

            updateHeartbeat() {
                // Adjust heartbeat rate and intensity based on node status and activity
                let targetRate = 0.025; // Base rate
                let targetIntensity = 0.4; // Base intensity
                
                if (this.parent === null) {
                    // Central node has slower, deeper breathing
                    targetRate = 0.015;
                    targetIntensity = 0.3;
                    
                    if (this.status === 'malware' || this.status === 'botnet' || this.status === 'commandControl') {
                        // Infected central node has erratic heartbeat
                        targetRate = 0.06 + Math.sin(this.time * 0.02) * 0.03;
                        targetIntensity = 0.5;
                    } else if (this.isSelfHealing) {
                        // Faster heartbeat during healing
                        targetRate = 0.035;
                        targetIntensity = 0.4;
                    }
                } else {
                    // Regular nodes
                    switch(this.status) {
                        case 'green':
                            targetRate = 0.025;
                            targetIntensity = 0.4;
                            break;
                        case 'yellow':
                            // Stressed/warning nodes breathe faster but shallower
                            targetRate = 0.04;
                            targetIntensity = 0.3;
                            break;
                        case 'red':
                            // Down nodes have weak, slow pulse
                            targetRate = 0.015;
                            targetIntensity = 0.2;
                            break;
                        case 'malware':
                            // Infected nodes have rapid, intense pulse
                            targetRate = 0.08 + Math.sin(this.time * 0.08) * 0.02;
                            targetIntensity = 0.6;
                            break;
                    }
                    
                    // Activity modifiers
                    if (this.isBeingInfected) {
                        // Under attack - elevated heartbeat
                        targetRate *= 1.5;
                        targetIntensity *= 1.2;
                    }
                    
                    if (this.isDefending) {
                        // Defense response - sharp, fast pulse
                        targetRate *= 1.8;
                        targetIntensity *= 1.3;
                    }
                    
                    if (this.remediationState === 'spinning') {
                        // Being healed - calming down
                        targetRate *= 0.7;
                        targetIntensity *= 0.8;
                    }
                }
                
                // Smooth transition to target values
                this.heartbeatRate += (targetRate - this.heartbeatRate) * 0.1;
                this.heartbeatIntensity += (targetIntensity - this.heartbeatIntensity) * 0.1;
            }

            update() {
                const colorTransitionSpeed = 0.05;
                const spawnSpeed = 0.015;

                if (this.state === 'spawning') {
                    this.spawnProgress += spawnSpeed;
                    this.opacity = this.spawnProgress;

                    if (this.spawnProgress >= 1) {
                        this.spawnProgress = 1;
                        this.x = this.baseX;
                        this.y = this.baseY;
                        this.opacity = 1;
                        this.state = 'alive';
                    } else if (this.parent) {
                        const t = this.spawnProgress;
                        this.x = this.parent.x + (this.baseX - this.parent.x) * t;
                        this.y = this.parent.y + (this.baseY - this.parent.y) * t;
                    }

                } else if (this.state === 'retracting' && this.parent) {
                    if (this.children.length === 0) {
                        const retractionSpeed = 0.1;
                        this.x += (this.parent.x - this.x) * retractionSpeed;
                        this.y += (this.parent.y - this.y) * retractionSpeed;
                        
                        this.radius *= 0.95;
                        const dist = Math.sqrt((this.parent.x - this.x)**2 + (this.parent.y - this.y)**2);
                        if (dist < 5 || this.radius < 0.5) {
                            this.opacity = 0;
                        }
                    }
                }

                if (this.isSatellite && this.state === 'alive') {
                    const hostValid = this.satelliteHost && this.satelliteHost.isGroundStation && this.satelliteHost.state === 'alive';
                    const parentValid = this.parent && (this.parent.isGroundStation || this.parent.isSatellite) && this.parent.state === 'alive';
                    const parentTethered = !this.parent || !this.parent.isSatellite || this.parent.isTethered;
                    if (!hostValid || !parentValid || !parentTethered || !this.isTethered) {
                        untetherSatellite(this);
                        if (this.state === 'drifting') {
                            return;
                        }
                    }
                }

                if (this.state === 'drifting') {
                    if (this.isSatellite) {
                        const heartbeat = Math.sin(this.breathingPhase) * (this.heartbeatIntensity * 0.3);
                        this.baseRadius = 9;
                        this.targetRadius = this.baseRadius * (1 + heartbeat);
                        const targetColor = colors.satellite;
                        this.currentColor.r += (targetColor.r - this.currentColor.r) * colorTransitionSpeed;
                        this.currentColor.g += (targetColor.g - this.currentColor.g) * colorTransitionSpeed;
                        this.currentColor.b += (targetColor.b - this.currentColor.b) * colorTransitionSpeed;
                    }

                    this.x += this.driftVelocityX;
                    this.y += this.driftVelocityY;
                    this.driftVelocityX *= 0.995;
                    this.driftVelocityY = (this.driftVelocityY + SATELLITE_DRIFT_GRAVITY) * 0.995;

                    this.opacity = Math.max(0, this.opacity - SATELLITE_DRIFT_FADE_RATE);
                    this.radius += (this.targetRadius - this.radius) * 0.08;

                    this.time += 1;
                    this.spinnerAngle += 0.04;
                    this.ccRotation += 0.02;
                    this.breathingPhase += this.heartbeatRate * 0.5;
                    return;
                }

                if (this.state !== 'retracting') {
                    // Update settling phase for gradual physics integration
                    if (this.settlingPhase > 0) {
                        this.settlingPhase -= 16; // Assume ~60fps (16ms per frame)
                        this.physicsMultiplier = 0.3 + (0.7 * (1 - Math.max(0, this.settlingPhase) / 2000));
                    } else {
                        this.physicsMultiplier = 1.0; // Fully settled
                    }
                    
                    // Update heartbeat before calculating radius
                    this.updateHeartbeat();
                    
                    if (this.parent === null) { 
                        // Central node grows with connections like other nodes, but with larger minimum
                        const descendantCount = countDescendants(this);
                        this.baseRadius = 15 + Math.min(descendantCount * 1.5, 10);
                        
                        // Add organic breathing effect to central node
                        const heartbeat = Math.sin(this.breathingPhase) * this.heartbeatIntensity;
                        this.targetRadius = this.baseRadius * (1 + heartbeat);
                        
                        // Add pulse effect on top
                        this.targetRadius += this.pulseEffect * 28;
                        this.pulseEffect *= 0.92;
                        if (this.pulseEffect < 0.01) this.pulseEffect = 0;
                        
                        let targetColor = colors.blue;
                        if (this.status === 'malware') {
                            targetColor = colors.malware;
                        } else if (this.status === 'botnet') {
                            targetColor = colors.botnet;
                        } else if (this.status === 'commandControl') {
                            targetColor = colors.commandControl;
                        }
                        this.currentColor.r += (targetColor.r - this.currentColor.r) * colorTransitionSpeed;
                        this.currentColor.g += (targetColor.g - this.currentColor.g) * colorTransitionSpeed;
                        this.currentColor.b += (targetColor.b - this.currentColor.b) * colorTransitionSpeed;
                    } else {
                        if (this.isGroundStation) {
                            this.baseRadius = 22; // Fixed larger footprint for ground stations
                            const heartbeat = Math.sin(this.breathingPhase) * (this.heartbeatIntensity * 0.6);
                            this.targetRadius = this.baseRadius * (1 + heartbeat);

                            let targetColor = colors.groundStation;
                            switch (this.status) {
                                case 'red':
                                    targetColor = colors.red;
                                    break;
                                case 'yellow':
                                    targetColor = colors.yellow;
                                    break;
                                case 'malware':
                                    targetColor = colors.malware;
                                    break;
                                case 'botnet':
                                    targetColor = colors.botnet;
                                    break;
                                case 'commandControl':
                                    targetColor = colors.commandControl;
                                    break;
                                case 'green':
                                default:
                                    targetColor = colors.groundStation;
                                    break;
                            }

                            this.currentColor.r += (targetColor.r - this.currentColor.r) * colorTransitionSpeed;
                            this.currentColor.g += (targetColor.g - this.currentColor.g) * colorTransitionSpeed;
                            this.currentColor.b += (targetColor.b - this.currentColor.b) * colorTransitionSpeed;
                        } else if (this.isSatellite) {
                            this.baseRadius = 10;
                            const heartbeat = Math.sin(this.breathingPhase) * (this.heartbeatIntensity * 0.4);
                            this.targetRadius = this.baseRadius * (1 + heartbeat);
                            const targetColor = colors.satellite;
                            this.currentColor.r += (targetColor.r - this.currentColor.r) * colorTransitionSpeed;
                            this.currentColor.g += (targetColor.g - this.currentColor.g) * colorTransitionSpeed;
                            this.currentColor.b += (targetColor.b - this.currentColor.b) * colorTransitionSpeed;
                        } else {
                            const descendantCount = countDescendants(this);
                            this.baseRadius = 7 + Math.min(descendantCount * 1.5, 8);

                            // Dynamic heartbeat-based pulsing based on current state
                            const heartbeat = Math.sin(this.breathingPhase) * this.heartbeatIntensity;
                            
                            // Malware, botnet, and C&C nodes pulse larger, not smaller
                            if (this.status === 'malware' || this.status === 'botnet' || this.status === 'commandControl') {
                                this.targetRadius = this.baseRadius * (1.5 + heartbeat * 0.5); // Pulse between 1.2x and 1.8x
                            } else {
                                this.targetRadius = this.baseRadius * (1 + heartbeat);
                            }
                            
                            let targetColor = colors.green;
                            switch(this.status) {
                                case 'red': targetColor = colors.red; break;
                                case 'yellow': targetColor = colors.yellow; break;
                                case 'malware': targetColor = colors.malware; break;
                                case 'botnet': targetColor = colors.botnet; break;
                                case 'commandControl': targetColor = colors.commandControl; break;
                                case 'green': 
                                    // Use neon green for firewall nodes
                                    targetColor = this.hasFirewall ? colors.neonGreen : colors.green;
                                    break;
                            }
                            if (this.isGuardian) {
                                targetColor = colors.white;
                            }
                            this.currentColor.r += (targetColor.r - this.currentColor.r) * colorTransitionSpeed;
                            this.currentColor.g += (targetColor.g - this.currentColor.g) * colorTransitionSpeed;
                            this.currentColor.b += (targetColor.b - this.currentColor.b) * colorTransitionSpeed;
                        }
                    }
                }
                
                this.radius += (this.targetRadius - this.radius) * 0.05;
                
                if (this.state === 'alive') {
                    let springStrength, damping = 0.95;
                    if (this.parent === null) {
                        springStrength = 0.02; 
                        damping = 0.9;
                    } else {
                        springStrength = 0.001;
                    }
                    this.fx += (this.baseX - this.x) * springStrength;
                    this.fy += (this.baseY - this.y) * springStrength;
                    
                    if (this.parent !== null) {
                        const floatSpeed = 0.02;
                        const floatAmount = 0.01;
                        this.fx += Math.sin(this.time * floatSpeed + this.id) * floatAmount;
                        this.fy += Math.cos(this.time * floatSpeed + this.id) * floatAmount;
                    }

                    this.x += this.fx;
                    this.y += this.fy;
                    this.fx *= damping;
                    this.fy *= damping;

                    if (this.parent !== null) {
                        this.x = Math.max(padding, Math.min(canvas.width - padding, this.x));
                        this.y = Math.max(padding, Math.min(canvas.height - padding, this.y));
                    }
                }
                
                this.time += 1;
                this.spinnerAngle += 0.05;
                this.ccRotation += 0.02; // Rotate C&C danger ring
                this.breathingPhase += this.heartbeatRate;
                
                // Update shield logic
                this.updateShield();

                const SPIN_DURATION = 1200 / healSpeedMultiplier;
                const POP_DURATION = 300 / healSpeedMultiplier;

                if (this.remediationState === 'spinning') {
                    if (Date.now() - this.remediationStart > SPIN_DURATION) {
                        this.remediationState = 'popping';
                        this.remediationStart = Date.now();
                        createPopParticles(this.x, this.y, this.currentColor);
                    }
                } else if (this.remediationState === 'popping') {
                    const elapsed = Date.now() - this.remediationStart;
                    const progress = Math.min(1, elapsed / POP_DURATION);
                    
                    this.opacity = 1 - progress;
                    this.radius = this.baseRadius * (1 - progress);

                    if (progress >= 1) {
                        this.remediationState = 'none';
                        updateNodeStatus(this, 'green');
                        this.opacity = 1;
                        if (this.pendingDispatchPromotionCheck) {
                            this.pendingDispatchPromotionCheck = false;
                            if (!this.isGuardian && this.state === 'alive' && this.status === 'green' && Math.random() < 0.10) {
                                promoteToGuardian(this, 'guardianPromotionDispatch');
                            }
                        }
                    }
                }

                if (this.isSelfHealing) {
                    const SELF_HEAL_DURATION = 5000;
                    if (Date.now() > this.selfHealingStartTime + SELF_HEAL_DURATION) {
                        this.isSelfHealing = false;
                        this.selfHealingDispatchAllowance = 0;
                        this.selfHealingPacketsCreated = 0;
                        updateNodeStatus(this, 'blue');
                        
                        // Activate recovery shield for central node
                        if (this.parent === null) {
                            this.hasRecoveryShield = true;
                            this.recoveryShieldStartTime = Date.now();
                            this.shieldActive = true;
                            this.shieldOpacity = 0; // Will fade in via updateShield
                            this.shieldStrength = 1.0;
                            logEvent('recoveryShieldActivated', { node: this });
                        }
                    }
                }

                // Handle immunity healing
                if (this.isImmunityHealing && (this.status === 'malware' || this.status === 'botnet' || this.status === 'commandControl')) {
                    const numPackets = this.attachedImmunityPackets.length;
                    if (numPackets > 0) {
                        // Base healing time: 120 seconds for 1 packet
                        // More packets = faster healing (direct division)
                        // Supercharged packets count as 2 regular packets
                        const BASE_HEAL_TIME = 120000 / healSpeedMultiplier; // 120 seconds
                        
                        // Count regular and supercharged packets
                        let regularCount = 0;
                        let superchargedCount = 0;
                        this.attachedImmunityPackets.forEach(packet => {
                            if (packet.isSupercharged) {
                                superchargedCount++;
                            } else {
                                regularCount++;
                            }
                        });
                        
                        // Calculate effective packet count (supercharged = 2x regular)
                        // Reduced recovery modifier by half for slower healing
                        const effectivePackets = (regularCount + (superchargedCount * 2)) / 2;
                        const healTime = BASE_HEAL_TIME / effectivePackets;
                        
                        const elapsed = Date.now() - this.immunityHealingStartTime;
                        if (elapsed >= healTime) {
                            // Healing complete!
                            // Pop all attached immunity packets
                            this.attachedImmunityPackets.forEach(packet => {
                                if (packet.active) {
                                    packet.active = false;
                                    createPopParticles(packet.x, packet.y, colors.white);
                                }
                            });
                            this.attachedImmunityPackets = [];
                            
                            // Pop the node itself with white particles
                            createPopParticles(this.x, this.y, colors.white);
                            
                            // Heal the node
                            this.isImmunityHealing = false;
                            this.immunityHealingStartTime = 0;
                            logEvent('immunityHealingCompleted', { node: this });
                            // Central node heals to 'blue', other nodes to 'green'
                            const healedStatus = this.parent === null ? 'blue' : 'green';
                            updateNodeStatus(this, healedStatus);
                        }
                    } else {
                        // No packets attached anymore, stop healing
                        this.isImmunityHealing = false;
                        this.immunityHealingStartTime = 0;
                    }
                }

                // Handle infection logic
                this.spreadingInfections = this.spreadingInfections.filter(infection => {
                    const target = infection.target;
                    
                    // An attack is cancelled if the attacker is remediated, or the target becomes invalid.
                    if ((this.status !== 'malware' && this.status !== 'botnet' && this.status !== 'commandControl') || !target || target.state !== 'alive' || target.status === 'malware' || target.status === 'botnet' || target.status === 'commandControl') {
                        if (target) target.isBeingInfected = false;
                        return false; // remove this infection
                    } 
                    
                    const elapsed = Date.now() - infection.startTime;
                    
                    if (target.parent === null) {
                        const ATTACK_DURATION = 1500;
                        const DEFENSE_DELAY = 1500;
                        // FIX: Check if defense has been attempted for this specific attack instance to prevent double-hits
                        if (elapsed > DEFENSE_DELAY && !infection.defenseTriggered && target.status !== 'malware') {
                            // Mark this attack instance as having triggered a defense, preventing re-triggers.
                            infection.defenseTriggered = true;

                            // Trigger the defense pulse animation regardless of success or failure.
                            target.isDefending = true;
                            target.defenseStartTime = Date.now();
                            
                            // Now, determine the outcome.
                            // Recovery shield provides 99% resistance (1% failure), otherwise 10% failure
                            const failureChance = target.hasRecoveryShield ? 0.01 : 0.1;
                            if (target.hasRecoveryShield) {
                                logEvent('recoveryShieldAttack', { target });
                            }
                            if (Math.random() < failureChance) {
                                updateNodeStatus(target, 'malware');
                                // If recovery shield was active but failed, it shatters
                                if (target.hasRecoveryShield) {
                                    target.hasRecoveryShield = false;
                                    target.shieldCracking = true;
                                    target.shieldCrackProgress = 0;
                                    target.createShieldFragments();
                                }
                            } else {
                                // Defense successful! Only spawn immunity packets if in bot defense mode
                                if (target.botDefenseModeActive) {
                                    spawnCentralImmunityPackets(target);
                                }
                            }
                        }
                        // The infection object is removed after the attack animation (advance + retreat) is complete
                        if (elapsed > ATTACK_DURATION + 1000) {
                            return false; // remove this infection
                        }
                    } else { 
                        // Regular infection timing
                        const INFECTION_DURATION = 4000;
                        const BASE_DEFENSE_CHANCE = 0.25;
                        
                        // Apply size-based defense bonus
                        const defenseBonus = getNodeDefenseBonus(target);
                        const defenseCap = target.isGuardian ? 0.95 : 0.75;
                        const DEFENSE_CHANCE = Math.min(BASE_DEFENSE_CHANCE + defenseBonus, defenseCap);

                        if (elapsed > INFECTION_DURATION) {
                            if (Math.random() < DEFENSE_CHANCE) {
                                target.isDefending = true;
                                target.defenseStartTime = Date.now();
                                logEvent('nodeDefended', { node: target });
                                incrementStat('totalDefenses');
                            } else {
                                updateNodeStatus(target, 'malware');
                                logEvent('nodeInfected', { node: target });
                                incrementStat('totalInfections');
                            }
                            target.isBeingInfected = false;
                            return false; // remove this infection
                        }
                    }
                    return true; // keep this infection
                });
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 + 1;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.radius = Math.random() * 2 + 1;
                this.life = 30 + Math.random() * 30; // Reduced from 50-100 to 30-60 for better performance
                this.initialLife = this.life;
                this.color = color;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.98;
                this.vy *= 0.98;
                this.life -= 1;
            }

            draw() {
                if (this.life <= 0) return;
                const opacity = this.life / this.initialLife;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${opacity})`;
                ctx.fill();
            }
        }

        class DataPacket {
            constructor(edge, direction = 1) {
                this.edge = edge;
                this.direction = direction; // 1 = from->to, -1 = to->from
                this.progress = direction === 1 ? 0 : 1;
                this.active = true;
                
                // Calculate initial position immediately to avoid (0,0) spawn
                const fromNode = edge.from;
                const toNode = edge.to;
                if (fromNode && toNode) {
                    const dx = toNode.x - fromNode.x;
                    const dy = toNode.y - fromNode.y;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    
                    if (length > 0) {
                        const baseX = fromNode.x + dx * this.progress;
                        const baseY = fromNode.y + dy * this.progress;
                        const perpX = -dy / length;
                        const perpY = dx / length;
                        const lateralOffset = direction === 1 ? 3 : -3;
                        
                        this.x = baseX + perpX * lateralOffset;
                        this.y = baseY + perpY * lateralOffset;
                    } else {
                        // Fallback to node position if edge has zero length
                        this.x = fromNode.x;
                        this.y = fromNode.y;
                    }
                } else {
                    // Fallback if nodes are invalid
                    this.x = 0;
                    this.y = 0;
                }
                
                // Check if this is infected traffic between malware/botnet nodes
                const fromMalware = edge.from && (edge.from.status === 'malware' || edge.from.status === 'botnet' || edge.from.status === 'commandControl');
                const toMalware = edge.to && (edge.to.status === 'malware' || edge.to.status === 'botnet' || edge.to.status === 'commandControl');
                
                if (fromMalware && toMalware) {
                    // Infected packet traveling between malware nodes
                    this.type = 'infected';
                    this.color = { r: 168, g: 85, b: 247 }; // Purple (malware color)
                    this.radius = 2;
                } else {
                    // Normal packet types: 'data', 'control', 'security'
                    const rand = Math.random();
                    if (rand < 0.6) {
                        this.type = 'data';
                        this.color = { r: 100, g: 200, b: 255 }; // Light blue
                        this.radius = 2;
                    } else if (rand < 0.85) {
                        this.type = 'control';
                        this.color = { r: 150, g: 255, b: 150 }; // Light green
                        this.radius = 2;
                    } else {
                        this.type = 'security';
                        this.color = { r: 255, g: 200, b: 100 }; // Golden
                        this.radius = 2;
                    }
                }
                
                // Calculate edge length for speed normalization using base positions
                // Use baseX/baseY since nodes might still be animating to their final positions
                const dx = edge.to.baseX - edge.from.baseX;
                const dy = edge.to.baseY - edge.from.baseY;
                const edgeLength = Math.sqrt(dx * dx + dy * dy);
                
                // Normalize speed: longer edges = faster progress
                // Target: ~1.0 pixel per frame at 60fps for consistent visual velocity
                const PIXELS_PER_FRAME = 1.0;
                
                // Base speed gives us the progress per frame
                // For consistent visual speed, adjust based on edge length
                this.baseSpeed = edgeLength > 0 ? PIXELS_PER_FRAME / edgeLength : 0.003;
                this.speed = this.baseSpeed * packetSpeedMultiplier;
                this.opacity = 0.8;
                
                // Offset to side of line for bidirectional flow
                this.lateralOffset = direction === 1 ? 3 : -3;
                
                // Drifting state for when edge is removed
                this.isDrifting = false;
                this.driftVelocityX = 0;
                this.driftVelocityY = 0;
                
                // Jitter state for unstable links
                this.jitterX = 0;
                this.jitterY = 0;
                
                // Drop check - only perform once per packet
                this.dropCheckPerformed = false;
            }

            update() {
                // Check if edge has been removed from edges array (due to remeshing)
                const edgeExists = edges.includes(this.edge);
                
                if (!edgeExists || !this.edge.from || !this.edge.to || 
                    this.edge.from.state !== 'alive' || this.edge.to.state !== 'alive') {
                    // Enter drifting mode instead of immediately deactivating
                    if (!this.isDrifting) {
                        this.isDrifting = true;
                        // Scatter in a random direction
                        const randomAngle = Math.random() * Math.PI * 2;
                        const driftSpeed = 1 + Math.random() * 2; // Random speed between 1 and 3
                        this.driftVelocityX = Math.cos(randomAngle) * driftSpeed;
                        this.driftVelocityY = Math.sin(randomAngle) * driftSpeed;
                        
                        // Count as dropped packet
                        incrementStat('packetsDropped');
                    }
                    
                    // Continue drifting
                    if (this.isDrifting) {
                        this.x += this.driftVelocityX;
                        this.y += this.driftVelocityY;
                        this.opacity -= 0.04; // Fade out twice as fast (was 0.02)
                        
                        if (this.opacity <= 0) {
                            this.active = false;
                        }
                    } else {
                        this.active = false;
                    }
                    return;
                }

                // Adjust speed based on link status and packet type
                const fromNode = this.edge.from;
                const toNode = this.direction === 1 ? this.edge.to : this.edge.from;
                
                // Don't adjust speed/opacity for drifting packets - they're fading out
                if (!this.isDrifting) {
                    // Immunity packets glow bright and move fast
                    if (this.type === 'immunity') {
                        this.speed = this.baseSpeed * 1.5 * packetSpeedMultiplier; // Faster for infected traffic
                        this.opacity = 0.8; // 80% opacity
                    } else if (toNode.status === 'red' || toNode.status === 'malware' || toNode.status === 'botnet' || toNode.status === 'commandControl') {
                        this.speed = this.baseSpeed * 0.4 * packetSpeedMultiplier; // Slow when link is compromised
                        this.opacity = 0.8; // 80% opacity
                    } else if (toNode.status === 'yellow') {
                        this.speed = this.baseSpeed * 0.7 * packetSpeedMultiplier; // Moderate when stressed
                        this.opacity = 0.8; // 80% opacity
                    } else {
                        this.speed = this.baseSpeed * packetSpeedMultiplier; // Normal speed when healthy
                        this.opacity = 0.8; // 80% opacity
                    }
                    
                    // Apply DDOS slowdown to packets in affected branches
                    if (isNodeInDDOSBranch(toNode) || isNodeInDDOSBranch(fromNode)) {
                        // Data packets are severely slowed during DDOS
                        this.speed *= 0.15; // 85% slower
                        this.opacity = 0.4; // Dim to show degraded service
                    }
                }
                
                // Calculate drop chance and jitter based on link status (only once per packet)
                if (!this.dropCheckPerformed) {
                    this.dropCheckPerformed = true;
                    
                    let dropChance = 0;
                    const isMalwarePacket = this.type === 'infected';
                    
                    // Check link conditions
                    const isDDOS = isNodeInDDOSBranch(toNode) || isNodeInDDOSBranch(fromNode);
                    const isBotnetLink = toNode.status === 'botnet' || fromNode.status === 'botnet';
                    const isMalwareLink = toNode.status === 'malware' || fromNode.status === 'malware';
                    
                    if (isDDOS && !isMalwarePacket) {
                        dropChance = 0.75; // 75% drop chance during DDOS
                    } else if (isBotnetLink && !isMalwarePacket) {
                        dropChance = 0.50; // 50% drop chance on botnet links
                    } else if (isMalwareLink && !isMalwarePacket) {
                        dropChance = 0.25; // 25% drop chance on infected links
                    }
                    
                    // Check for packet drop (one-time check)
                    if (dropChance > 0 && Math.random() < dropChance) {
                        // Packet dropped - enter drift mode
                        this.isDrifting = true;
                        const randomAngle = Math.random() * Math.PI * 2;
                        const driftSpeed = 0.5 + Math.random() * 1;
                        this.driftVelocityX = Math.cos(randomAngle) * driftSpeed;
                        this.driftVelocityY = Math.sin(randomAngle) * driftSpeed;
                        incrementStat('packetsDropped');
                        return;
                    }
                }
                
                // If already drifting, continue drifting
                if (this.isDrifting) {
                    this.x += this.driftVelocityX;
                    this.y += this.driftVelocityY;
                    this.opacity -= 0.04;
                    if (this.opacity <= 0) {
                        this.active = false;
                    }
                    return;
                }
                
                // Apply jitter for unstable links
                let hasJitter = false;
                const isMalwarePacket = this.type === 'infected';
                const isDDOS = isNodeInDDOSBranch(toNode) || isNodeInDDOSBranch(fromNode);
                const isBotnetLink = toNode.status === 'botnet' || fromNode.status === 'botnet';
                const isMalwareLink = toNode.status === 'malware' || fromNode.status === 'malware';
                
                if (!isMalwarePacket && (isDDOS || isBotnetLink || isMalwareLink)) {
                    hasJitter = true;
                }
                
                // Apply jitter if link is unstable
                if (hasJitter) {
                    // Random jitter movement perpendicular to travel direction
                    const jitterAmount = 2 + Math.random() * 3; // 2-5 pixels
                    this.jitterX = (Math.random() - 0.5) * jitterAmount;
                    this.jitterY = (Math.random() - 0.5) * jitterAmount;
                } else {
                    this.jitterX = 0;
                    this.jitterY = 0;
                }

                // Only update progress if not drifting
                if (!this.isDrifting) {
                    // Update progress
                    if (this.direction === 1) {
                        this.progress += this.speed;
                        if (this.progress >= 1) {
                            this.active = false;
                            // Count as successfully received
                            incrementStat('packetsReceived');
                        }
                    } else {
                        this.progress -= this.speed;
                        if (this.progress <= 0) {
                            this.active = false;
                            // Count as successfully received
                            incrementStat('packetsReceived');
                        }
                    }
                }

                // Calculate position along the edge (reuse fromNode from above)
                // Skip if drifting - position is updated by drift velocity
                if (!this.isDrifting) {
                    const toNodeDest = this.edge.to;
                    const dx = toNodeDest.x - fromNode.x;
                    const dy = toNodeDest.y - fromNode.y;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    
                    if (length > 0) {
                        // Position along the line
                        const baseX = fromNode.x + dx * this.progress;
                        const baseY = fromNode.y + dy * this.progress;
                        
                        // Calculate perpendicular offset
                        const perpX = -dy / length;
                        const perpY = dx / length;
                        
                        // Apply lateral offset and jitter
                        this.x = baseX + perpX * this.lateralOffset + this.jitterX;
                        this.y = baseY + perpY * this.lateralOffset + this.jitterY;
                    }
                }
            }

            draw() {
                if (!this.active) return;
                
                ctx.save();
                
                // Infected packets get stronger glow for visibility
                if (this.type === 'infected') {
                    ctx.shadowColor = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 1)`;
                    ctx.shadowBlur = 8;
                } else {
                    // Subtle glow for normal packets
                    ctx.shadowColor = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.opacity})`;
                    ctx.shadowBlur = 4;
                }
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.opacity})`;
                ctx.fill();
                
                ctx.restore();
            }
        }

        Node.prototype.startRemediation = function() {
            if (this.remediationState !== 'none') return;
            this.remediationState = 'spinning';
            this.remediationStart = Date.now();
            logEvent('remediationStarted', { node: this });
        }

        class ImmunityPacket {
            constructor(edge, direction = 1) {
                this.edge = edge;
                this.direction = direction; // 1 = from->to, -1 = to->from
                this.progress = direction === 1 ? 0 : 1;
                this.x = 0;
                this.y = 0;
                this.active = true;
                this.color = { ...colors.white };
                this.radius = 1.5;
                this.baseSpeed = 0.002; // Slower than data packets
                this.speed = this.baseSpeed * packetSpeedMultiplier;
                this.opacity = 0.9;
                this.lateralOffset = direction === 1 ? 5 : -5;
                
                // Attachment state
                this.isAttached = false;
                this.attachedNode = null;
                this.attachmentAngle = 0; // Angle around the node
                this.attachmentDistance = 0; // Distance from node center
                
                // Seeking behavior
                this.targetNode = null; // Infected node to seek
                this.isSeeking = false;
                
                // Supercharged property (for burst packets from central node)
                this.isSupercharged = false;
                this.pulsePhase = Math.random() * Math.PI * 2; // Random starting phase for pulse
                
                // Emergency lights effect (red/white alternating like fire truck/ambulance)
                this.flashPhase = Math.random() * Math.PI * 2; // Random starting phase for variety
            }

            update() {
                // If attached to a node, cling to its perimeter
                if (this.isAttached && this.attachedNode) {
                    const isCentralNode = this.attachedNode.parent === null;
                    const isInfected = this.attachedNode.status === 'malware' || this.attachedNode.status === 'botnet' || this.attachedNode.status === 'commandControl';
                    
                    // Check if node can still hold packets
                    if (!isInfected && !isCentralNode) {
                        // Node is healed (regular node) or no longer valid, packet should pop
                        this.active = false;
                        createPopParticles(this.x, this.y, this.color);
                        return;
                    }
                    
                    // Calculate base angle based on current position in the array (for even distribution)
                    const packetIndex = this.attachedNode.attachedImmunityPackets.indexOf(this);
                    let baseAngle = 0;
                    if (packetIndex !== -1) {
                        const totalPackets = this.attachedNode.attachedImmunityPackets.length;
                        baseAngle = (packetIndex / totalPackets) * Math.PI * 2;
                    }
                    
                    // Add slow clockwise rotation (0.01 radians per frame)
                    // Use node's time for synchronized rotation
                    const rotationSpeed = 0.01;
                    const rotationOffset = this.attachedNode.time * rotationSpeed;
                    this.attachmentAngle = baseAngle + rotationOffset;
                    
                    // Cling to the current radius of the node (which pulses)
                    const distance = this.attachedNode.radius + 5;
                    this.x = this.attachedNode.x + Math.cos(this.attachmentAngle) * distance;
                    this.y = this.attachedNode.y + Math.sin(this.attachmentAngle) * distance;
                    return;
                }
                
                // Check if edge still exists
                const edgeExists = edges.includes(this.edge);
                if (!edgeExists || !this.edge.from || !this.edge.to || 
                    this.edge.from.state !== 'alive' || this.edge.to.state !== 'alive') {
                    this.active = false;
                    return;
                }

                // Check for nearby infected nodes to attach to
                const fromNode = this.edge.from;
                const toNode = this.edge.to;
                
                // Calculate current position first
                const dx = toNode.x - fromNode.x;
                const dy = toNode.y - fromNode.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                
                if (length > 0) {
                    const baseX = fromNode.x + dx * this.progress;
                    const baseY = fromNode.y + dy * this.progress;
                    const perpX = -dy / length;
                    const perpY = dx / length;
                    const offset = this.isSupercharged ? 0 : this.lateralOffset;
                    this.x = baseX + perpX * offset;
                    this.y = baseY + perpY * offset;
                }
                
                // Check if we're near a node that can collect immunity packets
                const checkNode = (node) => {
                    if (node.isGuardian) {
                        return false; // Guardians let immunity packets pass through
                    }
                    const isCentralNode = node.parent === null;
                    const isInfected = node.status === 'malware' || node.status === 'botnet' || node.status === 'commandControl';
                    
                    // If seeking a specific target, only attach to that target
                    if (this.isSeeking && this.targetNode) {
                        if (node !== this.targetNode) {
                            // Supercharged packets no longer roam - they must hit their target
                            // If they encounter a firewall node, it absorbs them
                            if (this.isSupercharged && node.hasFirewall && node.status === 'green' && node.state === 'alive') {
                                // Firewall absorbs the missed supercharged packet
                                return true; // Attach to firewall and stop
                            }
                            return false; // Not our target, skip
                        } else {
                            // Target must be infected to attach
                            if (!isInfected || node.state !== 'alive') {
                                // Target is no longer valid
                                // Supercharged packets are absorbed by first firewall they encounter
                                if (this.isSupercharged) {
                                    // Find first firewall node to absorb
                                    const firewallNode = nodes.find(n => 
                                        n.hasFirewall && 
                                        n.status === 'green' && 
                                        n.state === 'alive' &&
                                        Math.sqrt((this.x - n.x) ** 2 + (this.y - n.y) ** 2) < 200
                                    );
                                    if (firewallNode) {
                                        this.targetNode = firewallNode;
                                        return false; // Continue seeking firewall
                                    }
                                }
                                this.isSeeking = false;
                                this.targetNode = null;
                                return false;
                            }
                        }
                    } else {
                        // Normal collection logic
                        // Central node can collect when healthy (blue) or infected
                        // Regular nodes can only collect when infected
                        const canCollect = node.state === 'alive' && (
                            (isCentralNode && (node.status === 'blue' || isInfected)) ||
                            (!isCentralNode && isInfected)
                        );
                        
                        if (!canCollect) {
                            return false;
                        }
                    }
                    
                    // Check if node already has maximum packets (20 for central node, 20 for infected nodes, 10 for healthy nodes)
                    const maxPackets = (isCentralNode || isInfected) ? 20 : 10;
                    if (node.attachedImmunityPackets.length >= maxPackets) {
                        return false; // Node is full, can't attach
                    }
                    
                    const distToNode = Math.sqrt((this.x - node.x) ** 2 + (this.y - node.y) ** 2);
                    if (distToNode < node.radius + 15) {
                        // Attach to this node
                        this.isAttached = true;
                        this.attachedNode = node;
                        this.isSeeking = false; // Clear seeking state
                        this.targetNode = null;
                        
                        // Add to node's attached packets
                        if (!node.attachedImmunityPackets.includes(this)) {
                            node.attachedImmunityPackets.push(this);

                            // Calculate initial angle based on position in array
                            const packetIndex = node.attachedImmunityPackets.length - 1;
                            this.attachmentAngle = (packetIndex / node.attachedImmunityPackets.length) * Math.PI * 2;

                            if (isCentralNode) {
                                this.isSupercharged = true;
                                this.radius = Math.max(this.radius, 3);
                            }
                            
                            // Compounding logic for infected nodes (not central node)
                            if (!isCentralNode && isInfected) {
                                const currentCount = node.attachedImmunityPackets.length;
                                
                                // Once we have more than 10 packets, convert a regular packet to supercharged
                                if (currentCount > 10 && currentCount <= 20) {
                                    // Find the first regular (non-supercharged) packet to upgrade
                                    const regularPacket = node.attachedImmunityPackets.find(p => !p.isSupercharged);
                                    if (regularPacket) {
                                        regularPacket.isSupercharged = true;
                                        regularPacket.radius = Math.max(regularPacket.radius, 3);
                                        logEvent('immunityPacketUpgraded', { 
                                            node, 
                                            totalPackets: currentCount,
                                            superchargedCount: node.attachedImmunityPackets.filter(p => p.isSupercharged).length
                                        });
                                    }
                                }
                            }

                            // Start healing if infected and not already healing
                            if (isInfected && !node.isImmunityHealing) {
                                node.isImmunityHealing = true;
                                node.immunityHealingStartTime = Date.now();
                                logEvent('immunityHealingStarted', { node, packetCount: node.attachedImmunityPackets.length });
                            }
                        }
                        return true;
                    }
                    return false;
                };
                
                // If seeking, check target node first
                if (this.isSeeking && this.targetNode && checkNode(this.targetNode)) {
                    return;
                }
                
                // Otherwise check nearby nodes
                if (checkNode(fromNode) || checkNode(toNode)) {
                    return;
                }
                
                // Apply DDOS slowdown to immunity packets in affected branches
                const currentFromNode = this.edge.from;
                const currentToNode = this.edge.to;
                let effectiveSpeed = this.speed;
                if (isNodeInDDOSBranch(currentToNode) || isNodeInDDOSBranch(currentFromNode)) {
                    effectiveSpeed *= 0.15; // Severely slowed during DDOS
                }
                
                // Normal movement along edge
                if (this.direction === 1) {
                    this.progress += effectiveSpeed;
                    if (this.progress >= 1) {
                        const endNode = this.edge.to;
                        
                        // Check if node is dead/invalid
                        if (!endNode || endNode.state !== 'alive') {
                            this.active = false;
                            return;
                        }
                        
                        // All packets try to continue forward on random routes
                        // Central node consumes all packets (don't bounce back)
                        if (endNode.parent === null) {
                            // Packet reached central node, let it be consumed
                            // It will be collected via the checkNode logic above
                            this.active = false;
                        } else {
                            // Try to find available edges to continue (children or siblings)
                            const availableEdges = edges.filter(edge => 
                                edge.from === endNode && 
                                edge.to.state === 'alive' &&
                                edge.to !== this.edge.from // Don't go back immediately
                            );
                            
                            if (availableEdges.length > 0) {
                                // Pick a random edge and continue
                                const randomEdge = availableEdges[Math.floor(Math.random() * availableEdges.length)];
                                this.edge = randomEdge;
                                this.progress = 0;
                                this.direction = 1;
                                // Keep same lateral offset direction
                            } else {
                                // No available paths forward, drop the packet
                                this.active = false;
                            }
                        }
                    }
                } else {
                    this.progress -= effectiveSpeed;
                    if (this.progress <= 0) {
                        const startNode = this.edge.from;
                        
                        // Check if node is dead/invalid
                        if (!startNode || startNode.state !== 'alive') {
                            this.active = false;
                            return;
                        }
                        
                        // At central node, consume the packet (don't bounce back)
                        if (startNode.parent === null) {
                            // Packet reached central node, let it be consumed
                            this.active = false;
                        } else {
                            // Try to find available edges (parent or siblings)
                            const availableEdges = edges.filter(edge => 
                                edge.from === startNode && 
                                edge.to.state === 'alive' &&
                                edge.to !== this.edge.to // Don't go back immediately
                            );
                            
                            if (availableEdges.length > 0) {
                                // Pick a random edge and continue
                                const randomEdge = availableEdges[Math.floor(Math.random() * availableEdges.length)];
                                this.edge = randomEdge;
                                this.progress = 0;
                                this.direction = 1;
                            } else {
                                // No available paths, drop the packet
                                this.active = false;
                            }
                        }
                    }
                }
            }

            draw() {
                if (!this.active) return;
                
                ctx.save();
                
                // Check if attached to central node
                const isAttachedToCentral = this.isAttached && this.attachedNode && this.attachedNode.parent === null;
                
                // Supercharged packets OR packets attached to central node pulse with neon yellow
                if (this.isSupercharged || isAttachedToCentral) {
                    // Always update pulse phase for smooth animation
                    if (!this.pulsePhase) this.pulsePhase = Math.random() * Math.PI * 2;
                    this.pulsePhase += 0.15; // Faster pulsing
                    const pulseFactor = 0.5 + Math.sin(this.pulsePhase) * 0.5; // Oscillates 0-1
                    
                    // Pulsing bright neon yellow for high visibility
                    const brightYellow = { r: 255, g: 255, b: 0 }; // Pure bright yellow
                    const neonYellow = { r: 255, g: 255, b: 100 }; // Slightly greenish yellow for variety
                    const r = brightYellow.r + (neonYellow.r - brightYellow.r) * pulseFactor;
                    const g = brightYellow.g + (neonYellow.g - brightYellow.g) * pulseFactor;
                    const b = brightYellow.b + (neonYellow.b - brightYellow.b) * pulseFactor;
                    
                    // Intense neon glow for supercharged packets
                    ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 1)`;
                    ctx.shadowBlur = 25 + pulseFactor * 20; // Much brighter glow
                    
                    // Draw with pulsing neon yellow
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${this.opacity})`;
                    ctx.fill();
                } else {
                    // Emergency lights effect - alternate between bright red and white smoothly
                    this.flashPhase += 0.15; // Fast flashing speed
                    
                    // Use sine wave to create smooth red-white-red transitions
                    // Sine oscillates between -1 and 1, we map to 0-1
                    const flashValue = (Math.sin(this.flashPhase) + 1) / 2; // 0 = red, 1 = white
                    
                    // Interpolate between bright pure red and white for high visibility
                    const brightRed = { r: 255, g: 0, b: 0 }; // Pure bright red
                    const brightWhite = { r: 255, g: 255, b: 255 }; // Pure white
                    const r = brightRed.r + (brightWhite.r - brightRed.r) * flashValue;
                    const g = brightRed.g + (brightWhite.g - brightRed.g) * flashValue;
                    const b = brightRed.b + (brightWhite.b - brightRed.b) * flashValue;
                    
                    // Enhanced glow that pulses with the color - brighter and more intense
                    ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 1)`;
                    ctx.shadowBlur = 18 + flashValue * 12;
                    
                    // Draw emergency light packet
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${this.opacity})`;
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }

        function buildNodePath(origin, target) {
            const actualOrigin = origin || nodes[0];
            if (!actualOrigin || !target) return [];

            const ancestorSet = new Set();
            let current = actualOrigin;
            while (current) {
                ancestorSet.add(current);
                current = current.parent;
            }

            const downwardPath = [];
            current = target;
            while (current && !ancestorSet.has(current)) {
                downwardPath.push(current);
                current = current.parent;
            }

            if (!current) {
                return [];
            }

            const lca = current;
            const path = [];
            current = actualOrigin;
            while (current && current !== lca) {
                path.push(current);
                current = current.parent;
            }

            if (!current) {
                return [];
            }

            path.push(current); // include LCA once

            for (let i = downwardPath.length - 1; i >= 0; i--) {
                path.push(downwardPath[i]);
            }

            return path;
        }

        class DispatchPacket {
            constructor(targetNode, originNode = null) {
                this.origin = originNode || nodes[0];
                this.target = targetNode;
                this.path = buildNodePath(this.origin, targetNode);
                if (!this.path.length) {
                    this.state = 'finished';
                    return;
                }
                this.progress = 0;
                // Variable speed: between 0.0046875 and 0.009375
                const minSpeed = 0.0046875;
                const maxSpeed = 0.009375;
                const baseSpeed = minSpeed + Math.random() * (maxSpeed - minSpeed);
                const pathLength = Math.max(1, this.path.length - 1); // Number of segments
                this.speed = (baseSpeed / pathLength) * packetSpeedMultiplier; // Longer paths = slower progress per frame
                this.radius = 2.5; // Dispatch packet size (reduced by 50%)
                this.x = this.path[0].x;
                this.y = this.path[0].y;
                this.state = 'active';
            }

            update() {
                if (this.state !== 'active') return;

                // Apply DDOS slowdown if target node is in affected branch
                let effectiveSpeed = this.speed;
                if (this.target && isNodeInDDOSBranch(this.target)) {
                    effectiveSpeed *= 0.15; // Dispatch packets severely slowed during DDOS
                }
                
                this.progress += effectiveSpeed;

                // First, check for successful arrival
                if (this.progress >= 1) {
                    this.progress = 1;
                    this.state = 'finished';
                    this.x = this.target.x;
                    this.y = this.target.y;

                    if (this.target.remediationState === 'none' && this.target.state === 'alive' && (this.target.status === 'malware' || this.target.status === 'botnet' || this.target.status === 'commandControl')) {
                        // C&C nodes are hardest to remediate (40%), botnet (25%), regular malware (10%)
                        let baseDefenseChance = 0.10;
                        if (this.target.status === 'botnet') baseDefenseChance = 0.25;
                        if (this.target.status === 'commandControl') baseDefenseChance = 0.40;

                        // Apply size-based defense bonus
                        const defenseBonus = getNodeDefenseBonus(this.target);
                        const defenseCap = this.target.isGuardian ? 0.95 : 0.75;
                        const defenseChance = Math.min(baseDefenseChance + defenseBonus, defenseCap);

                        if (Math.random() < defenseChance) {
                            this.target.isDefending = true;
                            this.target.defenseStartTime = Date.now();
                        } else {
                            this.target.startRemediation();
                            // Flag for post-remediation guardian promotion check
                            this.target.pendingDispatchPromotionCheck = true;
                            logEvent('dispatchSuccessful', { target: this.target });
                        }
                    }
                    return;
                }

                // For packets still in transit, calculate position and check for abort conditions
                const totalLength = this.path.length - 1;
                if (totalLength <= 0) { 
                    this.state = 'finished';
                    return;
                }

                const clampedProgress = this.progress;
                const currentSegmentIndex = Math.floor(clampedProgress * totalLength);
                const segmentProgress = (clampedProgress * totalLength) - currentSegmentIndex;
                const fromNode = this.path[currentSegmentIndex];
                const toNode = this.path[currentSegmentIndex + 1];

                // Update position before checking for failures to ensure pop happens at the right spot
                if (fromNode && toNode) {
                    this.x = fromNode.x + (toNode.x - fromNode.x) * segmentProgress;
                    this.y = fromNode.y + (toNode.y - fromNode.y) * segmentProgress;
                } else {
                    // Fallback pop if path is somehow invalid
                    createPopParticles(this.x, this.y, colors.gold);
                    this.state = 'finished';
                    this.target.isTargeted = false;
                    return;
                }

                // Check for abort conditions
                const isPhysicallyBroken = this.path.some(node => node.state === 'retracting');
                const remainingPath = this.path.slice(currentSegmentIndex + 1);
                const isLogicallyBlocked = remainingPath.some(node => node.status === 'red' || node.status === 'yellow');
                
                // NEW: Check if any node in the path has become infected (excluding root and target)
                // Only the first infected node in a chain should be targeted, so if any upstream
                // or intermediate node becomes infected, cancel this dispatch packet
                const intermediateNodes = this.path.slice(1, -1); // All nodes except root and target
                const hasUpstreamInfection = intermediateNodes.some(node => node.status === 'malware' || node.status === 'botnet' || node.status === 'commandControl');
                
                if (isPhysicallyBroken || isLogicallyBlocked || hasUpstreamInfection) {
                    // Only create particles if path is blocked by infection or status, not retraction
                    // Retraction happens during cleanup, so we silently remove the pulse
                    if (!isPhysicallyBroken) {
                        createPopParticles(this.x, this.y, colors.gold);
                        // Log dispatch blocked if it's due to infected nodes
                        if (isLogicallyBlocked || hasUpstreamInfection) {
                            logEvent('dispatchBlocked', { target: this.target });
                        }
                    }
                    this.state = 'finished';
                    this.target.isTargeted = false; // Allow a new pulse to be sent
                    return;
                }
            }


            draw() {
                if (this.state === 'finished') return;

                // Orb color
                const goldColor = `rgba(${colors.gold.r}, ${colors.gold.g}, ${colors.gold.b}, 1)`;
                
                // Pulsing light effect
                const now = Date.now();
                const cycle = 1000; // Time in ms for a full red-blue pulse cycle
                const progress = (now % cycle) / cycle;
                
                let pulseColor, pulseRadius;
                
                const basePulseRadius = this.radius * 2.5;
                const pulseRange = this.radius * 2;

                if (progress < 0.5) {
                    // First half: Red pulse expands and fades
                    const redProgress = progress * 2;
                    pulseColor = `rgba(${colors.red.r}, ${colors.red.g}, ${colors.red.b}, ${0.7 * (1 - redProgress)})`;
                    pulseRadius = basePulseRadius + pulseRange * redProgress;
                } else {
                    // Second half: Blue pulse expands and fades
                    const blueProgress = (progress - 0.5) * 2;
                    pulseColor = `rgba(${colors.blue.r}, ${colors.blue.g}, ${colors.blue.b}, ${0.7 * (1 - blueProgress)})`;
                    pulseRadius = basePulseRadius + pulseRange * blueProgress;
                }

                ctx.save();

                // Draw the expanding pulse
                ctx.beginPath();
                ctx.arc(this.x, this.y, pulseRadius, 0, Math.PI * 2);
                ctx.fillStyle = pulseColor;
                ctx.fill();
                
                // Draw the central dispatch packet
                ctx.shadowColor = `rgba(${colors.gold.r}, ${colors.gold.g}, ${colors.gold.b}, 0.7)`;
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = goldColor;
                ctx.fill();

                ctx.restore();
            }
        }

        class PingOfDeath {
            constructor(sourceNode, targetNode) {
                this.source = sourceNode;
                this.target = targetNode;
                this.path = this.findPath(sourceNode, targetNode);
                this.progress = 0;
                // Increased by 125% from 0.00375 to 0.0084375
                // Now faster than dispatch packet (0.003) and approaching original speed (0.012)
                this.speed = 0.0084375 * packetSpeedMultiplier;
                this.radius = 6;
                this.x = sourceNode.x;
                this.y = sourceNode.y;
                this.state = 'active';
                this.spikes = 8; // Number of spikes around the packet
                this.spikeRotation = 0;
                this.electricArcs = []; // Electric arc effects
                this.trail = []; // Trail to show path taken
                this.maxTrailLength = 15; // Maximum trail points
                this.lastSegmentIndex = -1; // Track which segment we're on for path recalculation
                this.checkedFirewallNodes = new Set(); // Track which firewall nodes we've already checked
                
                // Initialize electric arcs
                for (let i = 0; i < 3; i++) {
                    this.electricArcs.push({
                        angle: Math.random() * Math.PI * 2,
                        length: 0,
                        maxLength: this.radius * 2,
                        speed: 0.3 + Math.random() * 0.3
                    });
                }
            }

            // BFS pathfinding that can traverse through any node
            findPath(start, target) {
                if (start === target) return [start];
                
                const queue = [[start]];
                const visited = new Set([start.id]);
                
                while (queue.length > 0) {
                    const path = queue.shift();
                    const current = path[path.length - 1];
                    
                    // Get all connected nodes (parent, children, mesh connections)
                    const neighbors = [...current.children];
                    if (current.parent) neighbors.push(current.parent);
                    
                    // Add mesh-connected nodes
                    edges.forEach(edge => {
                        if (edge.isBotnetMesh) {
                            if (edge.from === current && !neighbors.includes(edge.to)) {
                                neighbors.push(edge.to);
                            } else if (edge.to === current && !neighbors.includes(edge.from)) {
                                neighbors.push(edge.from);
                            }
                        }
                    });
                    
                    for (const neighbor of neighbors) {
                        if (!neighbor || neighbor.state !== 'alive') continue;
                        if (visited.has(neighbor.id)) continue;
                        
                        visited.add(neighbor.id);
                        const newPath = [...path, neighbor];
                        
                        if (neighbor === target) {
                            return newPath;
                        }
                        
                        queue.push(newPath);
                    }
                }
                
                // No path found
                return null;
            }

            update() {
                // Update spike rotation
                this.spikeRotation += 0.1;
                
                // Update electric arcs
                this.electricArcs.forEach(arc => {
                    arc.length += arc.speed;
                    if (arc.length > arc.maxLength) {
                        arc.length = 0;
                        arc.angle = Math.random() * Math.PI * 2;
                    }
                });

                if (!this.path || this.path.length === 0) {
                    this.state = 'finished';
                    if (this.source.activePingOfDeath === this) {
                        this.source.activePingOfDeath = null;
                    }
                    return;
                }

                this.progress += this.speed;

                // Check for arrival
                if (this.progress >= 1) {
                    this.progress = 1;
                    this.state = 'finished';
                    this.x = this.target.x;
                    this.y = this.target.y;
                    
                    // Clear source's active ping
                    if (this.source.activePingOfDeath === this) {
                        this.source.activePingOfDeath = null;
                    }

                    // Apply ping of death effect
                    if (this.target.state === 'alive' && this.target.parent !== null) {
                        const targetType = this.target.isGuardian ? 'Guardian' : (this.target.hasFirewall ? 'Firewall node' : 'node');
                        logEvent('pingOfDeathHit', { target: this.target, targetType });
                        incrementStat('pingDeaths');
                        
                        // Put in red (down) state
                        updateNodeStatus(this.target, 'red');
                        
                        // Mark node as hit by ping of death (increases malware conversion chance)
                        this.target.hitByPingOfDeath = true;
                        this.target.pingOfDeathTime = Date.now();
                        
                        // Visual effect with red particles (matching ping animation color)
                        createPopParticles(this.target.x, this.target.y, { r: 220, g: 38, b: 38 });
                    }
                    return;
                }

                // Calculate position along path
                const totalLength = this.path.length - 1;
                if (totalLength <= 0) {
                    this.state = 'finished';
                    if (this.source.activePingOfDeath === this) {
                        this.source.activePingOfDeath = null;
                    }
                    return;
                }

                const clampedProgress = this.progress;
                const currentSegmentIndex = Math.floor(clampedProgress * totalLength);
                const segmentProgress = (clampedProgress * totalLength) - currentSegmentIndex;
                const fromNode = this.path[currentSegmentIndex];
                const toNode = this.path[currentSegmentIndex + 1];
                
                // Recalculate path when transitioning to a new segment to handle topology changes
                // Only recalculate if we've moved significantly (at least crossed into next segment)
                if (this.lastSegmentIndex !== undefined && this.lastSegmentIndex !== currentSegmentIndex) {
                    // We've moved to a new segment - recalculate from current node
                    if (fromNode && fromNode !== this.target && fromNode.state === 'alive') {
                        const newPath = this.findPath(fromNode, this.target);
                        if (newPath && newPath.length > 1) {
                            // Update to use the new path from current position
                            this.path = newPath;
                            // Adjust progress to continue smoothly from current position
                            // Start at beginning of new path (fromNode to next node)
                            this.progress = segmentProgress / (newPath.length - 1);
                            this.lastSegmentIndex = 0; // Reset to start of new path
                            return; // Restart update with recalculated values
                        }
                    }
                }
                
                // Track current segment for next frame
                this.lastSegmentIndex = currentSegmentIndex;

                // Check for firewall blocking (50%, 90% if guardian)
                if (fromNode && fromNode.hasFirewall && fromNode.status === 'green' && 
                    !this.checkedFirewallNodes.has(fromNode.id) && fromNode !== this.source) {
                    // Mark this firewall node as checked
                    this.checkedFirewallNodes.add(fromNode.id);
                    
                    // Guardians are elite defenders with a higher block probability
                    const pingBlockChance = fromNode.isGuardian ? 0.9 : 0.5;

                    if (Math.random() < pingBlockChance) {
                        logEvent('firewallBlockedPing', { firewallNode: fromNode });
                        incrementStat('totalDefenses');
                        
                        // Trigger defense pulse on the firewall node
                        fromNode.isDefending = true;
                        fromNode.defenseStartTime = Date.now();
                        
                        // Create visual effect at firewall node
                        createPopParticles(fromNode.x, fromNode.y, colors.neonGreen);
                        
                        // Guardian Counter-Strike: 50% chance to traceback
                        if (fromNode.isGuardian && Math.random() < 0.5) {
                            const counterStrike = new CounterStrikePacket(fromNode, this.source, this.path);
                            counterStrikePackets.push(counterStrike);
                            logEvent('custom', { message: `‚ö° Guardian ${fromNode.id} launched counter-strike traceback!` });
                        }
                        
                        // Block the packet
                        this.state = 'finished';
                        if (this.source.activePingOfDeath === this) {
                            this.source.activePingOfDeath = null;
                        }
                        return;
                    }
                }

                if (fromNode && toNode) {
                    this.x = fromNode.x + (toNode.x - fromNode.x) * segmentProgress;
                    this.y = fromNode.y + (toNode.y - fromNode.y) * segmentProgress;
                    
                    // Add current position to trail
                    this.trail.push({ x: this.x, y: this.y, age: 0 });
                    
                    // Limit trail length
                    if (this.trail.length > this.maxTrailLength) {
                        this.trail.shift();
                    }
                }
                
                // Age the trail points
                this.trail.forEach(point => point.age++);

                // Check for abort conditions (similar to dispatch packet)
                // Target decayed or no longer exists
                const targetInvalid = !this.target || this.target.state !== 'alive' || this.target.state === 'retracting';
                
                // Path is physically broken (any node is retracting or not alive)
                const isPathBroken = this.path.some(node => node.state === 'retracting' || node.state !== 'alive');
                
                if (targetInvalid || isPathBroken) {
                    // Pop with red particles (same red as the ping animation)
                    createPopParticles(this.x, this.y, { r: 220, g: 38, b: 38 });
                    this.state = 'finished';
                    if (this.source.activePingOfDeath === this) {
                        this.source.activePingOfDeath = null;
                    }
                }
            }

            draw() {
                if (this.state === 'finished') return;

                ctx.save();
                
                // Draw trail first (behind the packet)
                if (this.trail.length > 1) {
                    for (let i = 0; i < this.trail.length - 1; i++) {
                        const point = this.trail[i];
                        const nextPoint = this.trail[i + 1];
                        
                        // Calculate opacity based on age (older = more faded)
                        const maxAge = this.maxTrailLength;
                        const opacity = Math.max(0, 1 - (point.age / maxAge)) * 0.6;
                        
                        // Draw line segment
                        ctx.strokeStyle = `rgba(220, 38, 38, ${opacity})`; // Red trail
                        ctx.lineWidth = 3;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(point.x, point.y);
                        ctx.lineTo(nextPoint.x, nextPoint.y);
                        ctx.stroke();
                    }
                }
                
                ctx.translate(this.x, this.y);

                // Draw expanding red shockwave
                const shockwaveRadius = this.radius * 3;
                const shockwaveGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, shockwaveRadius);
                shockwaveGradient.addColorStop(0, 'rgba(220, 38, 38, 0.4)'); // Brighter red
                shockwaveGradient.addColorStop(0.5, 'rgba(139, 0, 0, 0.3)');
                shockwaveGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = shockwaveGradient;
                ctx.beginPath();
                ctx.arc(0, 0, shockwaveRadius, 0, Math.PI * 2);
                ctx.fill();

                // Draw electric arcs (red)
                this.electricArcs.forEach(arc => {
                    const arcProgress = arc.length / arc.maxLength;
                    const arcOpacity = Math.sin(arcProgress * Math.PI) * 0.9;
                    const endX = Math.cos(arc.angle) * arc.length;
                    const endY = Math.sin(arc.angle) * arc.length;
                    
                    ctx.strokeStyle = `rgba(220, 38, 38, ${arcOpacity})`; // Brighter red arcs
                    ctx.lineWidth = 2.5;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                });

                // Draw red spiked core
                ctx.rotate(this.spikeRotation);
                ctx.fillStyle = 'rgba(139, 0, 0, 0.95)'; // Dark red instead of black
                ctx.shadowColor = 'rgba(220, 38, 38, 1)'; // Bright red glow
                ctx.shadowBlur = 20;
                
                // Draw spiky polygon
                ctx.beginPath();
                for (let i = 0; i < this.spikes; i++) {
                    const angle = (i / this.spikes) * Math.PI * 2;
                    const nextAngle = ((i + 1) / this.spikes) * Math.PI * 2;
                    
                    // Inner point
                    const innerRadius = this.radius * 0.6;
                    const innerX = Math.cos(angle) * innerRadius;
                    const innerY = Math.sin(angle) * innerRadius;
                    
                    // Outer spike point
                    const midAngle = (angle + nextAngle) / 2;
                    const outerX = Math.cos(midAngle) * this.radius * 1.5;
                    const outerY = Math.sin(midAngle) * this.radius * 1.5;
                    
                    if (i === 0) {
                        ctx.moveTo(innerX, innerY);
                    } else {
                        ctx.lineTo(innerX, innerY);
                    }
                    ctx.lineTo(outerX, outerY);
                }
                ctx.closePath();
                ctx.fill();
                
                // Draw bright red inner core
                const innerGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius * 0.5);
                innerGlow.addColorStop(0, 'rgba(255, 70, 70, 1)'); // Bright red center
                innerGlow.addColorStop(1, 'rgba(220, 38, 38, 0.8)');
                ctx.shadowBlur = 0;
                ctx.fillStyle = innerGlow;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * 0.5, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        class PhishPacket {
            constructor(sourceNode, targetNode) {
                this.source = sourceNode;
                this.target = targetNode;
                this.path = this.findPath(sourceNode, targetNode);
                this.progress = 0;
                this.speed = 0.0084375 * packetSpeedMultiplier; // Same speed as ping of death
                this.radius = 6;
                this.x = sourceNode.x;
                this.y = sourceNode.y;
                this.state = 'active';
                this.spikes = 8;
                this.spikeRotation = 0;
                this.electricArcs = [];
                this.trail = [];
                this.maxTrailLength = 15;
                this.lastSegmentIndex = -1;
                
                // Initialize electric arcs
                for (let i = 0; i < 3; i++) {
                    this.electricArcs.push({
                        angle: Math.random() * Math.PI * 2,
                        length: 0,
                        maxLength: this.radius * 2,
                        speed: 0.3 + Math.random() * 0.3
                    });
                }
            }

            // BFS pathfinding (same as PingOfDeath)
            findPath(start, target) {
                if (start === target) return [start];
                
                const queue = [[start]];
                const visited = new Set([start.id]);
                
                while (queue.length > 0) {
                    const path = queue.shift();
                    const current = path[path.length - 1];
                    
                    const neighbors = [...current.children];
                    if (current.parent) neighbors.push(current.parent);
                    
                    edges.forEach(edge => {
                        if (edge.isBotnetMesh) {
                            if (edge.from === current && !neighbors.includes(edge.to)) {
                                neighbors.push(edge.to);
                            } else if (edge.to === current && !neighbors.includes(edge.from)) {
                                neighbors.push(edge.from);
                            }
                        }
                    });
                    
                    for (const neighbor of neighbors) {
                        if (!neighbor || neighbor.state !== 'alive') continue;
                        if (visited.has(neighbor.id)) continue;
                        
                        visited.add(neighbor.id);
                        const newPath = [...path, neighbor];
                        
                        if (neighbor === target) {
                            return newPath;
                        }
                        
                        queue.push(newPath);
                    }
                }
                
                return null;
            }

            update() {
                if (this.state !== 'active') return;
                
                this.spikeRotation += 0.1;
                
                this.electricArcs.forEach(arc => {
                    arc.length += arc.speed;
                    if (arc.length > arc.maxLength) {
                        arc.length = 0;
                        arc.angle = Math.random() * Math.PI * 2;
                    }
                });

                if (!this.path || this.path.length === 0) {
                    this.state = 'finished';
                    return;
                }

                this.progress += this.speed;

                // Check for arrival
                if (this.progress >= 1) {
                    this.progress = 1;
                    this.state = 'finished';
                    this.x = this.target.x;
                    this.y = this.target.y;

                    // Apply phishing infection attempt
                    if (this.target.state === 'alive' && this.target.parent !== null && this.target.status === 'green') {
                        // Special block chances for defenders
                        let blocked = false;
                        let defenderType = '';
                        if (this.target.isGuardian) {
                            blocked = Math.random() < 0.50;
                            defenderType = 'Guardian';
                        } else if (this.target.hasFirewall && this.target.shieldStrength > 0) {
                            blocked = Math.random() < 0.25;
                            defenderType = 'Firewall';
                        }

                        if (blocked) {
                            // Phishing blocked by Guardian or Firewall
                            logEvent('phishingBlocked', { node: this.target, defender: defenderType });
                            incrementStat('totalDefenses');
                            createPopParticles(this.target.x, this.target.y, colors.malware); // Purple particles
                            
                            // Guardian Counter-Strike: 50% chance to traceback
                            if (this.target.isGuardian && Math.random() < 0.5) {
                                const counterStrike = new CounterStrikePacket(this.target, this.source, this.path);
                                counterStrikePackets.push(counterStrike);
                                logEvent('custom', { message: `‚ö° Guardian ${this.target.id} launched counter-strike traceback!` });
                            }
                        } else {
                            // Node defended against phishing
                            this.target.isDefending = true;
                            this.target.defenseStartTime = Date.now();
                            createPopParticles(this.target.x, this.target.y, colors.malware); // Purple particles
                            logEvent('phishingDefended', { node: this.target });

                            trySpawnGuardian(this.target);
                            
                            // Phishing successful - infect node
                            updateNodeStatus(this.target, 'malware');
                            logEvent('phishingSuccess', { target: this.target });
                            incrementStat('phishSuccess');
                            incrementStat('totalInfections');
                        }
                    }
                    return;
                }

                // Calculate position along path
                const totalLength = this.path.length - 1;
                if (totalLength <= 0) {
                    this.state = 'finished';
                    return;
                }

                const clampedProgress = this.progress;
                const currentSegmentIndex = Math.floor(clampedProgress * totalLength);
                const segmentProgress = (clampedProgress * totalLength) - currentSegmentIndex;
                const fromNode = this.path[currentSegmentIndex];
                const toNode = this.path[currentSegmentIndex + 1];
                
                // Recalculate path when transitioning to a new segment
                if (this.lastSegmentIndex !== undefined && this.lastSegmentIndex !== currentSegmentIndex) {
                    // We've moved to a new segment - recalculate from current node
                    if (fromNode && fromNode !== this.target && fromNode.state === 'alive') {
                        const newPath = this.findPath(fromNode, this.target);
                        if (newPath && newPath.length > 1) {
                            // Update to use the new path from current position
                            this.path = newPath;
                            // Adjust progress to continue smoothly from current position
                            // Start at beginning of new path (fromNode to next node)
                            this.progress = segmentProgress / (newPath.length - 1);
                            this.lastSegmentIndex = 0; // Reset to start of new path
                            return; // Restart update with recalculated values
                        }
                    }
                }
                
                this.lastSegmentIndex = currentSegmentIndex;

                if (fromNode && toNode) {
                    this.x = fromNode.x + (toNode.x - fromNode.x) * segmentProgress;
                    this.y = fromNode.y + (toNode.y - fromNode.y) * segmentProgress;
                    
                    this.trail.push({ x: this.x, y: this.y, age: 0 });
                    
                    if (this.trail.length > this.maxTrailLength) {
                        this.trail.shift();
                    }
                }
                
                this.trail.forEach(point => point.age++);

                // Check for abort conditions
                const targetInvalid = !this.target || this.target.state !== 'alive' || this.target.state === 'retracting';
                const isPathBroken = this.path.some(node => node.state === 'retracting' || node.state !== 'alive');
                
                if (targetInvalid || isPathBroken) {
                    createPopParticles(this.x, this.y, colors.malware); // Purple particles
                    this.state = 'finished';
                }
            }

            draw() {
                if (this.state === 'finished') return;

                ctx.save();
                
                // Draw purple trail
                if (this.trail.length > 1) {
                    for (let i = 0; i < this.trail.length - 1; i++) {
                        const point = this.trail[i];
                        const nextPoint = this.trail[i + 1];
                        
                        const maxAge = this.maxTrailLength;
                        const opacity = Math.max(0, 1 - (point.age / maxAge)) * 0.6;
                        
                        ctx.strokeStyle = `rgba(168, 85, 247, ${opacity})`; // Purple trail
                        ctx.lineWidth = 3;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(point.x, point.y);
                        ctx.lineTo(nextPoint.x, nextPoint.y);
                        ctx.stroke();
                    }
                }
                
                ctx.translate(this.x, this.y);

                // Draw purple shockwave
                const shockwaveRadius = this.radius * 3;
                const shockwaveGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, shockwaveRadius);
                shockwaveGradient.addColorStop(0, 'rgba(168, 85, 247, 0.4)');
                shockwaveGradient.addColorStop(0.5, 'rgba(124, 58, 237, 0.3)');
                shockwaveGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = shockwaveGradient;
                ctx.beginPath();
                ctx.arc(0, 0, shockwaveRadius, 0, Math.PI * 2);
                ctx.fill();

                // Draw purple electric arcs
                this.electricArcs.forEach(arc => {
                    const arcProgress = arc.length / arc.maxLength;
                    const arcOpacity = Math.sin(arcProgress * Math.PI) * 0.9;
                    const endX = Math.cos(arc.angle) * arc.length;
                    const endY = Math.sin(arc.angle) * arc.length;
                    
                    ctx.strokeStyle = `rgba(168, 85, 247, ${arcOpacity})`;
                    ctx.lineWidth = 2.5;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                });

                // Draw purple spiked core
                ctx.rotate(this.spikeRotation);
                ctx.fillStyle = 'rgba(124, 58, 237, 0.95)';
                ctx.shadowColor = 'rgba(168, 85, 247, 1)';
                ctx.shadowBlur = 20;
                
                ctx.beginPath();
                for (let i = 0; i < this.spikes; i++) {
                    const angle = (i / this.spikes) * Math.PI * 2;
                    const nextAngle = ((i + 1) / this.spikes) * Math.PI * 2;
                    
                    const innerRadius = this.radius * 0.6;
                    const innerX = Math.cos(angle) * innerRadius;
                    const innerY = Math.sin(angle) * innerRadius;
                    
                    const midAngle = (angle + nextAngle) / 2;
                    const outerX = Math.cos(midAngle) * this.radius * 1.5;
                    const outerY = Math.sin(midAngle) * this.radius * 1.5;
                    
                    if (i === 0) {
                        ctx.moveTo(innerX, innerY);
                    } else {
                        ctx.lineTo(innerX, innerY);
                    }
                    ctx.lineTo(outerX, outerY);
                }
                ctx.closePath();
                ctx.fill();
                
                // Draw bright purple inner core
                const innerGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius * 0.5);
                innerGlow.addColorStop(0, 'rgba(192, 132, 252, 1)');
                innerGlow.addColorStop(1, 'rgba(168, 85, 247, 0.8)');
                ctx.shadowBlur = 0;
                ctx.fillStyle = innerGlow;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * 0.5, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        // Counter-Strike Packet - Guardian traceback attack
        class CounterStrikePacket {
            constructor(guardianNode, targetNode, attackPath) {
                this.guardian = guardianNode;
                this.target = targetNode;
                // Reverse the attack path for traceback
                this.path = attackPath ? [...attackPath].reverse() : null;
                this.progress = 0;
                this.speed = 0.015 * packetSpeedMultiplier; // Faster than attack packets
                this.radius = 5;
                this.x = guardianNode.x;
                this.y = guardianNode.y;
                this.state = 'active';
                this.color = { r: 96, g: 165, b: 250 }; // Bright blue
                this.trail = [];
                this.maxTrailLength = 20;
                this.lightning = [];
                this.lightningUpdateCounter = 0;
            }

            update() {
                if (this.state !== 'active') return;

                if (!this.path || this.path.length === 0) {
                    this.state = 'finished';
                    return;
                }

                this.progress += this.speed;

                // Check for arrival at target
                if (this.progress >= 1) {
                    this.progress = 1;
                    this.state = 'finished';
                    this.x = this.target.x;
                    this.y = this.target.y;

                    // Apply counter-strike effect on arrival
                    if (this.target.state === 'alive') {
                        const previousStatus = this.target.status;
                        
                        // Downgrade the infected node
                        if (this.target.status === 'commandControl') {
                            this.target.status = 'botnet';
                            logEvent('custom', { message: `‚ö° Counter-strike downgraded C&C node ${this.target.id} to botnet!` });
                        } else if (this.target.status === 'botnet') {
                            this.target.status = 'malware';
                            logEvent('custom', { message: `‚ö° Counter-strike downgraded botnet ${this.target.id} to malware!` });
                        } else if (this.target.status === 'malware') {
                            this.target.status = 'green';
                            this.target.isImmunityHealing = false;
                            this.target.attachedImmunityPackets = [];
                            incrementStat('totalRecoveries');
                            logEvent('custom', { message: `‚ö° Counter-strike cleansed node ${this.target.id}!` });
                        }
                        
                        this.target.statusChangeTime = Date.now();
                        
                        // Visual feedback
                        createPopParticles(this.target.x, this.target.y, this.color);
                    }
                    return;
                }

                // Calculate position along path
                const totalLength = this.path.length - 1;
                if (totalLength <= 0) {
                    this.state = 'finished';
                    return;
                }

                const currentSegmentIndex = Math.floor(this.progress * totalLength);
                const segmentProgress = (this.progress * totalLength) - currentSegmentIndex;
                const fromNode = this.path[currentSegmentIndex];
                const toNode = this.path[currentSegmentIndex + 1];

                if (fromNode && toNode) {
                    this.x = fromNode.x + (toNode.x - fromNode.x) * segmentProgress;
                    this.y = fromNode.y + (toNode.y - fromNode.y) * segmentProgress;
                    
                    // Add to trail
                    this.trail.unshift({ x: this.x, y: this.y });
                    if (this.trail.length > this.maxTrailLength) {
                        this.trail.pop();
                    }
                    
                    // Generate lightning effect periodically
                    this.lightningUpdateCounter++;
                    if (this.lightningUpdateCounter % 3 === 0) {
                        this.lightning = [];
                        for (let i = 0; i < 4; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const dist = this.radius + Math.random() * 15;
                            this.lightning.push({
                                x: this.x + Math.cos(angle) * dist,
                                y: this.y + Math.sin(angle) * dist
                            });
                        }
                    }
                }
            }

            draw() {
                if (this.state !== 'active') return;

                ctx.save();
                
                // Draw lightning arcs
                ctx.strokeStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 0.4)`;
                ctx.lineWidth = 1.5;
                this.lightning.forEach(bolt => {
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(bolt.x, bolt.y);
                    ctx.stroke();
                });
                
                // Draw trail
                for (let i = 0; i < this.trail.length; i++) {
                    const opacity = (1 - i / this.trail.length) * 0.6;
                    const size = this.radius * (1 - i / this.trail.length);
                    ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${opacity})`;
                    ctx.beginPath();
                    ctx.arc(this.trail[i].x, this.trail[i].y, size, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw main packet with glow
                ctx.shadowColor = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 1)`;
                ctx.shadowBlur = 15;
                ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, 1)`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw inner white core
                ctx.shadowBlur = 0;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 0.5, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        function randomRange(min, max) {
            return Math.random() * (max - min) + min;
        }

        function initializeGalaxy() {
            galaxyStars.length = 0;
            const starPalette = [
                { r: 255, g: 255, b: 255 },
                { r: 176, g: 196, b: 255 },
                { r: 255, g: 244, b: 214 },
                { r: 167, g: 210, b: 255 }
            ];
            for (let i = 0; i < GALAXY_STAR_COUNT; i++) {
                const depth = Math.random();
                const base = starPalette[Math.floor(Math.random() * starPalette.length)];
                galaxyStars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: 0.25 + depth * 1.6,
                    speed: 10 + depth * 40,
                    twinkleSpeed: 0.5 + Math.random() * 1.5,
                    twinkleOffset: Math.random() * Math.PI * 2,
                    color: base
                });
            }

            galaxyNebulae.length = 0;
            const nebulaPalette = [
                { r: 99, g: 102, b: 241 },
                { r: 14, g: 165, b: 233 },
                { r: 236, g: 72, b: 153 },
                { r: 74, g: 222, b: 128 }
            ];
            const maxDimension = Math.max(canvas.width, canvas.height) || 1;
            for (let i = 0; i < GALAXY_NEBULA_COUNT; i++) {
                const color = nebulaPalette[Math.floor(Math.random() * nebulaPalette.length)];
                const baseRadius = randomRange(maxDimension * 0.28, maxDimension * 0.45);
                const driftAngle = Math.random() * Math.PI * 2;
                const driftSpeed = randomRange(4, 12);
                galaxyNebulae.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    baseRadius,
                    color,
                    pulseSpeed: randomRange(0.25, 0.6),
                    pulsePhase: Math.random() * Math.PI * 2,
                    vx: Math.cos(driftAngle) * driftSpeed,
                    vy: Math.sin(driftAngle) * driftSpeed
                });
            }

            galaxyComets.length = 0;
            galaxyNovas.length = 0;
            galaxyCometExplosions.length = 0;
            lastBackgroundTime = Date.now();
            lastNovaSpawn = lastBackgroundTime;
        }

        function spawnComet() {
            const startX = -randomRange(40, 160);
            const startY = randomRange(-80, canvas.height * 0.7);
            const speed = randomRange(150, 260);
            const angle = randomRange(0.12, 0.35);
            const color = { r: 173, g: 216, b: 255 };
            galaxyComets.push({
                x: startX,
                y: startY,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                radius: randomRange(2.2, 3.6),
                life: randomRange(12, 18),
                tailDistance: randomRange(140, 220),
                color
            });
        }

        function spawnNova(now) {
            lastNovaSpawn = now;
            const novaPalette = [
                { r: 255, g: 255, b: 255 },
                { r: 255, g: 214, b: 102 },
                { r: 147, g: 197, b: 253 },
                { r: 244, g: 114, b: 182 }
            ];
            galaxyNovas.push({
                x: randomRange(0, canvas.width),
                y: randomRange(0, canvas.height),
                start: now,
                duration: randomRange(1200, 2200),
                maxRadius: randomRange(Math.max(canvas.width, canvas.height) * 0.08, Math.max(canvas.width, canvas.height) * 0.14),
                color: novaPalette[Math.floor(Math.random() * novaPalette.length)]
            });
        }

        function drawGalaxyBackground(now) {
            if (canvas.width === 0 || canvas.height === 0) {
                return;
            }

            if (galaxyStars.length === 0) {
                initializeGalaxy();
            }

            const deltaSeconds = Math.min(0.05, (now - lastBackgroundTime) / 1000) || 0;
            lastBackgroundTime = now;

            ctx.save();
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Nebulae
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            galaxyNebulae.forEach(nebula => {
                nebula.x += nebula.vx * deltaSeconds;
                nebula.y += nebula.vy * deltaSeconds;
                nebula.pulsePhase += nebula.pulseSpeed * deltaSeconds;
                const pulse = 0.82 + (Math.cos(nebula.pulsePhase) * -0.18);
                const maxRadius = nebula.baseRadius;
                if (nebula.x < -maxRadius) nebula.x = canvas.width + maxRadius;
                if (nebula.x > canvas.width + maxRadius) nebula.x = -maxRadius;
                if (nebula.y < -maxRadius) nebula.y = canvas.height + maxRadius;
                if (nebula.y > canvas.height + maxRadius) nebula.y = -maxRadius;
                const radius = nebula.baseRadius * pulse;
                const gradient = ctx.createRadialGradient(nebula.x, nebula.y, 0, nebula.x, nebula.y, radius);
                gradient.addColorStop(0, `rgba(${nebula.color.r}, ${nebula.color.g}, ${nebula.color.b}, 0.35)`);
                gradient.addColorStop(0.6, `rgba(${nebula.color.r}, ${nebula.color.g}, ${nebula.color.b}, 0.16)`);
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(nebula.x, nebula.y, radius, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.restore();

            // Stars
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            galaxyStars.forEach(star => {
                star.x -= star.speed * deltaSeconds;
                if (star.x < -star.radius) {
                    star.x = canvas.width + star.radius;
                    star.y = Math.random() * canvas.height;
                }
                const twinkle = Math.sin(now * 0.002 * star.twinkleSpeed + star.twinkleOffset) * 0.5 + 0.5;
                const alpha = 0.25 + twinkle * 0.75;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = `rgba(${star.color.r}, ${star.color.g}, ${star.color.b}, 1)`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.restore();

            // Spawn new comets and novas
            if (galaxyComets.length < GALAXY_COMET_CAP && Math.random() < deltaSeconds * 0.05) {
                spawnComet();
            }
            if (now - lastNovaSpawn > 6000 && Math.random() < deltaSeconds * 0.18) {
                spawnNova(now);
            }

            // Comets
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            const rootX = canvas.width / 2;
            const rootY = canvas.height / 2;
            const maxCenterDistance = Math.hypot(rootX, rootY) || 1;
            const centralNode = nodes[0];
            const centralRadius = centralNode ? centralNode.radius : 0;
            for (let i = galaxyComets.length - 1; i >= 0; i--) {
                const comet = galaxyComets[i];
                comet.x += comet.vx * deltaSeconds;
                comet.y += comet.vy * deltaSeconds;
                comet.life -= deltaSeconds;

                if (comet.life <= 0 ||
                    comet.x < -200 ||
                    comet.x > canvas.width + 200 ||
                    comet.y < -200 ||
                    comet.y > canvas.height + 200) {
                    galaxyComets.splice(i, 1);
                    continue;
                }

                const dirX = comet.x - rootX;
                const dirY = comet.y - rootY;
                const dirMag = Math.sqrt(dirX * dirX + dirY * dirY) || 1;
                const distanceFromCenter = Math.min(maxCenterDistance, dirMag);
                const centerFactor = 1 - (distanceFromCenter / maxCenterDistance);

                if (centralNode && centralRadius > 0) {
                    if (dirMag <= centralRadius + comet.radius * 0.75) {
                        galaxyComets.splice(i, 1);
                        galaxyCometExplosions.push({
                            x: comet.x,
                            y: comet.y,
                            start: now,
                            duration: 950,
                            maxRadius: Math.max(centralRadius * 1.6, 60),
                            color: { ...comet.color }
                        });
                        createPopParticles(centralNode.x, centralNode.y, {
                            r: Math.min(255, comet.color.r + 40),
                            g: Math.min(255, comet.color.g + 40),
                            b: Math.min(255, comet.color.b + 40)
                        });
                        centralImpactShake = Math.min(centralImpactShake + 8, 24);
                        centralImpactShakePhase = Math.random() * Math.PI * 2;
                        centralImpactShakeOffsetX = 0;
                        centralImpactShakeOffsetY = 0;
                        continue;
                    }
                }

                const influenceRadius = maxCenterDistance * 0.65;
                if (dirMag < influenceRadius) {
                    const normDirX = dirX / dirMag;
                    const normDirY = dirY / dirMag;
                    const proximity = 1 - (dirMag / influenceRadius);
                    const radialAccel = 110 * Math.pow(proximity, 1.4);
                    const tangentialAccel = 22 * (proximity ** 2);

                    // Pull toward the center to curve the path inward
                    comet.vx += -normDirX * radialAccel * deltaSeconds;
                    comet.vy += -normDirY * radialAccel * deltaSeconds;

                    // Add a slight tangential component to simulate gravitational bending
                    const normalX = -normDirY;
                    const normalY = normDirX;
                    comet.vx += normalX * tangentialAccel * deltaSeconds;
                    comet.vy += normalY * tangentialAccel * deltaSeconds;
                }

                const normX = dirX / dirMag;
                const normY = dirY / dirMag;
                const tailEndX = comet.x + normX * comet.tailDistance;
                const tailEndY = comet.y + normY * comet.tailDistance;

                const brightness = 0.35 + centerFactor * 0.65;
                const tintAmount = centerFactor * 0.8;
                const tintedColor = {
                    r: Math.round(comet.color.r + (255 - comet.color.r) * tintAmount),
                    g: Math.round(comet.color.g + (255 - comet.color.g) * tintAmount),
                    b: Math.round(comet.color.b + (255 - comet.color.b) * tintAmount)
                };

                const gradient = ctx.createLinearGradient(comet.x, comet.y, tailEndX, tailEndY);
                gradient.addColorStop(0, `rgba(${tintedColor.r}, ${tintedColor.g}, ${tintedColor.b}, ${0.2 + brightness * 0.8})`);
                gradient.addColorStop(1, 'rgba(20, 20, 20, 0)');
                ctx.strokeStyle = gradient;
                ctx.lineWidth = comet.radius * (1.4 + centerFactor * 1.2);
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(comet.x, comet.y);
                ctx.lineTo(tailEndX, tailEndY);
                ctx.stroke();

                ctx.fillStyle = `rgba(${tintedColor.r}, ${tintedColor.g}, ${tintedColor.b}, ${0.25 + brightness * 0.7})`;
                ctx.beginPath();
                ctx.arc(comet.x, comet.y, comet.radius, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();

            // Comet explosions
            if (galaxyCometExplosions.length > 0) {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                for (let i = galaxyCometExplosions.length - 1; i >= 0; i--) {
                    const boom = galaxyCometExplosions[i];
                    const progress = (now - boom.start) / boom.duration;
                    if (progress >= 1) {
                        galaxyCometExplosions.splice(i, 1);
                        continue;
                    }
                    const eased = Math.pow(progress, 0.55);
                    const radius = boom.maxRadius * eased;
                    const alpha = 0.75 * (1 - progress);
                    const gradient = ctx.createRadialGradient(boom.x, boom.y, 0, boom.x, boom.y, radius);
                    gradient.addColorStop(0, `rgba(${boom.color.r}, ${boom.color.g}, ${boom.color.b}, ${alpha})`);
                    gradient.addColorStop(0.45, `rgba(${boom.color.r}, ${boom.color.g}, ${boom.color.b}, ${alpha * 0.6})`);
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(boom.x, boom.y, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            }

            // Novas
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            for (let i = galaxyNovas.length - 1; i >= 0; i--) {
                const nova = galaxyNovas[i];
                const progress = (now - nova.start) / nova.duration;
                if (progress >= 1) {
                    galaxyNovas.splice(i, 1);
                    continue;
                }
                const eased = progress * (2 - progress);
                const radius = nova.maxRadius * eased;
                const alpha = (1 - progress) * 0.8;
                const gradient = ctx.createRadialGradient(nova.x, nova.y, 0, nova.x, nova.y, radius);
                gradient.addColorStop(0, `rgba(${nova.color.r}, ${nova.color.g}, ${nova.color.b}, ${Math.min(1, alpha)})`);
                gradient.addColorStop(0.4, `rgba(${nova.color.r}, ${nova.color.g}, ${nova.color.b}, ${alpha * 0.55})`);
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(nova.x, nova.y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();

            ctx.restore();

            // Decay central shake
            if (centralImpactShake > 0.0001) {
                centralImpactShake = Math.max(0, centralImpactShake - deltaSeconds * 10);
                centralImpactShakePhase += deltaSeconds * 20;
                const magnitude = centralImpactShake;
                centralImpactShakeOffsetX = Math.sin(centralImpactShakePhase) * magnitude;
                centralImpactShakeOffsetY = Math.cos(centralImpactShakePhase * 1.3) * magnitude * 0.8;
            } else {
                centralImpactShake = 0;
                centralImpactShakeOffsetX = 0;
                centralImpactShakeOffsetY = 0;
            }

            lastBackgroundTime = now;
        }

        let initialBranchTimeout;
        function createGraph() {
            clearTimeout(initialBranchTimeout);
            nodes.length = 0;
            edges.length = 0;
            pulses.length = 0;
            particles.length = 0;
            dataPackets.length = 0;
            immunityPackets.length = 0;
            pingOfDeathPackets.length = 0;
            phishPackets.length = 0;
            counterStrikePackets.length = 0;

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            const root = new Node(0, centerX, centerY);
            root.baseRadius = 30;
            root.currentColor = { ...colors.blue };
            root.status = 'blue';
            root.state = 'alive';
            root.opacity = 1;
            root.radius = root.baseRadius;
            nodes.push(root);

            createInitialBranches(0, desiredBranchCount);
        }

        function createInitialBranches(index, total) {
            if (index >= total) return;
            const angle = (index / total) * Math.PI * 2;
            sproutNewBranch(angle);
            initialBranchTimeout = setTimeout(() => createInitialBranches(index + 1, total), 800);
        }

        // --- Space-Probing Functions for Organic Growth ---
        
        function pointToLineDistance(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            
            if (lenSq !== 0) param = dot / lenSq;
            
            let xx, yy;
            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }
            
            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function scorePosition(x, y, parentNode) {
            let score = 100; // Start with base score
            
            // Penalty for proximity to other nodes (reduced from 80 to allow denser packing)
            const PERSONAL_SPACE = 65;
            for (const node of nodes) {
                if (node.state !== 'alive' || node === parentNode) continue;
                const dx = x - node.x;
                const dy = y - node.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < PERSONAL_SPACE) {
                    score -= (PERSONAL_SPACE - dist) * 2; // Heavy penalty for crowding
                }
            }
            
            // Penalty for proximity to edges (line-to-point distance)
            const EDGE_CLEARANCE = 40;
            for (const edge of edges) {
                if (!edge.from || !edge.to || edge.from.state !== 'alive' || edge.to.state !== 'alive') continue;
                const dist = pointToLineDistance(x, y, edge.from.x, edge.from.y, edge.to.x, edge.to.y);
                
                if (dist < EDGE_CLEARANCE) {
                    score -= (EDGE_CLEARANCE - dist) * 1.5;
                }
            }
            
            // Penalty for staying near ideal distance from parent
            const parentDist = Math.sqrt((x - parentNode.x) ** 2 + (y - parentNode.y) ** 2);
            const idealDist = 80;
            score -= Math.abs(parentDist - idealDist) * 0.5;
            
            // IMPROVED: Heavy penalty for being too close to canvas boundaries
            const BOUNDARY_BUFFER = 100; // Discourage nodes within 100px of edge
            const distToLeft = x - padding;
            const distToRight = (canvas.width - padding) - x;
            const distToTop = y - padding;
            const distToBottom = (canvas.height - padding) - y;
            const minDistToBoundary = Math.min(distToLeft, distToRight, distToTop, distToBottom);
            
            if (minDistToBoundary < BOUNDARY_BUFFER) {
                score -= (BOUNDARY_BUFFER - minDistToBoundary) * 3; // Strong penalty near edges
            }
            
            // IMPROVED: Bonus for staying closer to canvas center (centripetal tendency)
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const distToCenter = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
            const maxDistToCenter = Math.sqrt((canvas.width / 2) ** 2 + (canvas.height / 2) ** 2);
            const centerBonus = (1 - (distToCenter / maxDistToCenter)) * 20; // Up to +20 for being near center
            score += centerBonus;
            
            // Heavy penalty if the segment to the parent would cross existing non-wireless edges
            if (parentNode && segmentCrossesExistingEdges(parentNode, { x, y })) {
                score -= 1000;
            }
            
            return score;
        }

        function findOptimalBranchPosition(parentNode, angle, distance, samples = 8) {
            const allCandidates = [];

            const sampleOnce = (count, cone = Math.PI / 3, distJitter = 0.2) => {
                const candidates = [];
                for (let i = 0; i < count; i++) {
                    const angleVariation = (i / count - 0.5) * cone; // symmetric cone
                    const testAngle = angle + angleVariation;
                    const distVariation = distance * (1 - distJitter + Math.random() * (2 * distJitter));

                    const x = parentNode.baseX + Math.cos(testAngle) * distVariation;
                    const y = parentNode.baseY + Math.sin(testAngle) * distVariation;

                    const clampedX = Math.max(padding, Math.min(canvas.width - padding, x));
                    const clampedY = Math.max(padding, Math.min(canvas.height - padding, y));

                    const candidate = { x: clampedX, y: clampedY, angle: testAngle };
                    candidate.score = scorePosition(candidate.x, candidate.y, parentNode);
                    candidates.push(candidate);
                    allCandidates.push(candidate);
                }
                // Prefer non-crossing candidates
                const safe = candidates.filter(c => !segmentCrossesExistingEdges(parentNode, c));
                if (safe.length > 0) {
                    safe.sort((a, b) => b.score - a.score);
                    return safe[0];
                }
                return null;
            };

            // Try progressively larger cones / more samples to find a non-crossing option
            const attempts = [
                { count: samples, cone: Math.PI / 3, jitter: 0.2 },
                { count: Math.max(12, samples + 4), cone: Math.PI / 2, jitter: 0.3 },
                { count: Math.max(18, samples + 10), cone: (2 * Math.PI) / 3, jitter: 0.35 },
            ];

            for (const a of attempts) {
                const pick = sampleOnce(a.count, a.cone, a.jitter);
                if (pick) return pick;
            }

            // Fallback: if no safe candidate, return the highest-scoring overall
            allCandidates.sort((a, b) => b.score - a.score);
            return allCandidates[0] || { x: parentNode.x, y: parentNode.y, angle };
        }

        function sproutNewBranch(angle = null) {
             const root = nodes[0];
             let newAngle = angle;

             if (newAngle === null) {
                const mainBranches = root.children.filter(n => n.state !== 'retracting');
                if (mainBranches.length < 2) {
                    newAngle = Math.random() * Math.PI * 2;
                } else {
                    const angles = mainBranches.map(branch => Math.atan2(branch.baseY - root.baseY, branch.baseX - root.baseX)).sort((a, b) => a - b);
                    let maxGap = 0;
                    let angleForMaxGap = 0;

                    for (let i = 0; i < angles.length; i++) {
                        const nextAngle = (i === angles.length - 1) ? angles[0] + Math.PI * 2 : angles[i + 1];
                        const gap = nextAngle - angles[i];
                        if (gap > maxGap) {
                            maxGap = gap;
                            angleForMaxGap = angles[i];
                        }
                    }
                    newAngle = angleForMaxGap + maxGap / 2;
                }
             }
             
            const cosAngle = Math.abs(Math.cos(newAngle));
            let lengthFactor;
            let branchDepth;

            if (cosAngle > 0.5) {
                lengthFactor = 0.6 + Math.random() * 0.3;
                branchDepth = 3; 
            } else {
                lengthFactor = 0.2 + Math.random() * 0.2;
                branchDepth = 2;
            }

             const xDist = (canvas.width / 2 - padding) * lengthFactor;
             const yDist = (canvas.height / 2 - padding) * lengthFactor;
             const targetDist = Math.sqrt(xDist * xDist + yDist * yDist);

             // IMPROVED: Use space-probing for main branch position
             const optimal = findOptimalBranchPosition(root, newAngle, targetDist, 12); // More samples for main branches

             let endpoint = { x: optimal.x, y: optimal.y };
             let growthAngle = optimal.angle;
             if (segmentCrossesExistingEdges(root, endpoint)) {
                 const nudged = nudgeEndpointToAvoidCrossing(root, endpoint);
                 if (nudged) {
                     endpoint = nudged;
                 } else {
                     const alt = findOptimalBranchPosition(root, newAngle + (Math.random() - 0.5) * (Math.PI / 2), targetDist, 18);
                     if (!alt || segmentCrossesExistingEdges(root, alt)) {
                         return; // Skip this main branch to avoid crossing
                     }
                     endpoint = { x: alt.x, y: alt.y };
                     growthAngle = alt.angle;
                 }
             }

             const mainNode = new Node(Date.now() + Math.random(), endpoint.x, endpoint.y, root);
           root.children.push(mainNode);
           nodes.push(mainNode);
           edges.push({ from: root, to: mainNode });
           applyParentStatusToChild(root, mainNode);

           growBranchSequentially(mainNode, branchDepth, growthAngle);
             root.pulseEffect = 1;

            scheduleGroundStationPromotion(mainNode);
        }

        function scheduleGroundStationPromotion(branchNode) {
            if (!branchNode) return;
            setTimeout(() => {
                const isSingle = branchNode.parent === nodes[0] && branchNode.children.length === 0 && branchNode.state === 'alive';
                const alreadySpecial = branchNode.isGuardian || branchNode.isGroundStation;
                if (!isSingle || alreadySpecial) return;

                if (Math.random() < 0.25) {
                    convertToGroundStation(branchNode);
                }
            }, 4000 + Math.random() * 2000); // Allow initial settling before promotion
        }

        function applyParentStatusToChild(parentNode, childNode) {
            if (!parentNode || !childNode) return;
            if (childNode.isSatellite) return;
            if (parentNode.status === 'red' || parentNode.status === 'yellow' || parentNode.status === 'malware' || parentNode.status === 'botnet' || parentNode.status === 'commandControl') {
                childNode.status = 'yellow';
                childNode.statusChangedAt = Date.now();
            }
        }

        function growBranchSequentially(parentNode, depth, parentAngle) {
            if (depth <= 0) return;
            const numChildren = Math.floor(Math.random() * 3);

            for (let i = 0; i < numChildren; i++) {
                setTimeout(() => {
                    if (parentNode.state === 'retracting') return;

                    // IMPROVED: Use space-probing instead of simple angle offset
                    const angle = parentAngle + (Math.random() - 0.5) * 0.9;
                    const dist = 50 + Math.random() * 40;
                    
                    const optimal = findOptimalBranchPosition(parentNode, angle, dist);
                    
                    let endpoint = { x: optimal.x, y: optimal.y };
                    let nextAngle = optimal.angle;
                    if (segmentCrossesExistingEdges(parentNode, endpoint)) {
                        const nudged = nudgeEndpointToAvoidCrossing(parentNode, endpoint);
                        if (nudged) {
                            endpoint = nudged;
                        } else {
                            const alt = findOptimalBranchPosition(parentNode, angle + (Math.random() - 0.5) * 0.8, dist, 14);
                            if (!alt || segmentCrossesExistingEdges(parentNode, alt)) {
                                return; // Skip this child; cannot place without crossing
                            }
                            endpoint = { x: alt.x, y: alt.y };
                            nextAngle = alt.angle;
                        }
                    }

                    const childNode = new Node(Date.now() + Math.random(), endpoint.x, endpoint.y, parentNode);
                    parentNode.children.push(childNode);
                    nodes.push(childNode);
                    edges.push({ from: parentNode, to: childNode });
                    applyParentStatusToChild(parentNode, childNode);

                    // IMPROVED: Longer delay to let physics settle
                    setTimeout(() => {
                        growBranchSequentially(childNode, depth - 1, nextAngle);
                    }, 1500); // Increased from 1000ms
                }, i * (1000 + Math.random() * 400)); // Increased from 600-800ms
            }
        }

        function markBranchForRetraction(node, options = {}) {
            if (!node) return;
            const allowGroundStation = options.allowGroundStation === true;
            if (node.isGroundStation && !allowGroundStation) return;
            if (node.isGroundStation && allowGroundStation) {
                removeSatelliteChain(node);
                node.isGroundStation = false;
            }
            if (node.isSatellite) {
                untetherSatellite(node);
            }
            node.state = 'retracting';

            // Clear any attached immunity packets when branch is marked for retraction
            if (node.attachedImmunityPackets && node.attachedImmunityPackets.length > 0) {
                node.attachedImmunityPackets.forEach(packet => {
                    packet.active = false;
                    packet.isAttached = false;
                    packet.attachedNode = null;
                });
                node.attachedImmunityPackets = [];
                node.isImmunityHealing = false;
                node.immunityHealingStartTime = 0;
            }
            
            // Clear targeting flag and remove any pulses targeting this node
            node.isTargeted = false;
            pulses = pulses.filter(p => p.target !== node);
            
            node.children.forEach(child => markBranchForRetraction(child, options));
        }

        function pruneRandomBranch() {
            const now = Date.now();
            const potentialBranches = nodes.filter(n => 
                n.parent === nodes[0] && 
                n.state === 'alive' && 
                (now - n.createdAt) > 10000 &&
                n.status !== 'botnet' && // Don't prune botnet nodes
                n.status !== 'commandControl' && // Don't prune C&C nodes
                !hasBotnetMeshConnections(n) // Don't prune nodes with mesh connections
            );

            if (potentialBranches.length > 7) {
                // Weight selection based on branch size - larger branches are more resilient
                // Smaller branches (fewer descendants) are more likely to be pruned
                const branchWeights = potentialBranches.map(branch => {
                    const descendantCount = countDescendants(branch);
                    // Inverse weighting: fewer descendants = higher weight (more likely to be pruned)
                    // Base weight of 10, reduced by descendant count
                    return Math.max(1, 10 - descendantCount);
                });
                
                // Calculate total weight
                const totalWeight = branchWeights.reduce((sum, weight) => sum + weight, 0);
                
                // Select a random branch based on weights
                let randomValue = Math.random() * totalWeight;
                let selectedIndex = 0;
                for (let i = 0; i < branchWeights.length; i++) {
                    randomValue -= branchWeights[i];
                    if (randomValue <= 0) {
                        selectedIndex = i;
                        break;
                    }
                }
                
                const branchToPrune = potentialBranches[selectedIndex];
                markBranchForRetraction(branchToPrune);
            }
        }
        
        function pruneSingleNodeBranches() {
            const now = Date.now();
            // Find all single-node branches (direct children of root with no children of their own)
            // that have existed for more than 5 seconds
            const singleNodeBranches = nodes.filter(n => 
                n.parent === nodes[0] && 
                n.state === 'alive' && 
                n.children.length === 0 &&
                !n.isGroundStation &&
                (now - n.createdAt) > 5000 &&
                n.status !== 'botnet' && // Don't prune botnet nodes
                n.status !== 'commandControl' && // Don't prune C&C nodes
                !hasBotnetMeshConnections(n) // Don't prune nodes with mesh connections
            );
            
            // Prune all single-node branches that meet the criteria
            singleNodeBranches.forEach(branch => {
                markBranchForRetraction(branch);
            });
        }
        
        function spawnCentralImmunityPackets(centralNode) {
            // Central node spawns normal immunity packets like firewall nodes
            // Spawn on all edges connected to the central node
            if (!centralNode || centralNode.parent !== null) return;
            
            edges.forEach(edge => {
                // Check if this edge is connected to the central node
                const connectedToCentral = (edge.from === centralNode || edge.to === centralNode);
                if (!connectedToCentral) return;
                
                // Make sure the other node is alive
                const otherNode = edge.from === centralNode ? edge.to : edge.from;
                if (!otherNode || otherNode.state !== 'alive') return;
                
                // Spawn normal immunity packets in both directions on this edge
                // Spawn 2-3 packets per edge for a noticeable response
                const packetCount = 2 + Math.floor(Math.random() * 2); // 2-3 packets
                
                for (let i = 0; i < packetCount; i++) {
                    // Spawn going away from central (direction based on edge orientation)
                    const direction = edge.from === centralNode ? 1 : -1;
                    const packet = new ImmunityPacket(edge, direction);
                    packet.progress = 0.05 + (i * 0.1); // Stagger slightly
                    immunityPackets.push(packet);
                    incrementStat('totalImmunityPackets');
                }
            });
        }
        
        function redistributeImmunityPackets(centralNode) {
            // Get all attached immunity packets from central node
            const packetsToRedistribute = [...centralNode.attachedImmunityPackets];
            
            if (packetsToRedistribute.length > 0) {
                logEvent('immunitySupercharged', { packetCount: packetsToRedistribute.length });
            }
            
            // Clear the central node's attached packets
            centralNode.attachedImmunityPackets = [];
            centralNode.isImmunityHealing = false;
            centralNode.immunityHealingStartTime = 0;
            
            // Find all healthy edges to redistribute packets to
            const healthyEdges = edges.filter(edge => 
                edge.from && edge.to && 
                edge.from.state === 'alive' && edge.to.state === 'alive' &&
                (edge.from.status === 'green' || edge.to.status === 'green')
            );
            
            if (healthyEdges.length === 0) {
                // No healthy edges, deactivate all packets
                packetsToRedistribute.forEach(packet => {
                    packet.active = false;
                    packet.isAttached = false;
                    packet.attachedNode = null;
                });
                return;
            }
            
            // Redistribute each packet to a random healthy edge
            packetsToRedistribute.forEach(packet => {
                const randomEdge = healthyEdges[Math.floor(Math.random() * healthyEdges.length)];
                
                // Detach from central node
                packet.isAttached = false;
                packet.attachedNode = null;
                
                // Assign to new edge with random direction and progress
                packet.edge = randomEdge;
                packet.direction = Math.random() < 0.5 ? 1 : -1;
                packet.progress = Math.random(); // Random position along edge
                packet.lateralOffset = packet.direction === 1 ? 5 : -5;
            });
        }
        
        function updateNodeStatus(node, newStatus) {
            if(!node || node.state !== 'alive' || node.status === newStatus) return;
            if (node.isSatellite) return;
            
            const previousStatus = node.status;
            const isRoot = node.parent === null;
            if (isRoot && (newStatus === 'malware' || newStatus === 'botnet' || newStatus === 'commandControl')) {
                // CRITICAL ALERT for central node infection!
                logEvent('centralCompromised', { node });
                
                node.isSelfHealing = false; // Reset healing state on new infection
                node.hasRecoveryShield = false; // Clear recovery shield on new infection
                // Reset Bot Defense Mode immediately
                node.botDefenseModeActive = false;
                node.botDefenseTargets = [];
                node.botDefenseLastBurst = 0;

                // Redistribute immunity packets back into the network
                if (node.attachedImmunityPackets && node.attachedImmunityPackets.length > 0) {
                    redistributeImmunityPackets(node);
                }
            }

            if (node.isGuardian && (newStatus === 'malware' || newStatus === 'botnet' || newStatus === 'commandControl')) {
                demoteGuardian(node, 'guardianDemoted');
                newStatus = 'malware';
            }

            node.status = newStatus;
            node.statusChangedAt = Date.now();
            node.isHealing = false;
            
            // Clear immunity healing state when node changes status
            if (newStatus !== 'malware' && newStatus !== 'botnet' && newStatus !== 'commandControl') {
                node.isImmunityHealing = false;
                node.immunityHealingStartTime = 0;
                // Detach all immunity packets
                node.attachedImmunityPackets.forEach(packet => {
                    packet.isAttached = false;
                    packet.attachedNode = null;
                });
                node.attachedImmunityPackets = [];
            }

            if (newStatus === 'malware' || newStatus === 'botnet' || newStatus === 'commandControl') {
                if (!node.infectedAt) {
                    node.infectedAt = Date.now();
                    node.pulseDelay = 2000 + Math.random() * 4000; // 2-6 seconds
                    node.spreadDelay = 500 + Math.random() * 2500; // 0.5-3 seconds
                    node.canSpread = Math.random() > 0.05; // 95% chance to spread, 5% chance not to 
                }
            } else if (newStatus === 'red') {
                if (node.isGroundStation && node.parent && Math.random() < 0.10) {
                    markBranchForRetraction(node, { allowGroundStation: true });
                }
            } else if (newStatus === 'green' || (isRoot && newStatus === 'blue')) {
                node.infectedAt = null;
                node.spreadDelay = 0;
                node.canSpread = true;
                node.isTargeted = false;
                
                // Track recovery if previous status was infected
                if (previousStatus === 'malware' || previousStatus === 'botnet' || previousStatus === 'red' || previousStatus === 'yellow') {
                    incrementStat('totalRecoveries');
                }
                
                // 25% chance to gain firewall when recovering to healthy status
                // (if node doesn't already have one)
                if (!node.hasFirewall && Math.random() < 0.25) {
                    node.hasFirewall = true;
                    logEvent('firewallGained', { node });
                }
            }

            const statusLogKey = STATUS_LOG_KEYS[newStatus];
            if (statusLogKey) {
                logEvent(statusLogKey, {
                    node,
                    previousStatus,
                    isGroundStation: node.isGroundStation
                });
            }

            if (newStatus === 'red' || newStatus === 'malware' || newStatus === 'botnet') propagateStatus(node, 'yellow', true);
            if (newStatus === 'green' || (isRoot && newStatus === 'blue')) propagateStatus(node, 'green', true);
        }

        function propagateStatus(parentNode, status, preserveMalware = false) {
            for (const child of parentNode.children) {
                if (!child || child.isSatellite) continue;
                // If we are propagating a healing status, do not overwrite an active 'malware' or 'botnet' status.
                if (preserveMalware && (child.status === 'malware' || child.status === 'botnet' || child.status === 'commandControl')) {
                    // Recursively call to heal nodes *below* this infected one.
                    propagateStatus(child, status, preserveMalware);
                    // Then, skip changing the status of the malware node itself.
                    continue;
                }
                
                child.status = status;
                propagateStatus(child, status, preserveMalware);
            }
        }

        // --- Self-healing and dynamic growth functions ---
        function healNetwork() {
            const HEAL_DELAY = 2000 / healSpeedMultiplier;
            const SELF_HEAL_DELAY = 3000 / healSpeedMultiplier; // Yellow nodes with healthy parents heal after 3 seconds
            
            // First, check for yellow nodes with healthy parents that should self-heal
            const yellowNodesWithHealthyParent = nodes.filter(n => 
                n.status === 'yellow' && 
                n.parent && 
                n.state === 'alive' &&
                !n.isSatellite &&
                (n.parent.status === 'green' || (n.parent.parent === null && n.parent.status === 'blue')) &&
                Date.now() > n.statusChangedAt + SELF_HEAL_DELAY
            );
            
            if (yellowNodesWithHealthyParent.length > 0) {
                // Heal these nodes directly to green
                yellowNodesWithHealthyParent.forEach(node => {
                    updateNodeStatus(node, 'green');
                });
                return;
            }
            
            // Then, handle yellow nodes with red parents (adoption logic)
            const yellowNodes = nodes.filter(n => 
                n.status === 'yellow' && 
                n.parent && 
                n.parent.status === 'red' && 
                !n.isHealing &&
                Date.now() > n.parent.statusChangedAt + HEAL_DELAY
            );
            if (yellowNodes.length === 0) return;

            const targetNode = yellowNodes[0];
            
            const potentialHealers = nodes.filter(n => 
                n.status === 'green' && 
                n.state === 'alive' &&
                n.id !== targetNode.id && 
                !isDescendant(targetNode, n)
            );

            if (potentialHealers.length === 0) return;
            
            let closestHealer = null;
            let minDistance = Infinity;
            let minCost = Infinity;
            const centerX = canvas.width / 2;

            potentialHealers.forEach(healer => {
                const dx = healer.x - targetNode.x;
                const dy = targetNode.y - healer.y;
                const distanceSq = dx * dx + dy * dy;
                
                let penalty = 0;
                // Add a penalty for crossing the vertical centerline to prevent criss-crossing
                if ((targetNode.x > centerX && healer.x < centerX) || (targetNode.x < centerX && healer.x > centerX)) {
                    penalty = 300 * 300; // Large penalty equivalent to a 300px distance squared
                }

                const cost = distanceSq + penalty;

                if (cost < minCost) {
                    minCost = cost;
                    minDistance = distanceSq;
                    closestHealer = healer;
                }
            });

            if (closestHealer && minDistance < 200 * 200) {
                targetNode.isHealing = true;

                const oldParent = targetNode.parent;
                edges = edges.filter(edge => !(edge.from === oldParent && edge.to === targetNode));
                oldParent.children = oldParent.children.filter(child => child.id !== targetNode.id);

                targetNode.parent = closestHealer;
                closestHealer.children.push(targetNode);
                edges.push({ from: closestHealer, to: targetNode });

                updateNodeStatus(targetNode, 'green');
            }
        }
        
        function adoptRedNodes() {
            const ADOPTION_DELAY = 2000 / healSpeedMultiplier;
            const redNodesToAdopt = nodes.filter(n =>
                n.status === 'red' &&
                n.parent && 
                !n.isHealing &&
                n.children.length > 0 &&
                Date.now() > n.statusChangedAt + ADOPTION_DELAY
            );

            if (redNodesToAdopt.length === 0) return;

            const targetNode = redNodesToAdopt[0];

            const potentialAdopters = nodes.filter(n =>
                n.status === 'green' &&
                n.state === 'alive' &&
                n.id !== targetNode.id &&
                n.parent !== targetNode && 
                targetNode.parent.id !== n.id && 
                !isDescendant(targetNode, n)
            );

            if (potentialAdopters.length === 0) return;

            let closestAdopter = null;
            let minDistance = Infinity;
            let minCost = Infinity;
            const centerX = canvas.width / 2;

            potentialAdopters.forEach(adopter => {
                const dx = adopter.x - targetNode.x;
                const dy = adopter.y - targetNode.y;
                const distanceSq = dx * dx + dy * dy;

                let penalty = 0;
                // Add a penalty for crossing the vertical centerline to prevent criss-crossing
                if ((targetNode.x > centerX && adopter.x < centerX) || (targetNode.x < centerX && adopter.x > centerX)) {
                    penalty = 300 * 300; // Large penalty equivalent to a 300px distance squared
                }
                
                const cost = distanceSq + penalty;

                if (cost < minCost) {
                    minCost = cost;
                    minDistance = distanceSq;
                    closestAdopter = adopter;
                }
            });

            if (closestAdopter && minDistance < 250 * 250) { 
                targetNode.isHealing = true;

                const oldParent = targetNode.parent;
                if (oldParent) {
                    edges = edges.filter(edge => !(edge.from === oldParent && edge.to === targetNode));
                    oldParent.children = oldParent.children.filter(c => c !== targetNode);
                }

                targetNode.parent = closestAdopter;
                closestAdopter.children.push(targetNode);
                edges.push({ from: closestAdopter, to: targetNode });

                updateNodeStatus(targetNode, 'green');
            }
        }

        function countDescendants(node) {
            let count = node.children.filter(child => child && !child.isSatellite).length;
            node.children.forEach(child => {
                if (!child || child.isSatellite) return;
                count += countDescendants(child);
            });
            return count;
        }

        function isNodeInDDOSBranch(node) {
            // Check if node is part of a branch under DDOS attack
            if (!node || node.parent === null) return false; // Central node never affected
            
            // Walk up to find the main branch (direct child of central)
            let current = node;
            while (current.parent && current.parent.parent !== null) {
                current = current.parent;
            }
            
            // current is now the main branch node (direct child of central)
            return current.isUnderDDOS === true;
        }

        function hasBotnetMeshConnections(node) {
            // Check if a node has any botnet mesh connections
            return edges.some(edge => 
                edge.isBotnetMesh && 
                (edge.from === node || edge.to === node)
            );
        }

        function getNodeDefenseBonus(node) {
            if (!node) return 0;
            if (node.isGuardian) return 0.75;
            if (node.parent === null) return 0; // Central node uses different logic

            const descendantCount = countDescendants(node);

            if (descendantCount >= 6) return 0.15; // 15% bonus
            if (descendantCount >= 4) return 0.10; // 10% bonus
            if (descendantCount >= 2) return 0.05; // 5% bonus
            return 0; // No bonus
        }

        function getNodeDepth(node) {
            let depth = 0;
            let current = node;
            while (current.parent) {
                depth++;
                current = current.parent;
            }
            return depth;
        }

        function isDescendant(parent, potentialChild) {
            if (parent.children.length === 0) return false;
            for (const child of parent.children) {
                if (child.id === potentialChild.id) return true;
                if (isDescendant(child, potentialChild)) return true;
            }
            return false;
        }

        function resolveCrossings() {
            const CROSSING_CHECK_DELAY = 1000; 
            if (Date.now() - lastCrossingCheck < CROSSING_CHECK_DELAY) {
                return;
            }
            lastCrossingCheck = Date.now();

            const edgesToCheck = edges.filter(e =>
                e.from && e.to &&
                e.from.state === 'alive' &&
                e.to.state === 'alive'
            );

            for (let i = 0; i < edgesToCheck.length; i++) {
                for (let j = i + 1; j < edgesToCheck.length; j++) {
                    const edge1 = edgesToCheck[i];
                    const edge2 = edgesToCheck[j];
                    
                    if (edge1.from === edge2.from || edge1.from === edge2.to || edge1.to === edge2.from || edge1.to === edge2.to) {
                        continue;
                    }
                    
                    if (linesIntersect(edge1.from, edge1.to, edge2.from, edge2.to)) {
                        const nodeToMove = getNodeDepth(edge1.to) > getNodeDepth(edge2.to) ? edge1.to : edge2.to;
                        const potentialNewParent = nodeToMove === edge1.to ? edge2.from : edge1.from;
                        const oldParent = nodeToMove.parent;

                        if (
                            oldParent &&
                            nodeToMove.status !== 'malware' &&
                            (potentialNewParent.status === 'green' || potentialNewParent.status === 'blue') &&
                            !isDescendant(nodeToMove, potentialNewParent) &&
                            potentialNewParent !== nodeToMove
                        ) {
                            oldParent.children = oldParent.children.filter(child => child.id !== nodeToMove.id);
                            nodeToMove.parent = potentialNewParent;
                            potentialNewParent.children.push(nodeToMove);
                            
                            const edgeToUpdate = edges.find(e => e.to.id === nodeToMove.id);
                            if (edgeToUpdate) {
                                edgeToUpdate.from = potentialNewParent;
                            }
                            return; 
                        }
                    }
                }
            }
        }


        function spreadMalware() {
            const MULTI_INFECTION_CHANCE = 0.10 * attackFreqMultiplier;
            const DOWNSTREAM_INFECTION_CHANCE = 0.08 * attackFreqMultiplier;
            const UPSTREAM_ATTACK_CHANCE = 0.02 * attackFreqMultiplier;

            // Filter for malware/botnet nodes that are ready to spread (passed their delay and have spreading enabled)
            const malwareNodes = nodes.filter(n => 
                (n.status === 'malware' || n.status === 'botnet' || n.status === 'commandControl') && 
                n.state === 'alive' && 
                n.spreadingInfections.length === 0 &&
                n.canSpread &&
                n.infectedAt &&
                Date.now() > n.infectedAt + n.spreadDelay
            );

            malwareNodes.forEach(node => {
                if (Math.random() < MULTI_INFECTION_CHANCE) {
                    const neighbors = [...node.children];
                    if (node.parent) {
                        neighbors.push(node.parent);
                    }

                    const validTargets = neighbors.filter(n => n && !n.isSatellite && n.state === 'alive' && n.status !== 'malware' && n.status !== 'botnet' && !n.isBeingInfected);

                    validTargets.forEach(target => {
                        node.spreadingInfections.push({ target: target, startTime: Date.now() });
                        if (target.parent !== null) {
                            target.isBeingInfected = true;
                        }
                    });
                } else {
                    if (Math.random() < DOWNSTREAM_INFECTION_CHANCE) {
                        const potentialTargets = node.children.filter(n => n && !n.isSatellite && n.state === 'alive' && n.status !== 'malware' && !n.isBeingInfected);
                        if (potentialTargets.length > 0) {
                            const target = potentialTargets[Math.floor(Math.random() * potentialTargets.length)];
                            node.spreadingInfections.push({ target: target, startTime: Date.now() });
                            target.isBeingInfected = true;
                            return;
                        }
                    }

                    if (Math.random() < UPSTREAM_ATTACK_CHANCE) {
                        const parent = node.parent;
                        if (parent && !parent.isSatellite && parent.state === 'alive' && parent.status !== 'malware' && parent.status !== 'botnet' && !parent.isBeingInfected) {
                            node.spreadingInfections.push({ target: parent, startTime: Date.now() });
                            if (parent.parent !== null) {
                                parent.isBeingInfected = true;
                            }
                        }
                    }
                }
            });
        }


        function optimizeBotnetMesh() {
            // Periodically restructure mesh to prefer shorter connections
            if (Math.random() > 0.05) return; // Only optimize 5% of frames
            
            const MAX_MESH_CONNECTIONS = 5;
            const MAX_CC_MESH_CONNECTIONS = 10; // C&C nodes can have more connections
            
            // Helper function to get max connections for a node
            const getMaxConnections = (node) => {
                return (node.status === 'commandControl' || node.isCommandControl) 
                    ? MAX_CC_MESH_CONNECTIONS 
                    : MAX_MESH_CONNECTIONS;
            };
            
            // Find all botnet nodes (including C&C)
            const botnetNodes = nodes.filter(n => 
                (n.status === 'botnet' || n.status === 'commandControl') && 
                n.state === 'alive' && 
                n.parent !== null
            );
            
            if (botnetNodes.length < 3) return;
            
            // For each botnet node, consider optimizing its connections
            botnetNodes.forEach(node => {
                // Skip if this botnet is currently participating in a DDOS attack
                const isInActiveDDOS = nodes.some(n => 
                    n.status === 'commandControl' && 
                    n.ddosState === 'active' && 
                    n.ddosBotnets && 
                    n.ddosBotnets.includes(node)
                );
                if (isInActiveDDOS) return;
                
                // Get current mesh connections for this node
                const currentMeshEdges = edges.filter(edge => 
                    edge.isBotnetMesh && (edge.from === node || edge.to === node)
                );
                
                if (currentMeshEdges.length === 0) return;
                
                // Find the longest current connection
                let longestEdge = null;
                let longestDistance = 0;
                
                currentMeshEdges.forEach(edge => {
                    const other = edge.from === node ? edge.to : edge.from;
                    const dx = other.x - node.x;
                    const dy = other.y - node.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > longestDistance) {
                        longestDistance = distance;
                        longestEdge = edge;
                    }
                });
                
                // Find nearby botnet nodes that could be better connections
                const nearbyBotnets = botnetNodes.filter(other => {
                    if (other === node) return false;
                    if (other.parent === node || node.parent === other) return false;
                    
                    // Check if already connected
                    const alreadyConnected = edges.some(edge => 
                        edge.isBotnetMesh &&
                        ((edge.from === node && edge.to === other) || 
                         (edge.from === other && edge.to === node))
                    );
                    if (alreadyConnected) return false;
                    
                    // Calculate distance
                    const dx = other.x - node.x;
                    const dy = other.y - node.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Only consider if significantly closer than longest edge
                    return distance < longestDistance * 0.7;
                });
                
                if (nearbyBotnets.length === 0) return;
                
                // Find the closest candidate
                let closestNode = null;
                let closestDistance = Infinity;
                
                nearbyBotnets.forEach(other => {
                    // Check if other node has room for more connections
                    const otherMeshCount = edges.filter(edge => 
                        edge.isBotnetMesh && (edge.from === other || edge.to === other)
                    ).length;
                    
                    if (otherMeshCount >= getMaxConnections(other)) return;
                    
                    const dx = other.x - node.x;
                    const dy = other.y - node.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestNode = other;
                    }
                });
                
                // If we found a better connection, make the swap
                if (closestNode && longestEdge) {
                    // Remove longest edge
                    const edgeIndex = edges.indexOf(longestEdge);
                    if (edgeIndex !== -1) {
                        edges.splice(edgeIndex, 1);
                    }
                    
                    // Add new shorter edge
                    edges.push({ from: node, to: closestNode, isBotnetMesh: true });
                }
            });
        }

        function detectAndFormBotnets() {
            // First, remove all botnet mesh connections that involve non-botnet nodes
            edges = edges.filter(edge => {
                if (edge.isBotnetMesh) {
                    // Keep mesh edge only if both nodes are still malware, botnet, or C&C
                    return (edge.from.status === 'malware' || edge.from.status === 'botnet' || edge.from.status === 'commandControl') &&
                           (edge.to.status === 'malware' || edge.to.status === 'botnet' || edge.to.status === 'commandControl') &&
                           edge.from.state === 'alive' && edge.to.state === 'alive';
                }
                return true; // Keep non-mesh edges
            });
            
            // Find all infected nodes (malware, botnet, or C&C, excluding central node)
            const infectedNodes = nodes.filter(n => 
                (n.status === 'malware' || n.status === 'botnet' || n.status === 'commandControl') && 
                n.state === 'alive' && 
                n.parent !== null
            );
            
            // Find connected clusters of infected nodes
            const visited = new Set();
            const clusters = [];
            
            function findConnectedInfected(node, cluster) {
                if (visited.has(node.id) || (node.status !== 'malware' && node.status !== 'botnet' && node.status !== 'commandControl') || node.parent === null) return;
                
                visited.add(node.id);
                cluster.push(node);
                
                // Check connected nodes (parent, children, AND mesh connections)
                const connected = [...node.children];
                if (node.parent) connected.push(node.parent);
                
                // Also check for botnet mesh connections
                edges.forEach(edge => {
                    if (edge.isBotnetMesh) {
                        if (edge.from === node && !connected.includes(edge.to)) {
                            connected.push(edge.to);
                        } else if (edge.to === node && !connected.includes(edge.from)) {
                            connected.push(edge.from);
                        }
                    }
                });
                
                connected.forEach(connectedNode => {
                    if (connectedNode && (connectedNode.status === 'malware' || connectedNode.status === 'botnet' || connectedNode.status === 'commandControl')) {
                        findConnectedInfected(connectedNode, cluster);
                    }
                });
            }
            
            // Find all clusters
            infectedNodes.forEach(node => {
                if (!visited.has(node.id)) {
                    const cluster = [];
                    findConnectedInfected(node, cluster);
                    clusters.push(cluster);
                }
            });
            
            // Process each cluster
            clusters.forEach(cluster => {
                // Check if cluster is large enough to form a C&C node
                if (cluster.length >= 7) {
                    // Filter out any existing C&C nodes from the cluster
                    const botnetNodesInCluster = cluster.filter(n => n.status === 'botnet');
                    
                    // Only form C&C if we have 7+ botnet nodes (not C&C)
                    if (botnetNodesInCluster.length >= 7) {
                        // Filter out first-level branch nodes (direct children of central node)
                        // C&C should be deeper in the mesh, behind protective botnet nodes
                        const eligibleForCC = botnetNodesInCluster.filter(n => 
                            n.parent !== nodes[0]
                        );
                        
                        // Require at least 7 eligible nodes - don't allow first-level nodes as C&C
                        if (eligibleForCC.length < 7) {
                            return; // Skip C&C formation for this cluster
                        }
                        
                        // Sort nodes by number of descendants (leaf nodes first)
                        const nodesWithDescendants = eligibleForCC.map(node => ({
                            node: node,
                            descendants: countDescendants(node)
                        })).sort((a, b) => a.descendants - b.descendants);
                        
                        // Pick 4 nodes with fewest descendants to collapse into C&C
                        // The 5th node (at index 4) becomes the C&C node itself
                        const nodesToRemove = nodesWithDescendants.slice(0, 4).map(n => n.node);
                        const ccNode = nodesWithDescendants[4].node; // 5th node becomes C&C
                        
                        // Retract the 4 nodes sequentially
                        nodesToRemove.forEach((node, index) => {
                            // Delay retraction sequentially for visual effect (0.5 second intervals)
                            setTimeout(() => {
                                // Find nodes connected via mesh edges before removing
                                const meshConnectedNodes = [];
                                edges.forEach(edge => {
                                    if (edge.isBotnetMesh) {
                                        if (edge.from === node && edge.to.state === 'alive' && !nodesToRemove.includes(edge.to)) {
                                            meshConnectedNodes.push(edge.to);
                                        } else if (edge.to === node && edge.from.state === 'alive' && !nodesToRemove.includes(edge.from)) {
                                            meshConnectedNodes.push(edge.from);
                                        }
                                    }
                                });
                                
                                // Reassign children before retracting
                                if (node.children.length > 0) {
                                    node.children.forEach(child => {
                                        // Find a safe parent - prefer one that's NOT being removed
                                        let safeParent = node.parent;
                                        
                                        // If current parent is also being removed, use ccNode instead
                                        if (nodesToRemove.includes(safeParent)) {
                                            safeParent = ccNode;
                                        }
                                        
                                        // If parent is nucleus or ccNode, keep them there
                                        if (!nodesToRemove.includes(child) && safeParent && safeParent.state === 'alive') {
                                            child.parent = safeParent;
                                            safeParent.children.push(child);
                                            // Update edge
                                            edges = edges.filter(e => !(e.from === node && e.to === child));
                                            if (!edges.some(e => e.from === safeParent && e.to === child)) {
                                                edges.push({ from: safeParent, to: child });
                                            }
                                        }
                                    });
                                    // Clear children array to allow retraction animation to proceed
                                    node.children = [];
                                }
                                
                                // Reconnect mesh-connected nodes to ccNode
                                meshConnectedNodes.forEach(connectedNode => {
                                    // Connect to ccNode if not already connected
                                    const alreadyConnected = edges.some(e => 
                                        (e.from === ccNode && e.to === connectedNode) ||
                                        (e.from === connectedNode && e.to === ccNode)
                                    );
                                    if (!alreadyConnected) {
                                        edges.push({ from: ccNode, to: connectedNode, isBotnetMesh: true });
                                    }
                                });
                                
                                // Remove from parent's children
                                if (node.parent) {
                                    node.parent.children = node.parent.children.filter(c => c !== node);
                                }
                                
                                // Clean up immunity packets attached to this node
                                if (node.attachedImmunityPackets && node.attachedImmunityPackets.length > 0) {
                                    node.attachedImmunityPackets.forEach(packet => {
                                        packet.active = false;
                                        packet.isAttached = false;
                                        packet.attachedNode = null;
                                    });
                                    node.attachedImmunityPackets = [];
                                    node.isImmunityHealing = false;
                                    node.immunityHealingStartTime = 0;
                                }
                                
                                // Mark for retraction
                                node.state = 'retracting';
                                
                                // Clear targeting flag and remove any pulses targeting this node
                                node.isTargeted = false;
                                
                                // Remove pulses targeting this node to prevent particle shower
                                pulses = pulses.filter(p => p.target !== node);
                                
                                // Remove mesh edges
                                edges = edges.filter(e => e.from !== node && e.to !== node);
                            }, index * 500); // 500ms delay between each (2 seconds total for 4 nodes)
                        });
                        
                        const clusterSize = cluster.length;

                        // Transform the ccNode to C&C after all nodes retract
                        setTimeout(() => {
                            if (ccNode.state === 'alive') {
                                ccNode.status = 'commandControl';
                                ccNode.isCommandControl = true;
                                ccNode.statusChangedAt = Date.now();
                                ccNode.baseRadius = 20;
                                ccNode.targetRadius = 20;
                                ccNode.currentColor = { ...colors.commandControl };
                                logEvent('commandControlDetected', { node: ccNode, clusterSize });
                            }
                        }, 2000); // After 4 nodes retract (2 seconds)
                        
                        // Create mesh connections from C&C to remaining botnet nodes in cluster
                        // (excluding the removed nodes and the ccNode itself)
                        // C&C can have up to 10 connections, prioritize closer nodes
                        const remainingNodes = cluster.filter(n => 
                            !nodesToRemove.includes(n) && n !== ccNode
                        );
                        
                        // Sort by distance to prioritize closer nodes
                        const nodesWithDistance = remainingNodes.map(node => ({
                            node: node,
                            distance: Math.sqrt((node.x - ccNode.x) ** 2 + (node.y - ccNode.y) ** 2)
                        })).sort((a, b) => a.distance - b.distance);
                        
                        // Count existing C&C mesh connections (start at 0)
                        let ccMeshCount = 0;
                        const MAX_CC_MESH = 10;
                        
                        nodesWithDistance.forEach(({node}) => {
                            if (ccMeshCount >= MAX_CC_MESH) return; // C&C at max connections
                            
                            // Check if connection already exists
                            const edgeExists = edges.some(e => 
                                (e.from === ccNode && e.to === node) ||
                                (e.from === node && e.to === ccNode)
                            );
                            
                            if (!edgeExists) {
                                edges.push({ from: ccNode, to: node, isBotnetMesh: true });
                                ccMeshCount++;
                            }
                        });
                        
                        // Log C&C bridge creation
                        if (ccMeshCount > 0) {
                            logEvent('ccMeshBridged', { node: ccNode, count: ccMeshCount });
                        }
                        
                        return; // Skip normal botnet processing for this cluster
                    }
                }
                
                if (cluster.length >= 3) {
                    // Convert to botnet and create mesh connections
                    cluster.forEach(node => {
                        if (node.status !== 'botnet' && node.status !== 'commandControl') {
                            node.status = 'botnet';
                            node.statusChangedAt = Date.now();
                        }
                    });
                    
                    // Create limited mesh connections (max 3 per node, 10 for C&C) to reduce clutter
                    const MAX_MESH_CONNECTIONS = 3;
                    const MAX_CC_MESH_CONNECTIONS = 10;
                    
                    // Helper function to get max connections for a node
                    const getMaxConnections = (node) => {
                        return (node.status === 'commandControl' || node.isCommandControl) 
                            ? MAX_CC_MESH_CONNECTIONS 
                            : MAX_MESH_CONNECTIONS;
                    };
                    
                    // Track mesh connection counts for each node
                    const meshCounts = new Map();
                    cluster.forEach(node => meshCounts.set(node.id, 0));
                    
                    // Count existing mesh connections
                    edges.forEach(edge => {
                        if (edge.isBotnetMesh) {
                            if (cluster.includes(edge.from)) {
                                meshCounts.set(edge.from.id, (meshCounts.get(edge.from.id) || 0) + 1);
                            }
                            if (cluster.includes(edge.to)) {
                                meshCounts.set(edge.to.id, (meshCounts.get(edge.to.id) || 0) + 1);
                            }
                        }
                    });
                    
                    // Create new mesh connections up to the limit (within cluster)
                    for (let i = 0; i < cluster.length; i++) {
                        const nodeA = cluster[i];
                        
                        // Skip if this node already has max connections
                        if (meshCounts.get(nodeA.id) >= getMaxConnections(nodeA)) continue;
                        
                        // Skip if this botnet is currently participating in a DDOS attack
                        const isNodeAInDDOS = nodes.some(n => 
                            n.status === 'commandControl' && 
                            n.ddosState === 'active' && 
                            n.ddosBotnets && 
                            n.ddosBotnets.includes(nodeA)
                        );
                        if (isNodeAInDDOS) continue;
                        
                        for (let j = i + 1; j < cluster.length; j++) {
                            const nodeB = cluster[j];
                            
                            // Skip if either node has max connections
                            if (meshCounts.get(nodeB.id) >= getMaxConnections(nodeB)) continue;
                            if (meshCounts.get(nodeA.id) >= getMaxConnections(nodeA)) break;
                            
                            // Skip if nodeB is also participating in a DDOS attack
                            const isNodeBInDDOS = nodes.some(n => 
                                n.status === 'commandControl' && 
                                n.ddosState === 'active' && 
                                n.ddosBotnets && 
                                n.ddosBotnets.includes(nodeB)
                            );
                            if (isNodeBInDDOS) continue;
                            
                            // Check if edge already exists
                            const edgeExists = edges.some(edge => 
                                (edge.from === nodeA && edge.to === nodeB) ||
                                (edge.from === nodeB && edge.to === nodeA)
                            );
                            
                            // Create mesh edge if possible
                            if (!edgeExists && nodeA.parent !== nodeB && nodeB.parent !== nodeA) {
                                edges.push({ from: nodeA, to: nodeB, isBotnetMesh: true });
                                meshCounts.set(nodeA.id, meshCounts.get(nodeA.id) + 1);
                                meshCounts.set(nodeB.id, meshCounts.get(nodeB.id) + 1);
                            }
                        }
                    }
                    
                    // Bridge to nearby infected nodes within the same branch
                    const BRIDGE_DISTANCE = 100; // Maximum distance to bridge within branch
                    cluster.forEach(nodeA => {
                        // Skip if already at max connections
                        if (meshCounts.get(nodeA.id) >= getMaxConnections(nodeA)) return;
                        
                        // Skip if this botnet is currently participating in a DDOS attack
                        const isInActiveDDOS = nodes.some(n => 
                            n.status === 'commandControl' && 
                            n.ddosState === 'active' && 
                            n.ddosBotnets && 
                            n.ddosBotnets.includes(nodeA)
                        );
                        if (isInActiveDDOS) return;
                        
                        // Find nearby infected nodes NOT in this cluster (but in same branch)
                        infectedNodes.forEach(nodeB => {
                            // Skip if same cluster or already at max
                            if (cluster.includes(nodeB)) return;
                            if (!meshCounts.has(nodeB.id)) meshCounts.set(nodeB.id, 0);
                            if (meshCounts.get(nodeB.id) >= getMaxConnections(nodeB)) return;
                            if (meshCounts.get(nodeA.id) >= getMaxConnections(nodeA)) return;
                            
                            // Prevent cross-branch bridging - only allow within same root branch
                            const branchA = getRootBranch(nodeA);
                            const branchB = getRootBranch(nodeB);
                            if (branchA !== branchB) return;
                            
                            // Prevent mesh connections if EITHER branch is under DDOS attack
                            if (nodeA.isUnderDDOS || (branchA && branchA.isUnderDDOS)) return;
                            if (nodeB.isUnderDDOS || (branchB && branchB.isUnderDDOS)) return;
                            
                            // Check distance
                            const dx = nodeB.x - nodeA.x;
                            const dy = nodeB.y - nodeA.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance <= BRIDGE_DISTANCE) {
                                // Check if edge already exists
                                const edgeExists = edges.some(edge => 
                                    (edge.from === nodeA && edge.to === nodeB) ||
                                    (edge.from === nodeB && edge.to === nodeA)
                                );
                                
                                // Create bridge connection
                                if (!edgeExists && nodeA.parent !== nodeB && nodeB.parent !== nodeA) {
                                    edges.push({ from: nodeA, to: nodeB, isBotnetMesh: true });
                                    meshCounts.set(nodeA.id, meshCounts.get(nodeA.id) + 1);
                                    meshCounts.set(nodeB.id, meshCounts.get(nodeB.id) + 1);
                                    logEvent('botnetBridged');
                                }
                            }
                        });
                    });
                } else {
                    // Cluster has fewer than 3 nodes - downgrade botnets back to malware
                    cluster.forEach(node => {
                        if (node.status === 'botnet') {
                            node.status = 'malware';
                            node.statusChangedAt = Date.now();
                        }
                    });
                    
                    // Remove mesh connections for this small cluster
                    edges = edges.filter(edge => {
                        if (edge.isBotnetMesh) {
                            const involvesCluster = cluster.includes(edge.from) || cluster.includes(edge.to);
                            return !involvesCluster; // Remove if it involves this cluster
                        }
                        return true;
                    });
                }
            });
        }

        function spontaneouslySprout() {
            if (Math.random() > 0.05) return;

            const potentialParents = nodes.filter(n => n.state === 'alive' && n.status === 'green' && n.children.length < 3);
            if (potentialParents.length === 0) return;

            const parentNode = potentialParents[Math.floor(Math.random() * potentialParents.length)];

            // IMPROVED: Use space-probing for spontaneous growth
            const angle = Math.random() * Math.PI * 2;
            const dist = 40 + Math.random() * 20;
            const optimal = findOptimalBranchPosition(parentNode, angle, dist);

            const childNode = new Node(Date.now() + Math.random(), optimal.x, optimal.y, parentNode);
            parentNode.children.push(childNode);
            nodes.push(childNode);
            edges.push({ from: parentNode, to: childNode });
            applyParentStatusToChild(parentNode, childNode);
        }


        function simulateNetworkEvents() {
            const rootNode = nodes[0];
            if (rootNode) {
                const SELF_HEAL_DELAY = 5000 / healSpeedMultiplier;
                if ((rootNode.status === 'malware' || rootNode.status === 'botnet' || rootNode.status === 'commandControl') && !rootNode.isSelfHealing) {
                    if (Date.now() > rootNode.statusChangedAt + SELF_HEAL_DELAY) {
                        rootNode.isSelfHealing = true;
                        rootNode.selfHealingStartTime = Date.now();
                        const directChildren = (rootNode.children || []).filter(ch => ch && ch.state === 'alive');
                        rootNode.selfHealingPacketCap = directChildren.length * 4 * 2; // double the normal per-branch spawn
                        rootNode.selfHealingPacketsCreated = 0;
                        rootNode.selfHealingDispatchAllowance = 0;
                        logEvent('centralUnderAttack');
                    }
                }
            }
            
            const aliveNodes = nodes.filter(n => n.state === 'alive' && n.parent !== null && !n.isSatellite);
            if (aliveNodes.length === 0) return;

            const RED_NODE_TIMEOUT = 10000 / healSpeedMultiplier;
            aliveNodes.filter(n => n.status === 'red').forEach(node => {
                // Allow all red nodes to heal after timeout to prevent deadlocks
                if (Date.now() > node.statusChangedAt + RED_NODE_TIMEOUT) {
                    // Default: 10% chance to become malware, 90% chance to heal to green
                    // If hit by ping of death: 50% chance to become malware!
                    let malwareChance = 0.10;
                    if (node.hitByPingOfDeath) {
                        malwareChance = 0.50; // Significantly higher chance
                        node.hitByPingOfDeath = false; // Clear the flag
                    }
                    const newStatus = Math.random() < malwareChance ? 'malware' : 'green';
                    updateNodeStatus(node, newStatus);

                    // Chance to promote recovered nodes to guardians if they endured a ping of death
                    if (newStatus === 'green' && node.hitByPingOfDeath === false && Math.random() < 0.25) {
                        promoteToGuardian(node, 'guardianPromotionPingRecovery');
                    }
                }
            });

            // DISABLED: Logic for decaying entire branches that are down for 5 seconds
            // const BRANCH_DECAY_TIMEOUT = 5000;
            // if (rootNode && rootNode.children) {
            //     const downBranches = rootNode.children.filter(branch => 
            //         branch.status === 'red' && 
            //         branch.state === 'alive'
            //     );

            //     downBranches.forEach(branch => {
            //         if (Date.now() > branch.statusChangedAt + BRANCH_DECAY_TIMEOUT) {
            //             markBranchForRetraction(branch);
            //         }
            //     });
            // }

            if (Math.random() < (0.30 * attackFreqMultiplier)) { // Red node frequency
                const target = aliveNodes[Math.floor(Math.random() * aliveNodes.length)];
                if (target.status === 'green') updateNodeStatus(target, 'red');
            }
            if (Math.random() < (0.05 * attackFreqMultiplier)) { // Malware infection rate
                const target = aliveNodes[Math.floor(Math.random() * aliveNodes.length)];
                if (target.status === 'green' && !target.isTargeted && target.remediationState === 'none') {
                    updateNodeStatus(target, 'malware');
                }
            }

            healNetwork();
            spontaneouslySprout();
            adoptRedNodes();
            spreadMalware();
            detectAndFormBotnets();
            evaluateBotDefenseMode();
            optimizeBotnetMesh();
            resolveCrossings();
        }

        function updateNetworkTopology() {
            const currentBranches = nodes.filter(n => n.parent === nodes[0] && (n.state === 'alive' || n.state === 'spawning')).length;
            const changeProbability = 0.1;

            if (currentBranches > desiredBranchCount) {
                pruneRandomBranch();
                pruneSingleNodeBranches();
                refreshSatelliteLongLinks();
                maintainGroundStationSatelliteChains();
                return;
            }

            if (Math.random() < changeProbability) pruneRandomBranch();
            pruneSingleNodeBranches();

            if (currentBranches < desiredBranchCount && Math.random() < changeProbability) {
                sproutNewBranch();
            }

            refreshSatelliteLongLinks();
            maintainGroundStationSatelliteChains();
        }

        function convertToGroundStation(node) {
            if (!node || node.parent !== nodes[0]) return;

            if (node.isGuardian) {
                demoteGuardian(node);
            }
            removeSatelliteChain(node);
            node.isGroundStation = true;
            node.groundStationEstablishedAt = Date.now();
            node.lastSatelliteChainCheck = Date.now();
            node.baseRadius = 24;
            node.targetRadius = node.baseRadius;
            node.shieldStrength = Math.max(node.shieldStrength, 0.65);
            node.currentColor = { ...colors.groundStation };
            node.hasFirewall = true;
            buildSatelliteChain(node);
            createPopParticles(node.x, node.y, colors.blue);
            logEvent('groundStationEstablished', { node });
        }

        function registerSatelliteEdge(groundStation, edge) {
            if (!groundStation || !edge) return;
            if (!groundStation.satelliteEdges) {
                groundStation.satelliteEdges = [];
            }
            if (!groundStation.satelliteEdges.includes(edge)) {
                groundStation.satelliteEdges.push(edge);
            }
            if (!edge.satelliteHosts) {
                edge.satelliteHosts = new Set();
            }
            edge.satelliteHosts.add(groundStation);
        }

        function unregisterSatelliteEdge(edge) {
            if (!edge) return;
            if (edge.satelliteHosts && edge.satelliteHosts.size > 0) {
                edge.satelliteHosts.forEach(host => {
                    if (host && host.satelliteEdges) {
                        host.satelliteEdges = host.satelliteEdges.filter(e => e !== edge);
                    }
                });
                edge.satelliteHosts.clear();
            }
        }

        function createSatelliteNode(groundStation, parent, baseX, baseY) {
            const satellite = new Node(Date.now() + Math.random(), baseX, baseY, parent);
            satellite.isSatellite = true;
            satellite.satelliteHost = groundStation;
            satellite.isTethered = true;
            satellite.status = 'green';
            satellite.currentColor = { ...colors.satellite };
            satellite.baseRadius = 9;
            satellite.targetRadius = satellite.baseRadius;
            satellite.radius = satellite.baseRadius;
            satellite.spawnProgress = 0;
            satellite.opacity = 0;
            satellite.state = 'spawning';
            satellite.canSpread = false;
            satellite.hasFirewall = false;
            satellite.children = [];

            parent.children.push(satellite);
            nodes.push(satellite);

            const wirelessEdge = {
                from: parent,
                to: satellite,
                isWirelessLink: true,
                pulseSeed: Math.random() * Math.PI * 2
            };

            edges.push(wirelessEdge);
            registerSatelliteEdge(groundStation, wirelessEdge);

            return satellite;
        }

        function getOutwardAngleFrom(node) {
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const bx = (node.baseX !== undefined ? node.baseX : node.x) - cx;
            const by = (node.baseY !== undefined ? node.baseY : node.y) - cy;
            return Math.atan2(by, bx);
        }

        function findSatelliteTargetPosition(groundStation, parent, baseAngle, distance) {
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const parentBx = (parent.baseX !== undefined ? parent.baseX : parent.x);
            const parentBy = (parent.baseY !== undefined ? parent.baseY : parent.y);
            const distFromCenterParent = Math.hypot(parentBx - cx, parentBy - cy);
            const perpendicular = baseAngle + Math.PI / 2;

            const angleOffsets = [0, 0.12, -0.12, 0.22, -0.22, 0.35, -0.35, 0.5, -0.5];
            const lateralScales = [0, 0.15, -0.15, 0.3, -0.3, 0.45, -0.45, 0.6, -0.6, 0.8, -0.8];
            const distanceMultipliers = [1.0, 1.1, 0.9, 1.25, 0.75];
            const outwardSlack = 6; // allow up to 6px non-outward movement near the border

            // Preferred: try using the current parent as the origin to place the next satellite one segment out
            const baseAngleParent = getOutwardAngleFrom(parent);
            const perpParent = baseAngleParent + Math.PI / 2;
            for (const sm of distanceMultipliers) {
                const segDist = distance * sm;
                for (const da of angleOffsets) {
                    const ang2 = baseAngleParent + da;
                    for (const ls of lateralScales) {
                        const lateral = ls * SATELLITE_CHAIN_SEGMENT_LENGTH;
                        const x = parentBx + Math.cos(ang2) * segDist + Math.cos(perpParent) * lateral;
                        const y = parentBy + Math.sin(ang2) * segDist + Math.sin(perpParent) * lateral;

                        const clampedX = Math.max(padding, Math.min(canvas.width - padding, x));
                        const clampedY = Math.max(padding, Math.min(canvas.height - padding, y));

                        const distFromCenter = Math.hypot(clampedX - cx, clampedY - cy);
                        if (distFromCenter < distFromCenterParent - outwardSlack) continue;

                        let candidate = { x: clampedX, y: clampedY };
                        if (segmentCrossesExistingEdges(parent, candidate)) {
                            const nudged = nudgeEndpointToAvoidCrossing(parent, candidate);
                            if (!nudged) continue;
                            candidate = nudged;
                            const d2 = Math.hypot(candidate.x - cx, candidate.y - cy);
                            if (d2 < distFromCenterParent - outwardSlack) continue;
                            if (segmentCrossesExistingEdges(parent, candidate)) continue;
                        }

                        return candidate;
                    }
                }
            }

            // Fallback: use the ground station as the origin for a broader search
            for (const dm of distanceMultipliers) {
                const dist = distance * dm;
                for (const da of angleOffsets) {
                    const ang = baseAngle + da;
                    for (const ls of lateralScales) {
                        const lateral = ls * SATELLITE_CHAIN_SEGMENT_LENGTH;
                        const x = groundStation.baseX + Math.cos(ang) * dist + Math.cos(perpendicular) * lateral;
                        const y = groundStation.baseY + Math.sin(ang) * dist + Math.sin(perpendicular) * lateral;

                        const clampedX = Math.max(padding, Math.min(canvas.width - padding, x));
                        const clampedY = Math.max(padding, Math.min(canvas.height - padding, y));

                        // Ensure outward: strictly farther from center than parent
                        const distFromCenter = Math.hypot(clampedX - cx, clampedY - cy);
                        if (distFromCenter < distFromCenterParent - outwardSlack) continue;

                        // Avoid crossing wired/guardian edges when tethering; try nudging if needed
                        let candidate = { x: clampedX, y: clampedY };
                        if (segmentCrossesExistingEdges(parent, candidate)) {
                            const nudged = nudgeEndpointToAvoidCrossing(parent, candidate);
                            if (!nudged) continue;
                            candidate = nudged;
                            // Still require outward
                            const d2 = Math.hypot(candidate.x - cx, candidate.y - cy);
                            if (d2 < distFromCenterParent - outwardSlack) continue;
                            if (segmentCrossesExistingEdges(parent, candidate)) continue;
                        }

                        return candidate;
                    }
                }
            }
            return null;
        }

        function buildSatelliteChain(groundStation) {
            if (!groundStation || !groundStation.isGroundStation) return;
            if (!groundStation.satelliteChain) groundStation.satelliteChain = [];
            if (!groundStation.satelliteEdges) groundStation.satelliteEdges = [];
            if (groundStation.satelliteChain.length > 0) return;

            const chainLengthRange = SATELLITE_CHAIN_MAX_LENGTH - SATELLITE_CHAIN_MIN_LENGTH + 1;
            const chainLength = SATELLITE_CHAIN_MIN_LENGTH + Math.floor(Math.random() * chainLengthRange);
            if (chainLength <= 0) return;

            // Always sprout outward from the canvas center
            let baseAngle = getOutwardAngleFrom(groundStation);

            let currentParent = groundStation;
            for (let i = 0; i < chainLength; i++) {
                // Recompute outward angle from the current parent each step
                baseAngle = getOutwardAngleFrom(currentParent);
                const distance = SATELLITE_CHAIN_SEGMENT_LENGTH;
                const pos = findSatelliteTargetPosition(groundStation, currentParent, baseAngle, distance);
                if (!pos) break; // stop if no safe outward position found
                const satellite = createSatelliteNode(groundStation, currentParent, pos.x, pos.y);
                groundStation.satelliteChain.push(satellite);
                currentParent = satellite;
            }

            if (groundStation.satelliteChain.length > 0) {
                logEvent('satelliteChainEstablished', { node: groundStation, count: groundStation.satelliteChain.length });
            }

            ensureSatelliteLongLinks(groundStation);
            groundStation.lastSatelliteChainCheck = Date.now();
        }

        function removeSatelliteChain(groundStation) {
            if (!groundStation) return;
            const satellites = groundStation.satelliteChain || [];
            if (satellites.length === 0) return;

            satellites.forEach(satellite => untetherSatellite(satellite));

            groundStation.satelliteChain = [];
            groundStation.satelliteEdges = [];
            groundStation.lastSatelliteChainCheck = Date.now();
        }

        function untetherSatellite(satellite) {
            if (!satellite || !satellite.isSatellite) return;
            if (satellite.state === 'drifting') return;

            const host = satellite.satelliteHost;
            if (host && host.satelliteChain) {
                host.satelliteChain = host.satelliteChain.filter(s => s !== satellite);
            }
            if (host && host.satelliteEdges) {
                host.satelliteEdges = host.satelliteEdges.filter(edge => edge.from !== satellite && edge.to !== satellite);
            }

            const edgesToRemove = edges.filter(edge => edge.from === satellite || edge.to === satellite);
            edgesToRemove.forEach(unregisterSatelliteEdge);
            edges = edges.filter(edge => edge.from !== satellite && edge.to !== satellite);

            if (satellite.children && satellite.children.length > 0) {
                const children = [...satellite.children];
                satellite.children = [];
                children.forEach(child => {
                    if (!child) return;
                    if (child.isSatellite) {
                        if (child.state !== 'drifting') {
                            untetherSatellite(child);
                        }
                    } else {
                        markBranchForRetraction(child, { allowGroundStation: true });
                    }
                });
            }

            if (satellite.parent) {
                satellite.parent.children = satellite.parent.children.filter(child => child !== satellite);
            }

            satellite.satelliteHost = null;
            satellite.parent = null;
            satellite.isTethered = false;
            satellite.state = 'drifting';
            satellite.isDrifting = true;

            const driftAngle = Math.random() * Math.PI * 2;
            const driftSpeed = SATELLITE_DRIFT_SPEED_MIN + Math.random() * (SATELLITE_DRIFT_SPEED_MAX - SATELLITE_DRIFT_SPEED_MIN);
            satellite.driftVelocityX = Math.cos(driftAngle) * driftSpeed;
            satellite.driftVelocityY = Math.sin(driftAngle) * driftSpeed;

            logEvent('satelliteUntethered', { node: satellite });

            if (host) {
                ensureSatelliteLongLinks(host);
            } else {
                refreshSatelliteLongLinks();
            }
        }

        function hasWirelessEdgeBetween(nodeA, nodeB) {
            return edges.some(edge => edge.isWirelessLink && ((edge.from === nodeA && edge.to === nodeB) || (edge.from === nodeB && edge.to === nodeA)));
        }

        function hasAnyEdgeBetween(nodeA, nodeB) {
            return edges.some(edge => (edge.from === nodeA && edge.to === nodeB) || (edge.from === nodeB && edge.to === nodeA));
        }

        function orientation(ax, ay, bx, by, cx, cy) {
            const value = (bx - ax) * (cy - ay) - (by - ay) * (cx - ax);
            if (Math.abs(value) < 1e-6) return 0;
            return value > 0 ? 1 : -1;
        }

        function onSegment(ax, ay, bx, by, cx, cy) {
            return Math.min(ax, bx) - 1e-6 <= cx && cx <= Math.max(ax, bx) + 1e-6 &&
                   Math.min(ay, by) - 1e-6 <= cy && cy <= Math.max(ay, by) + 1e-6;
        }

        function segmentsIntersect(ax, ay, bx, by, cx, cy, dx, dy) {
            const o1 = orientation(ax, ay, bx, by, cx, cy);
            const o2 = orientation(ax, ay, bx, by, dx, dy);
            const o3 = orientation(cx, cy, dx, dy, ax, ay);
            const o4 = orientation(cx, cy, dx, dy, bx, by);

            if (o1 !== o2 && o3 !== o4) return true;

            if (o1 === 0 && onSegment(ax, ay, bx, by, cx, cy)) return true;
            if (o2 === 0 && onSegment(ax, ay, bx, by, dx, dy)) return true;
            if (o3 === 0 && onSegment(cx, cy, dx, dy, ax, ay)) return true;
            if (o4 === 0 && onSegment(cx, cy, dx, dy, bx, by)) return true;

            return false;
        }

        function nodesHaveClearView(nodeA, nodeB) {
            if (!nodeA || !nodeB) return false;
            const ax = nodeA.x;
            const ay = nodeA.y;
            const bx = nodeB.x;
            const by = nodeB.y;
            const abx = bx - ax;
            const aby = by - ay;
            const abLengthSquared = abx * abx + aby * aby;
            if (abLengthSquared === 0) return false;

            for (const node of nodes) {
                if (node === nodeA || node === nodeB) continue;
                if (node.state !== 'alive') continue;
                const apx = node.x - ax;
                const apy = node.y - ay;
                let t = (apx * abx + apy * aby) / abLengthSquared;
                t = Math.max(0, Math.min(1, t));
                const closestX = ax + abx * t;
                const closestY = ay + aby * t;
                const dx = node.x - closestX;
                const dy = node.y - closestY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const clearance = node.radius + 12;
                if (distance < clearance) {
                    return false;
                }
            }

            for (const edge of edges) {
                if (!edge || !edge.from || !edge.to) continue;
                if (edge.from === nodeA || edge.from === nodeB || edge.to === nodeA || edge.to === nodeB) continue;
                if (segmentsIntersect(ax, ay, bx, by, edge.from.x, edge.from.y, edge.to.x, edge.to.y)) {
                    return false;
                }
            }

            return true;
        }

        function ensureSatelliteLongLinks(groundStation) {
            if (!groundStation || !groundStation.isGroundStation || !groundStation.satelliteChain) return;
            if (!groundStation.satelliteEdges) groundStation.satelliteEdges = [];

            const longEdgesToRemove = [];
            groundStation.satelliteEdges = groundStation.satelliteEdges.filter(edge => {
                if (!edge || !edge.isSatelliteLongLink) return edge !== null;
                const { from, to } = edge;
                const valid = from && to && from.isSatellite && to.isSatellite && from.state === 'alive' && to.state === 'alive' && from.isTethered && to.isTethered && nodesHaveClearView(from, to);
                if (!valid) {
                    longEdgesToRemove.push(edge);
                    return false;
                }
                return true;
            });

            if (longEdgesToRemove.length > 0) {
                longEdgesToRemove.forEach(unregisterSatelliteEdge);
                edges = edges.filter(edge => !longEdgesToRemove.includes(edge));
            }

            const chain = groundStation.satelliteChain.filter(sat => (sat.state === 'alive' || sat.state === 'spawning') && sat.isTethered);
            if (chain.length < 3) return;

            for (let i = 0; i < chain.length - 2; i++) {
                for (let j = i + 2; j < chain.length; j++) {
                    const satA = chain[i];
                    const satB = chain[j];
                    if (!satA || !satB) continue;
                    if (hasWirelessEdgeBetween(satA, satB)) continue;
                    if (!nodesHaveClearView(satA, satB)) continue;

                    const extendedEdge = {
                        from: satA,
                        to: satB,
                        isWirelessLink: true,
                        pulseSeed: Math.random() * Math.PI * 2,
                        isSatelliteLongLink: true
                    };

                    edges.push(extendedEdge);
                    registerSatelliteEdge(groundStation, extendedEdge);
                }
            }
        }

        function refreshSatelliteLongLinks() {
            const groundStations = nodes.filter(node => node.isGroundStation && node.state === 'alive');
            groundStations.forEach(gs => ensureSatelliteLongLinks(gs));
            ensureInterBranchSatelliteLinks(groundStations);
        }

        function ensureInterBranchSatelliteLinks(groundStations = null) {
            const activeGroundStations = groundStations || nodes.filter(node => node.isGroundStation && node.state === 'alive');
            const eligibleSatellites = nodes.filter(node => node.isSatellite && node.state === 'alive' && node.isTethered && node.satelliteHost && node.satelliteHost.isGroundStation && node.satelliteHost.state === 'alive');

            for (let i = 0; i < eligibleSatellites.length - 1; i++) {
                const satA = eligibleSatellites[i];
                const hostA = satA.satelliteHost;
                for (let j = i + 1; j < eligibleSatellites.length; j++) {
                    const satB = eligibleSatellites[j];
                    const hostB = satB.satelliteHost;

                    if (!hostA || !hostB || hostA === hostB) continue;
                    if (!activeGroundStations.includes(hostA) && !activeGroundStations.includes(hostB)) continue;
                    if (hasAnyEdgeBetween(satA, satB)) continue;
                    if (!nodesHaveClearView(satA, satB)) continue;

                    const longLink = {
                        from: satA,
                        to: satB,
                        isWirelessLink: true,
                        pulseSeed: Math.random() * Math.PI * 2,
                        isSatelliteLongLink: true,
                        isCrossBranchSatelliteLink: true
                    };

                    edges.push(longLink);
                    registerSatelliteEdge(hostA, longLink);
                    registerSatelliteEdge(hostB, longLink);
                }
            }
        }

        function groundStationHasActiveSatellites(groundStation) {
            if (!groundStation || !groundStation.satelliteChain) return false;
            return groundStation.satelliteChain.some(sat => sat && sat.state === 'alive' && sat.isTethered);
        }

        function maintainGroundStationSatelliteChains() {
            const now = Date.now();
            const groundStations = nodes.filter(node => node.isGroundStation && node.state === 'alive');

            groundStations.forEach(gs => {
                if (groundStationHasActiveSatellites(gs)) {
                    gs.lastSatelliteChainCheck = now;
                    return;
                }

                if (!gs.lastSatelliteChainCheck) {
                    gs.lastSatelliteChainCheck = now;
                    return;
                }

                if (now - gs.lastSatelliteChainCheck >= SATELLITE_RESPAWN_INTERVAL) {
                    logEvent('satelliteRespawning', { groundStation: gs });
                    buildSatelliteChain(gs);
                    gs.lastSatelliteChainCheck = now;
                }
            });
        }
        function getRootBranch(node) {
            if (!node || !node.parent) return null;
            let currentNode = node;
            while (currentNode.parent && currentNode.parent.parent !== null) {
                currentNode = currentNode.parent;
            }
            return currentNode;
        }

        function applySpringForces() {
            const springStrength = 0.01;
            const idealEdgeLength = 80;
            const meshSpringStrength = 0.001; // Much weaker spring for mesh connections
            const meshIdealLength = 120; // Longer ideal distance for mesh
            const guardianSpringStrength = 0.002;
            const guardianIdealLength = 140;

            for (const edge of edges) {
                const p1 = edge.from;
                const p2 = edge.to;

                if (!p1 || !p2 || p1.state !== 'alive' || p2.state !== 'alive' || p1.parent === null) continue;

                // Use weaker forces for botnet mesh connections
                let edgeSpringStrength = springStrength;
                let edgeIdealLength = idealEdgeLength;

                if (edge.isBotnetMesh) {
                    edgeSpringStrength = meshSpringStrength;
                    edgeIdealLength = meshIdealLength;
                } else if (edge.isGuardianVpnTunnel) {
                    edgeSpringStrength = guardianSpringStrength;
                    edgeIdealLength = guardianIdealLength;
                } else if (edge.isWirelessLink) {
                    edgeSpringStrength = WIRELESS_SPRING_STRENGTH;
                    edgeIdealLength = WIRELESS_IDEAL_LENGTH;
                }

                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 0) {
                    const displacement = distance - edgeIdealLength;
                    const force = displacement * edgeSpringStrength;
                    
                    const forceX = (dx / distance) * force;
                    const forceY = (dy / distance) * force;

                    p1.fx += forceX * 0.5;
                    p1.fy += forceY * 0.5;
                    p2.fx -= forceX * 0.5;
                    p2.fy -= forceY * 0.5;
                }
            }
        }

        function applyEdgeRepulsion() {
            const edgeRepulsionStrength = 0.08;
            for (const edge of edges) {
                const p1 = edge.from;
                const p2 = edge.to;
                if (!p1 || !p2 || p1.state !== 'alive' || p2.state !== 'alive') continue;
                const l2 = (p2.x - p1.x)**2 + (p2.y - p1.y)**2;
                if (l2 === 0) continue;

                for (const node of nodes) {
                    if (node === p1 || node === p2 || node.state !== 'alive') continue;
                    let t = ((node.x - p1.x) * (p2.x - p1.x) + (node.y - p1.y) * (p2.y - p1.y)) / l2;
                    t = Math.max(0, Math.min(1, t));
                    const closestX = p1.x + t * (p2.x - p1.x);
                    const closestY = p1.y + t * (p2.y - p1.y);
                    const dx = node.x - closestX;
                    const dy = node.y - closestY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const minDistance = node.radius + 10;

                    if (distance < minDistance && distance > 0.01) {
                        const force = (minDistance - distance) * edgeRepulsionStrength;
                        const forceX = (dx / distance) * force;
                        const forceY = (dy / distance) * force;
                        
                        node.fx += forceX;
                        node.fy += forceY;
                        p1.fx -= forceX * (1 - t) * 0.5;
                        p1.fy -= forceY * (1 - t) * 0.5;
                        p2.fx -= forceX * t * 0.5;
                        p2.fy -= forceY * t * 0.5;
                    }
                }
            }
        }

        function applyBoundaryRepulsion(qtree) {
            const margin = Math.max(80, Math.min(canvas.width, canvas.height) * 0.08);
            const strength = 0.12;
            const leftBand   = new Rectangle(margin / 2, canvas.height / 2, margin / 2, canvas.height / 2);
            const rightBand  = new Rectangle(canvas.width - margin / 2, canvas.height / 2, margin / 2, canvas.height / 2);
            const topBand    = new Rectangle(canvas.width / 2, margin / 2, canvas.width / 2, margin / 2);
            const bottomBand = new Rectangle(canvas.width / 2, canvas.height - margin / 2, canvas.width / 2, margin / 2);
            
            const applyForSide = (range, side) => {
                const list = qtree.query(range);
                for (const node of list) {
                    if (node.state !== 'alive') continue;
                    let t = 0, fx = 0, fy = 0;
                    if (side === 'left') {
                        const d = node.x;
                        if (d < margin) { t = 1 - (d / margin); fx = strength * t * t; }
                    } else if (side === 'right') {
                        const d = canvas.width - node.x;
                        if (d < margin) { t = 1 - (d / margin); fx = -strength * t * t; }
                    } else if (side === 'top') {
                        const d = node.y;
                        if (d < margin) { t = 1 - (d / margin); fy = strength * t * t; }
                    } else if (side === 'bottom') {
                        const d = canvas.height - node.y;
                        if (d < margin) { t = 1 - (d / margin); fy = -strength * t * t; }
                    }
                    if (t > 0) {
                        const effective = node.physicsMultiplier;
                        node.fx += fx * effective;
                        node.fy += fy * effective;
                    }
                }
            };
            applyForSide(leftBand, 'left');
            applyForSide(rightBand, 'right');
            applyForSide(topBand, 'top');
            applyForSide(bottomBand, 'bottom');
        }

        function applyRepulsion(qtree) { // MODIFIED: Takes a quadtree as an argument
            const repulsionStrength = 0.25;
            const interBranchRepulsion = 0.7;

            for (const nodeA of nodes) {
                if (nodeA.state !== 'alive') continue;

                // Query the quadtree for nearby nodes to reduce calculations
                const range = new Circle(nodeA.x, nodeA.y, 100); 
                const nearbyNodes = qtree.query(range);

                for (const nodeB of nearbyNodes) {
                    // Ensure we don't compare a node to itself, and that we only process each pair once.
                    if (nodeA.id >= nodeB.id || nodeB.state !== 'alive') continue;

                    const dx = nodeB.x - nodeA.x;
                    const dy = nodeB.y - nodeA.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    let minDistance = nodeA.radius + nodeB.radius + 25;
                    let forceStrength = repulsionStrength;

                    const rootBranchA = getRootBranch(nodeA);
                    const rootBranchB = getRootBranch(nodeB);

                    if (rootBranchA && rootBranchB && rootBranchA.id !== rootBranchB.id) {
                        minDistance = nodeA.radius + nodeB.radius + 50;
                        forceStrength = interBranchRepulsion;
                    }

                    if (distance < minDistance && distance > 0) {
                        const force = (minDistance - distance) * forceStrength;
                        
                        // IMPROVED: Scale forces by settling phase multipliers for gentler physics
                        const effectiveMultiplier = nodeA.physicsMultiplier * nodeB.physicsMultiplier;
                        const effectiveForce = force * effectiveMultiplier;
                        
                        const forceX = (dx / distance) * effectiveForce;
                        const forceY = (dy / distance) * effectiveForce;
                        
                        nodeA.fx -= forceX * 0.5;
                        nodeA.fy -= forceY * 0.5;
                        nodeB.fx += forceX * 0.5;
                        nodeB.fy += forceY * 0.5;
                    }
                }
            }
        }

        function createPopParticles(x, y, color) {
            // Performance: Skip particles entirely at high node counts
            if (nodes.length > 250) return;
            
            const particleCount = 4; // Reduced from 8 to 4 for better performance
            for (let i = 0; i < particleCount; i++) {
                particles.push(new Particle(x, y, color));
            }
        }

        function promoteToGuardian(node, logKey, extraContext = {}) {
            if (!node || node.parent === null || node.state !== 'alive' || node.isGuardian || node.isGroundStation || node.isSatellite) {
                return false;
            }

            node.isGuardian = true;
            node.hasFirewall = true;
            node.shieldStrength = Math.max(node.shieldStrength, 0.8);
            node.currentColor = { ...colors.white };
            node.targetRadius = node.baseRadius * 1.15;
            node.guardianStreamCount = 0;
            clearGuardianVpnTunnels(node);
            node.lastGuardianBridgeUpdate = 0;
            node.lastGuardianFirewallAttempt = 0;
            createPopParticles(node.x, node.y, colors.white);

            if (logKey) {
                logEvent(logKey, { node, ...extraContext });
            }

            return true;
        }

        function demoteGuardian(node, logKey, extraContext = {}) {
            if (!node || !node.isGuardian) return;

            clearGuardianVpnTunnels(node);
            node.isGuardian = false;
            node.guardianStreamCount = 0;
            node.guardianImmunityLastSpawn = 0;
            node.hasFirewall = false;

            if (logKey) {
                logEvent(logKey, { node, ...extraContext });
            }
        }

        function trySpawnGuardian(node) {
            if (!node || node.parent === null || node.state !== 'alive' || node.isGuardian || node.isGroundStation || node.isSatellite) return;

            const GUARDIAN_SPAWN_CHANCE = 0.25;
            if (Math.random() >= GUARDIAN_SPAWN_CHANCE) return;

            promoteToGuardian(node, 'guardianPromotionPhishing');
        }

        function clearGuardianVpnTunnels(node) {
            if (!node || !node.guardianVpnTunnels) return;

            node.guardianVpnTunnels.forEach(tunnel => {
                if (!tunnel || !tunnel.edge) return;
                const index = edges.indexOf(tunnel.edge);
                if (index !== -1) {
                    edges.splice(index, 1);
                }
            });

            node.guardianVpnTunnels = [];
        }

        const GUARDIAN_VPN_TUNNEL_RANGE = 200;
        const GUARDIAN_VPN_TUNNEL_LIMIT = 3;

        function updateGuardianVpnTunnels() {
            const now = Date.now();
            const GUARDIAN_VPN_TUNNEL_REFRESH_INTERVAL = 6000 / healSpeedMultiplier;
            const GUARDIAN_FIREWALL_ATTEMPT_DURATION = 2000 / healSpeedMultiplier;

            nodes.forEach(node => {
                if (!node.guardianVpnTunnels) {
                    node.guardianVpnTunnels = [];
                }

                const isActiveGuardian = node.isGuardian && node.state === 'alive';

                if (!isActiveGuardian) {
                    clearGuardianVpnTunnels(node);
                    return;
                }

                // Clean up stale VPN tunnels (target removed or dead)
                node.guardianVpnTunnels = node.guardianVpnTunnels.filter(tunnel => {
                    if (!tunnel || !tunnel.edge || !tunnel.target) {
                        return false;
                    }
                    if (tunnel.target.state !== 'alive') {
                        const idx = edges.indexOf(tunnel.edge);
                        if (idx !== -1) edges.splice(idx, 1);
                        return false;
                    }
                    return true;
                });

                // Finalize firewall attempts
                node.guardianVpnTunnels.forEach(tunnel => {
                    if (!tunnel || !tunnel.firewallAttempt) return;
                    const attempt = tunnel.firewallAttempt;
                    if (attempt.completed) return;

                    const elapsed = now - attempt.startTime;
                    if (elapsed >= GUARDIAN_FIREWALL_ATTEMPT_DURATION) {
                        attempt.completed = true;
                        if (attempt.success && tunnel.target && tunnel.target.state === 'alive' && !tunnel.target.hasFirewall) {
                            tunnel.target.hasFirewall = true;
                            tunnel.target.shieldStrength = Math.max(tunnel.target.shieldStrength, 0.75);
                            tunnel.target.shieldFlashTimer = 0;
                            createPopParticles(tunnel.target.x, tunnel.target.y, colors.neonGreen);
                            logEvent('guardianFirewallSuccess', { guardian: node, target: tunnel.target });
                        }
                    }
                });

                if (now - node.lastGuardianBridgeUpdate < GUARDIAN_VPN_TUNNEL_REFRESH_INTERVAL) {
                    return;
                }

                node.lastGuardianBridgeUpdate = now;
                clearGuardianVpnTunnels(node);

                const candidates = nodes
                    .filter(target => {
                        if (!target || target === node) return false;
                        if (target.state !== 'alive') return false;
                        if (target.parent === null) return false; // skip central node
                        if (target.status !== 'green') return false;
                        const dx = target.x - node.x;
                        const dy = target.y - node.y;
                        const distance = Math.hypot(dx, dy);
                        if (distance > GUARDIAN_VPN_TUNNEL_RANGE) return false;

                        // Avoid duplicate edges (including existing guardian VPN tunnels)
                        const alreadyConnected = edges.some(edge => {
                            if (!edge.from || !edge.to) return false;
                            const sameDirection = edge.from === node && edge.to === target;
                            const oppositeDirection = edge.from === target && edge.to === node;
                            return sameDirection || oppositeDirection;
                        });
                        if (alreadyConnected) return false;

                        return true;
                    })
                    .sort((a, b) => {
                        const da = Math.hypot(a.x - node.x, a.y - node.y);
                        const db = Math.hypot(b.x - node.x, b.y - node.y);
                        return da - db;
                    })
                    .slice(0, GUARDIAN_VPN_TUNNEL_LIMIT);

                candidates.forEach(target => {
                    const edge = {
                        from: node,
                        to: target,
                        isGuardianVpnTunnel: true,
                        guardianOwnerId: node.id,
                        createdAt: now
                    };
                    edges.push(edge);

                    const tunnel = {
                        edge,
                        target,
                        firewallAttempt: null
                    };

                    if (!target.hasFirewall) {
                        const success = Math.random() < 0.75;
                        tunnel.firewallAttempt = {
                            startTime: now,
                            success,
                            completed: false
                        };
                        edge.guardianFirewallAttempt = tunnel.firewallAttempt;
                        node.lastGuardianFirewallAttempt = now;
                    } else {
                        edge.guardianFirewallAttempt = null;
                    }

                    node.guardianVpnTunnels.push(tunnel);
                    logEvent('guardianVpnCreated', { guardian: node, target });
                });
            });
        }

        function spawnGuardianImmunityStreams() {
            const now = Date.now();
            const GUARDIAN_STREAM_INTERVAL = 1200 / healSpeedMultiplier;
            const IMMUNITY_STREAM_SPEED = 0.006;

            nodes.forEach(node => {
                if (!node.isGuardian || node.state !== 'alive') return;

                if (now - node.guardianImmunityLastSpawn < GUARDIAN_STREAM_INTERVAL) {
                    return;
                }

                node.guardianImmunityLastSpawn = now;

                const connectedEdges = edges.filter(edge => edge.from === node || edge.to === node);
                const outwardDirections = connectedEdges.length > 0 ? connectedEdges : [{ from: node, to: node.parent }];

                outwardDirections.forEach(connection => {
                    if (!connection || (!connection.from && !connection.to)) return;

                    let edge = connection;
                    if (!edge.from || !edge.to) {
                        const sibling = node.parent;
                        if (!sibling) return;
                        edge = { from: node, to: sibling };
                    }

                    if (!edge.from || !edge.to || edge.from.state !== 'alive' || edge.to.state !== 'alive') return;

                    const direction = edge.from === node ? 1 : -1;
                    const packet = new ImmunityPacket(edge, direction);
                    node.guardianStreamCount = (node.guardianStreamCount + 1) % 10;

                    if (node.guardianStreamCount === 0) {
                        packet.isSupercharged = true;
                        packet.radius = 3;
                    }

                    packet.baseSpeed = IMMUNITY_STREAM_SPEED;
                    packet.speed = IMMUNITY_STREAM_SPEED;
                    packet.opacity = 1;
                    packet.lateralOffset = direction === 1 ? 6 : -6;
                    immunityPackets.push(packet);
                    incrementStat('totalImmunityPackets');
                });
            });
        }

        function manageParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.update();
                p.draw();
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function spawnDataPackets() {
            // Spawn packets on healthy edges
            // Control spawn rate to avoid overwhelming the visualization
            const SPAWN_CHANCE = 0.015; // 1.5% chance per frame to spawn on any given edge
            
            edges.forEach(edge => {
                if (!edge.from || !edge.to || 
                    edge.from.state !== 'alive' || edge.to.state !== 'alive') {
                    return;
                }
                
                // Higher spawn rate on healthy links, lower on compromised ones
                let spawnMultiplier = 1;
                if (edge.to.status === 'green' && edge.from.status !== 'red') {
                    spawnMultiplier = 1.5;
                } else if (edge.to.status === 'red' || edge.to.status === 'malware' || edge.to.status === 'botnet') {
                    spawnMultiplier = 0.3;
                } else if (edge.to.status === 'yellow') {
                    spawnMultiplier = 0.7;
                }
                
                // Spawn packet traveling from parent to child (forward direction)
                if (Math.random() < SPAWN_CHANCE * spawnMultiplier) {
                    const packet = new DataPacket(edge, 1);
                    dataPackets.push(packet);
                    // Track packet type for stats
                    if (packet.type === 'data') incrementStat('totalDataPackets');
                    else if (packet.type === 'control') incrementStat('totalControlPackets');
                    else if (packet.type === 'security') incrementStat('totalSecurityPackets');
                }
                
                // Spawn packet traveling from child to parent (backward direction)
                // Less frequent backward traffic
                if (Math.random() < SPAWN_CHANCE * spawnMultiplier * 0.6) {
                    const packet = new DataPacket(edge, -1);
                    dataPackets.push(packet);
                    // Track packet type for stats
                    if (packet.type === 'data') incrementStat('totalDataPackets');
                    else if (packet.type === 'control') incrementStat('totalControlPackets');
                    else if (packet.type === 'security') incrementStat('totalSecurityPackets');
                }
            });
        }

        function manageDataPackets() {
            // Spawn new packets
            spawnDataPackets();
            
            // Update and draw existing packets
            for (let i = dataPackets.length - 1; i >= 0; i--) {
                const packet = dataPackets[i];
                packet.update();
                packet.draw();
                
                // Remove inactive packets
                if (!packet.active) {
                    dataPackets.splice(i, 1);
                }
            }
        }

        function spawnImmunityPackets() {
            // Spawn immunity packets only from healthy firewalled nodes
            const SPAWN_CHANCE = 0.002; // Very rare spawn rate
            
            edges.forEach(edge => {
                if (!edge.from || !edge.to || 
                    edge.from.state !== 'alive' || edge.to.state !== 'alive') {
                    return;
                }
                
                // Only spawn from edges where at least one node is healthy AND has firewall
                const fromIsHealthyFirewalled = edge.from.status === 'green' && edge.from.hasFirewall;
                const toIsHealthyFirewalled = edge.to.status === 'green' && edge.to.hasFirewall;
                
                if (fromIsHealthyFirewalled || toIsHealthyFirewalled) {
                    // Spawn immunity packet in both directions (very rarely)
                    if (Math.random() < SPAWN_CHANCE) {
                        immunityPackets.push(new ImmunityPacket(edge, 1));
                        incrementStat('totalImmunityPackets');
                    }
                    if (Math.random() < SPAWN_CHANCE) {
                        immunityPackets.push(new ImmunityPacket(edge, -1));
                        incrementStat('totalImmunityPackets');
                    }
                }
            });
        }
        
        // --- Bot Defense Mode logic ---
        function evaluateBotDefenseMode() {
            const central = nodes[0];
            if (!central || central.parent !== null) return;
            const now = Date.now();
            // If central is compromised, disable mode and clear
            if (central.status === 'malware' || central.status === 'botnet' || central.status === 'commandControl' || central.state !== 'alive') {
                central.botDefenseModeActive = false;
                central.botDefenseTargets = [];
                central.botDefenseLastBurst = 0;
                return;
            }
            // Count infected direct children (branches)
            const infectedBranches = (central.children || []).filter(ch => ch && ch.state === 'alive' && (ch.status === 'malware' || ch.status === 'botnet' || ch.status === 'commandControl'));
            if (central.botDefenseModeActive) {
                // End if duration elapsed or not enough infected branches
                if ((now - central.botDefenseModeStart) >= BOT_DEFENSE_DURATION || infectedBranches.length < 3) {
                    central.botDefenseModeActive = false;
                    central.botDefenseTargets = [];
                    central.botDefenseLastBurst = 0;
                    central.botDefenseCooldownUntil = now + BOT_DEFENSE_COOLDOWN;
                } else {
                    central.botDefenseTargets = infectedBranches;
                }
                return;
            }
            // Not active: can we start?
            if (infectedBranches.length >= 3 && now >= (central.botDefenseCooldownUntil || 0) && Math.random() < 0.5) {
                central.botDefenseModeActive = true;
                central.botDefenseModeStart = now;
                central.botDefenseTargets = infectedBranches;
                central.botDefenseLastBurst = 0;
                // aura will render in draw()
            }
        }

        function getInfectedNodesUnder(branch) {
            const result = [];
            const stack = [branch];
            while (stack.length) {
                const n = stack.pop();
                if (!n || n.state !== 'alive') continue;
                if (n !== branch && (n.status === 'malware' || n.status === 'botnet' || n.status === 'commandControl')) {
                    result.push(n);
                }
                if (n.children && n.children.length) {
                    for (const c of n.children) stack.push(c);
                }
            }
            // If none deeper, allow branch itself if infected
            if (result.length === 0 && (branch.status === 'malware' || branch.status === 'botnet' || branch.status === 'commandControl')) {
                result.push(branch);
            }
            return result;
        }

        function createBotDefensePacket(centralNode, branchNode, targetNode) {
            // Find direct edge between central and branch
            const connection = edges.find(e => (e.from === centralNode && e.to === branchNode) || (e.to === centralNode && e.from === branchNode));
            if (!connection) return;
            const direction = connection.from === centralNode ? 1 : -1;
            const packet = new ImmunityPacket(connection, direction);
            packet.progress = direction === 1 ? Math.random() * 0.2 : 1 - Math.random() * 0.2;
            packet.lateralOffset = direction === 1 ? 6 : -6;
            packet.isSupercharged = true;
            packet.isSeeking = true;
            packet.targetNode = targetNode;
            packet.speed = packet.baseSpeed * 2.5;
            packet.opacity = 1;
            packet.radius = 3;
            immunityPackets.push(packet);
            incrementStat('totalImmunityPackets');
        }

        function handleBotDefenseBursts() {
            // REMOVED: Supercharged immunity packet bursts from central node's Bot Defense Mode
            // Central node now only sends supercharged packets to first infected parent nodes in each branch
            // during recovery (unlimited) or via consumed packets for dispatch
            return;
        }

        function manageImmunityPackets() {
            handleBotDefenseBursts();
            // Spawn new immunity packets
            spawnImmunityPackets();
            spawnGuardianImmunityStreams();
            
            // Update and draw existing packets (except those attached to central node)
            for (let i = immunityPackets.length - 1; i >= 0; i--) {
                const packet = immunityPackets[i];
                packet.update();
                
                // Only draw if NOT attached to central node (will draw those later on top)
                const isAttachedToCentral = packet.isAttached && packet.attachedNode && packet.attachedNode.parent === null;
                if (!isAttachedToCentral) {
                    packet.draw();
                }
                
                // Remove inactive packets
                if (!packet.active) {
                    // Remove from attached node's list if it was attached
                    if (packet.attachedNode) {
                        const idx = packet.attachedNode.attachedImmunityPackets.indexOf(packet);
                        if (idx !== -1) {
                            packet.attachedNode.attachedImmunityPackets.splice(idx, 1);
                        }
                    }
                    immunityPackets.splice(i, 1);
                }
            }
        }

        function managePingOfDeath() {
            // C&C nodes send ping of death packets to attack random nodes
            const ccNodes = nodes.filter(n => 
                n.status === 'commandControl' && 
                n.state === 'alive' && 
                n.parent !== null
            );
            
            ccNodes.forEach(ccNode => {
                // Check if this C&C can send a ping (one at a time, with cooldown)
                const now = Date.now();
                
                // Find connected green nodes for aggressive targeting
                const connectedGreenNodes = [];
                edges.forEach(edge => {
                    if (edge.isBotnetMesh) {
                        let otherNode = null;
                        if (edge.from === ccNode && edge.to.state === 'alive' && edge.to.status === 'green') {
                            otherNode = edge.to;
                        } else if (edge.to === ccNode && edge.from.state === 'alive' && edge.from.status === 'green') {
                            otherNode = edge.from;
                        }
                        if (otherNode && !otherNode.isSatellite && !connectedGreenNodes.includes(otherNode)) {
                            connectedGreenNodes.push(otherNode);
                        }
                    }
                });
                
                // Aggressive mode: shorter cooldown and higher attack rate for connected green nodes
                const hasConnectedGreenNodes = connectedGreenNodes.length > 0;
                
                // DDOS persistent attack: 2x faster pings during active DDOS
                const ddosSpeedBoost = (ccNode.ddosState === 'active') ? 2.0 : 1.0;
                const PING_COOLDOWN = ((hasConnectedGreenNodes ? 4000 : 8000) / attackFreqMultiplier) / ddosSpeedBoost;
                const baseAttackChance = (hasConnectedGreenNodes ? 0.40 : 0.15) * attackFreqMultiplier;
                const attackChance = baseAttackChance * ddosSpeedBoost;
                
                if (ccNode.activePingOfDeath || (now - ccNode.lastPingTime) < PING_COOLDOWN) {
                    return; // Already has active ping or on cooldown
                }
                
                // Higher chance to send ping if connected to green nodes
                if (Math.random() < Math.min(1, attackChance)) {
                let target;
                    
                    // During DDOS, ONLY target nodes in the affected branch
                    if (ccNode.ddosState === 'active' && ccNode.ddosTargetBranch) {
                        const branchTargets = nodes.filter(n => 
                            n.state === 'alive' && 
                            n.parent !== null &&
                            n !== ccNode &&
                            !n.isSatellite &&
                            isNodeInDDOSBranch(n)
                        );
                        if (branchTargets.length > 0) {
                            target = branchTargets[Math.floor(Math.random() * branchTargets.length)];
                        }
                        // If no targets in DDOS branch, don't send ping at all during DDOS
                    } else {
                        // Aggressively prioritize connected green nodes (90% of the time)
                        if (connectedGreenNodes.length > 0 && Math.random() < 0.90) {
                            target = connectedGreenNodes[Math.floor(Math.random() * connectedGreenNodes.length)];
                            logEvent('commandControlAggressiveAttack', { ccNode, target });
                        } else {
                            // Find all valid targets (alive nodes, not central node, not self)
                            const validTargets = nodes.filter(n => 
                                n.state === 'alive' && 
                                n.parent !== null && // Not the central node
                                n !== ccNode && // Not self
                                !n.isCommandControl // Don't target other C&C nodes
                                && !n.isSatellite
                            );
                            
                            if (validTargets.length > 0) {
                                // Try to pick a node with children (non-leaf) 70% of the time
                                const nonLeafNodes = validTargets.filter(n => n.children && n.children.length > 0);
                                if (nonLeafNodes.length > 0 && Math.random() < 0.7) {
                                    target = nonLeafNodes[Math.floor(Math.random() * nonLeafNodes.length)];
                                } else {
                                    target = validTargets[Math.floor(Math.random() * validTargets.length)];
                                }
                            }
                        }
                    }
                    
                    // Create ping of death packet if we have a target
                    if (target) {
                        const ping = new PingOfDeath(ccNode, target);
                        
                        if (ping.path && ping.path.length > 0) {
                            pingOfDeathPackets.push(ping);
                            ccNode.activePingOfDeath = ping;
                            ccNode.lastPingTime = now;
                            const targetType = target.children && target.children.length > 0 ? 'branch' : 'leaf';
                            logEvent('pingOfDeathSent', { ccNode, target, targetType, pathLength: ping.path.length });
                            incrementStat('totalAttacks');
                            incrementStat('totalPingPackets');
                        } else {
                            // Log failed pathfinding for debugging
                            logEvent('pingOfDeathFailed', { ccNode });
                        }
                    }
                }
            });
            
            // Update all ping of death packets
            pingOfDeathPackets.forEach(ping => {
                ping.update();
                ping.draw();
            });
            
            // Remove finished pings
            pingOfDeathPackets = pingOfDeathPackets.filter(ping => ping.state !== 'finished');
        }

        function managePhishPackets() {
            // C&C nodes send bursts of phishing packets to random targets
            const ccNodes = nodes.filter(n => 
                n.status === 'commandControl' && 
                n.state === 'alive' && 
                n.parent !== null
            );
            
            ccNodes.forEach(ccNode => {
                // DDOS persistent attack: 2x faster phishing during active DDOS
                const ddosSpeedBoost = (ccNode.ddosState === 'active') ? 2.0 : 1.0;
                const PHISH_BURST_COOLDOWN = (15000 / attackFreqMultiplier) / ddosSpeedBoost;
                const now = Date.now();
                
                // Initialize phish burst tracking
                if (!ccNode.lastPhishBurstTime) {
                    ccNode.lastPhishBurstTime = 0;
                }
                
                if ((now - ccNode.lastPhishBurstTime) < PHISH_BURST_COOLDOWN) {
                    return; // Still on cooldown
                }
                
                // DDOS persistent attack: 2x higher chance during active DDOS
                const baseChance = 0.10 * attackFreqMultiplier;
                const attackChance = baseChance * ddosSpeedBoost;
                
                if (Math.random() < Math.min(1, attackChance)) {
                    // Find all valid green targets
                    let validTargets = nodes.filter(n => 
                        n.state === 'alive' && 
                        n.parent !== null && // Not the central node
                        n !== ccNode && // Not self
                        n.status === 'green' && // Only target green nodes
                        !n.isCommandControl // Don't target other C&C nodes
                        && !n.isSatellite
                    );
                    
                    // During DDOS, ONLY target nodes in the affected branch
                    if (ccNode.ddosState === 'active' && ccNode.ddosTargetBranch) {
                        const branchTargets = validTargets.filter(n => isNodeInDDOSBranch(n));
                        if (branchTargets.length > 0) {
                            validTargets = branchTargets; // Exclusively target DDOS branch
                        } else {
                            validTargets = []; // No valid targets during DDOS - skip phishing
                        }
                    }
                    
                    if (validTargets.length > 0) {
                        // Send burst of 1-3 phish packets
                        const burstSize = Math.min(3, Math.floor(Math.random() * 3) + 1);
                        
                        for (let i = 0; i < burstSize; i++) {
                            // Pick random target for each packet
                            const target = validTargets[Math.floor(Math.random() * validTargets.length)];
                            const phish = new PhishPacket(ccNode, target);
                            
                            if (phish.path && phish.path.length > 0) {
                                phishPackets.push(phish);
                                incrementStat('totalAttacks');
                                incrementStat('totalPhishPackets');
                            }
                        }
                        
                        ccNode.lastPhishBurstTime = now;
                        logEvent('commandControlPhishBurst', { ccNode, burstSize });
                    }
                }
            });
            
            // Update all phish packets
            phishPackets.forEach(phish => {
                phish.update();
                phish.draw();
            });
            
            // Remove finished phish packets
            phishPackets = phishPackets.filter(phish => phish.state !== 'finished');
        }

        function manageDDOSAttacks() {
            const now = Date.now();
            const DDOS_CHARGE_TIME = 6000 / attackFreqMultiplier;
            const DDOS_DURATION = 12000;
            const DDOS_COOLDOWN = 25000 / attackFreqMultiplier;
            
            // Find all C&C nodes
            const ccNodes = nodes.filter(n => 
                n.status === 'commandControl' && 
                n.state === 'alive' && 
                n.parent !== null
            );
            
            ccNodes.forEach(ccNode => {
                // State machine for DDOS attack
                if (ccNode.ddosState === 'charging') {
                    const elapsed = now - ccNode.ddosChargeStart;
                    if (elapsed >= DDOS_CHARGE_TIME) {
                        // Charging complete - launch DDOS
                        ccNode.ddosState = 'active';
                        ccNode.ddosActiveStart = now;
                        
                        // Mark target branch as under attack
                        if (ccNode.ddosTargetBranch) {
                            ccNode.ddosTargetBranch.isUnderDDOS = true;
                            ccNode.ddosTargetBranch.ddosAttacker = ccNode;
                        }
                        
                        logEvent('ddosLaunched', { 
                            ccNode, 
                            targetBranch: ccNode.ddosTargetBranch,
                            botnetCount: ccNode.ddosBotnets.length 
                        });
                        
                        // Increment DDOS attack counter
                        incrementStat('totalDDOSAttacks');
                    }
                } else if (ccNode.ddosState === 'active') {
                    const elapsed = now - ccNode.ddosActiveStart;
                    
                    // Create DDOS attack paths along existing network topology
                    if (ccNode.ddosBotnets && ccNode.ddosBotnets.length > 0 && ccNode.ddosTargetBranch) {
                        // Initialize DDOS attack paths if not already created
                        if (!ccNode.ddosAttackPaths) {
                            ccNode.ddosAttackPaths = [];
                            
                            // Each botnet creates ONE attack path to the target branch node
                            ccNode.ddosBotnets.forEach(botnet => {
                                if (botnet.state !== 'alive') return;
                                
                                // Find path from botnet to target through existing network
                                // Path: botnet ‚Üí up to central ‚Üí target branch node
                                const path = [];
                                
                                // Trace up from botnet to central node
                                let current = botnet;
                                while (current && current.parent && current.parent.parent !== null) {
                                    const edge = edges.find(e => 
                                        (e.from === current && e.to === current.parent) ||
                                        (e.to === current && e.from === current.parent)
                                    );
                                    if (edge) {
                                        path.push({
                                            edge: edge,
                                            direction: (edge.from === current) ? 1 : -1, // 1 = from->to, -1 = to->from
                                            botnet: botnet
                                        });
                                    }
                                    current = current.parent;
                                }
                                
                                // Add edge from main branch node to central
                                if (current && current.parent === nodes[0]) {
                                    const edgeToCentral = edges.find(e => 
                                        (e.from === current && e.to === nodes[0]) ||
                                        (e.to === current && e.from === nodes[0])
                                    );
                                    if (edgeToCentral) {
                                        path.push({
                                            edge: edgeToCentral,
                                            direction: (edgeToCentral.from === current) ? 1 : -1,
                                            botnet: botnet
                                        });
                                    }
                                }
                                
                                // Add edge from central to target branch
                                const edgeToTarget = edges.find(e => 
                                    (e.from === nodes[0] && e.to === ccNode.ddosTargetBranch) ||
                                    (e.to === nodes[0] && e.from === ccNode.ddosTargetBranch)
                                );
                                if (edgeToTarget) {
                                    path.push({
                                        edge: edgeToTarget,
                                        direction: (edgeToTarget.from === nodes[0]) ? 1 : -1,
                                        botnet: botnet
                                    });
                                }
                                
                                if (path.length > 0) {
                                    ccNode.ddosAttackPaths.push({
                                        botnet: botnet,
                                        path: path,
                                        startTime: now,
                                        target: ccNode.ddosTargetBranch
                                    });
                                }
                            });
                        }
                    }
                    
                    if (elapsed >= DDOS_DURATION) {
                        // DDOS complete - enter cooldown
                        ccNode.ddosState = 'idle';
                        ccNode.ddosCooldownUntil = now + DDOS_COOLDOWN;
                        
                        // Clear target branch DDOS status
                        if (ccNode.ddosTargetBranch) {
                            ccNode.ddosTargetBranch.isUnderDDOS = false;
                            ccNode.ddosTargetBranch.ddosAttacker = null;
                            
                            logEvent('ddosEnded', { 
                                ccNode, 
                                targetBranch: ccNode.ddosTargetBranch 
                            });
                        }
                        
                        // Clean up DDOS attack paths
                        if (ccNode.ddosAttackPaths) {
                            ccNode.ddosAttackPaths = [];
                        }
                        
                        ccNode.ddosTargetBranch = null;
                        ccNode.ddosBotnets = [];
                    }
                } else if (ccNode.ddosState === 'idle') {
                    // Check if we can start a new DDOS attack
                    if (now < ccNode.ddosCooldownUntil) return; // Still on cooldown
                    
                    // Count connected botnet nodes
                    const connectedBotnets = [];
                    edges.forEach(edge => {
                        let otherNode = null;
                        if (edge.from === ccNode && edge.to && edge.to.status === 'botnet' && edge.to.state === 'alive') {
                            otherNode = edge.to;
                        } else if (edge.to === ccNode && edge.from && edge.from.status === 'botnet' && edge.from.state === 'alive') {
                            otherNode = edge.from;
                        }
                        if (otherNode && !connectedBotnets.includes(otherNode)) {
                            connectedBotnets.push(otherNode);
                        }
                    });
                    
                    // Need at least 3 botnets to launch DDOS
                    if (connectedBotnets.length < 3) return;
                    
                    // Find suitable target: a large branch (direct child of central node)
                    const centralNode = nodes[0];
                    if (!centralNode) return;
                    
                    // Find which branch the C&C node belongs to (walk up to find main branch)
                    let ccBranch = ccNode;
                    while (ccBranch.parent && ccBranch.parent.parent !== null) {
                        ccBranch = ccBranch.parent;
                    }
                    // ccBranch is now the main branch (direct child of central) that contains the C&C
                    
                    const validBranches = centralNode.children.filter(branch => 
                        branch && 
                        branch.state === 'alive' && 
                        !branch.isSatellite &&
                        !branch.isUnderDDOS && // Don't target already attacked branches
                        branch !== ccBranch && // Don't target the C&C's own branch
                        branch.hasFirewall // Only target firewalled nodes
                    );
                    
                    if (validBranches.length === 0) return;
                    
                    // Prioritize large branches (most descendants)
                    validBranches.sort((a, b) => {
                        const aDesc = countDescendants(a);
                        const bDesc = countDescendants(b);
                        return bDesc - aDesc;
                    });
                    
                    // 20% chance to initiate DDOS each check (affected by attack frequency multiplier)
                    if (Math.random() < Math.min(1, 0.20 * attackFreqMultiplier)) {
                        // Start charging DDOS
                        ccNode.ddosState = 'charging';
                        ccNode.ddosChargeStart = now;
                        ccNode.ddosTargetBranch = validBranches[0]; // Target largest branch
                        ccNode.ddosBotnets = connectedBotnets;
                        
                        logEvent('ddosCharging', { 
                            ccNode, 
                            botnetCount: connectedBotnets.length,
                            targetBranch: ccNode.ddosTargetBranch 
                        });
                    }
                }
            });
        }

        function manageCounterStrikes() {
            // Update and draw all counter-strike packets
            counterStrikePackets.forEach(strike => {
                strike.update();
                strike.draw();
            });
            
            // Remove finished counter-strikes
            counterStrikePackets = counterStrikePackets.filter(strike => strike.state !== 'finished');
        }

        // Guardian Threat Hunting System
        let lastThreatScan = 0;
        const THREAT_SCAN_INTERVAL = 3000; // Scan every 3 seconds
        const GUARDIAN_DISPATCH_INTERVAL = 10000; // Guardians can send dispatch packets every 10 seconds
        const THREAT_SCAN_RADIUS = 200; // Detection radius

        function guardianThreatHunting() {
            const now = Date.now();
            if (now - lastThreatScan < THREAT_SCAN_INTERVAL) return;
            lastThreatScan = now;

            const guardians = nodes.filter(n => 
                n.state === 'alive' && 
                n.isGuardian && 
                n.status === 'green'
            );

            guardians.forEach(guardian => {
                // Guardian dispatch support ‚Äì send remediation to closest reachable infected node
                if (now - guardian.guardianDispatchLastSent >= GUARDIAN_DISPATCH_INTERVAL) {
                    const infectedCandidates = nodes.filter(n =>
                        n && n !== guardian &&
                        n.state === 'alive' &&
                        (n.status === 'malware' || n.status === 'botnet' || n.status === 'commandControl') &&
                        !n.isTargeted &&
                        n.remediationState === 'none'
                    );

                    let bestTarget = null;
                    let bestDistanceSq = Infinity;
                    let bestPath = null;

                    infectedCandidates.forEach(candidate => {
                        const path = buildNodePath(guardian, candidate);
                        if (!path || path.length < 2) return;

                        const intermediateNodes = path.slice(1, -1);
                        const pathClear = intermediateNodes.every(node =>
                            node &&
                            node.state === 'alive' &&
                            (node.status === 'green' || node.status === 'blue')
                        );
                        if (!pathClear) return;

                        const dx = candidate.x - guardian.x;
                        const dy = candidate.y - guardian.y;
                        const distanceSq = dx * dx + dy * dy;
                        if (distanceSq < bestDistanceSq) {
                            bestDistanceSq = distanceSq;
                            bestTarget = candidate;
                            bestPath = path;
                        }
                    });

                    if (bestTarget && bestPath) {
                        const dispatch = new DispatchPacket(bestTarget, guardian);
                        if (dispatch.state !== 'finished') {
                            dispatchPackets.push(dispatch);
                            incrementStat('totalDispatchPackets');
                            bestTarget.isTargeted = true;
                            guardian.guardianDispatchLastSent = now;
                            logEvent('custom', { message: `üï∂ Guardian ${guardian.id} dispatched remediation to node ${bestTarget.id}.` });
                        }
                    }
                }

                // Scan for nearby infected nodes
                const nearbyInfected = nodes.filter(n => {
                    if (n.state !== 'alive') return false;
                    if (n.status !== 'malware' && n.status !== 'botnet' && n.status !== 'commandControl') return false;
                    
                    const dx = n.x - guardian.x;
                    const dy = n.y - guardian.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    return distance <= THREAT_SCAN_RADIUS;
                });

                if (nearbyInfected.length > 0) {
                    // Target the closest infected node
                    nearbyInfected.sort((a, b) => {
                        const distA = Math.sqrt((a.x - guardian.x) ** 2 + (a.y - guardian.y) ** 2);
                        const distB = Math.sqrt((b.x - guardian.x) ** 2 + (b.y - guardian.y) ** 2);
                        return distA - distB;
                    });

                    const target = nearbyInfected[0];
                    
                    // Visual scan pulse effect
                    createPopParticles(guardian.x, guardian.y, { r: 96, g: 165, b: 250 });
                    
                    // Send targeted immunity packet
                    const immunityPacket = new ImmunityPacket(
                        edges.find(e => e.from === guardian || e.to === guardian) || { from: guardian, to: guardian },
                        1
                    );
                    immunityPacket.targetNode = target;
                    immunityPacket.isTargeted = true;
                    immunityPackets.push(immunityPacket);
                    
                    logEvent('custom', { message: `üîç Guardian ${guardian.id} detected and targeting infected node ${target.id}!` });
                }
            });
        }

        function manageDispatchPackets() {
            const rootNode = nodes[0];
            // If the central node is compromised, it cannot send out remediation pulses.
            if (rootNode && (rootNode.status === 'malware' || rootNode.status === 'botnet' || rootNode.status === 'commandControl')) {
                // Update and draw any pulses that were already in flight before the infection.
                dispatchPackets.forEach(dispatchPacket => {
                    dispatchPacket.update();
                    dispatchPacket.draw();
                });
                dispatchPackets = dispatchPackets.filter(packet => packet.state !== 'finished');
                return; // Stop here and don't create new pulses.
            }
            
            const malwareNodes = nodes.filter(n => (n.status === 'malware' || n.status === 'botnet' || n.status === 'commandControl') && n.infectedAt && !n.isTargeted);
            
            malwareNodes.forEach(node => {
                if (Date.now() > node.infectedAt + node.pulseDelay) {
                    // Build the path to the target node to check for obstructions
                    const path = [];
                    let currentNode = node;
                    while (currentNode) {
                        path.push(currentNode);
                        currentNode = currentNode.parent;
                    }
                    path.reverse(); // Path is now [root, ..., target]

                    // A path is clear if all intermediate nodes are green.
                    // The root is blue, and the final node is malware, so we check the nodes in between.
                    const isPathClear = path.slice(1, -1).every(pathNode => pathNode.status === 'green');

                    // Only send a pulse if the path is not blocked by a red/yellow node AND central node has supercharged immunity packets
                    if (isPathClear) {
                        // Check if central node has supercharged immunity packets (unless self-healing = unlimited)
                        if (rootNode.isSelfHealing) {
                            // During recovery, central node has unlimited supercharged packets
                            dispatchPackets.push(new DispatchPacket(node));
                            incrementStat('totalDispatchPackets');
                            node.isTargeted = true;
                        } else {
                            // Check for available supercharged immunity packets
                            const superchargedPackets = rootNode.attachedImmunityPackets.filter(p => p && p.isSupercharged);
                            
                            if (superchargedPackets.length > 0) {
                                // Consume one supercharged immunity packet
                                const consumedPacket = superchargedPackets[0];
                                consumedPacket.active = false;
                                rootNode.attachedImmunityPackets = rootNode.attachedImmunityPackets.filter(p => p !== consumedPacket);
                                
                                // Send dispatch packet
                                dispatchPackets.push(new DispatchPacket(node));
                                incrementStat('totalDispatchPackets');
                                node.isTargeted = true;
                            }
                            // If no supercharged packets available, don't send dispatch
                        }
                    }
                }
            });

            dispatchPackets.forEach(dispatchPacket => {
                dispatchPacket.update();
                dispatchPacket.draw();
            });

            dispatchPackets = dispatchPackets.filter(packet => packet.state !== 'finished');
        }
        
        function animate() {
            const now = Date.now();
            const GUARDIAN_FIREWALL_ATTEMPT_DURATION = 2000 / healSpeedMultiplier;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGalaxyBackground(now);
            gradientOffset = (gradientOffset + 0.005) % 1;
            
            // Performance: Pre-calculate common animation values once per frame
            const animValues = {
                pulse005: Math.sin(now * 0.005),
                pulse008: Math.sin(now * 0.008),
                pulse01: Math.sin(now * 0.01),
                pulse02: Math.sin(now * 0.02),
                pulse001: Math.sin(now * 0.001),
                nowMod10: (now * 0.02) % 10,
                nowMod9: (now * 0.00125) % 9
            };
            
            // Performance: Viewport culling helper (with generous margin for large nodes/effects)
            const viewportMargin = 100;
            const isInViewport = (x, y, radius = 0) => {
                return x + radius > -viewportMargin && 
                       x - radius < canvas.width + viewportMargin && 
                       y + radius > -viewportMargin && 
                       y - radius < canvas.height + viewportMargin;
            };
            
            // Performance: Cache commonly used color strings to avoid repeated string concatenation
            const cachedColors = {
                green015: `rgba(${colors.green.r}, ${colors.green.g}, ${colors.green.b}, 0.15)`,
                green03: `rgba(${colors.green.r}, ${colors.green.g}, ${colors.green.b}, 0.3)`,
                malware: `rgba(${colors.malware.r}, ${colors.malware.g}, ${colors.malware.b}, 1)`,
                line05: `rgba(${colors.line.r}, ${colors.line.g}, ${colors.line.b}, 0.5)`,
                red: `rgba(220, 38, 38, 1)`,
                neonGreen: `rgba(${colors.neonGreen.r}, ${colors.neonGreen.g}, ${colors.neonGreen.b}, 1)`,
                blue04: `rgba(${colors.blue.r}, ${colors.blue.g}, ${colors.blue.b}, 0.4)`
            }; 
            
            // MODIFIED: Build and use the Quadtree for physics calculations
            const overscan = Math.max(60, Math.min(canvas.width, canvas.height) * 0.05);
            let boundary = new Rectangle(canvas.width / 2, canvas.height / 2, canvas.width / 2 + overscan, canvas.height / 2 + overscan);
            let qtree = new Quadtree(boundary, 4);
            for (const node of nodes) {
                if (node.state === 'alive') {
                    qtree.insert(node);
                }
            }
            
            applyBoundaryRepulsion(qtree);
            applyRepulsion(qtree);
            applyEdgeRepulsion();
            applySpringForces();
            updateGuardianVpnTunnels();

            edges.forEach(edge => {
                const fromNode = edge.from, toNode = edge.to;
                if(!fromNode || !toNode) return;
                
                const edgeOpacity = Math.min(fromNode.opacity, toNode.opacity);
                if(edgeOpacity <=0) return;
                
                // Performance: Viewport culling for edges - skip if both endpoints are off-screen
                if (!isInViewport(fromNode.x, fromNode.y, 50) && !isInViewport(toNode.x, toNode.y, 50)) {
                    return;
                }
                
                ctx.lineWidth = 4;

                const forwardInfection = fromNode.spreadingInfections?.find(i => i.target === toNode);
                const backwardInfection = toNode.spreadingInfections?.find(i => i.target === fromNode);

                // Check if this edge is part of an active DDOS attack path
                let ddosAttackOnEdge = null;
                nodes.forEach(n => {
                    if (n.status === 'commandControl' && n.ddosState === 'active' && n.ddosAttackPaths) {
                        n.ddosAttackPaths.forEach(attackPath => {
                            const edgeInPath = attackPath.path.find(p => p.edge === edge);
                            if (edgeInPath) {
                                ddosAttackOnEdge = {
                                    attackPath: attackPath,
                                    edgeInPath: edgeInPath,
                                    startTime: attackPath.startTime
                                };
                            }
                        });
                    }
                });

                if (ddosAttackOnEdge) {
                    // DDOS attack on this edge: dark red base with bright red flowing animation
                    ctx.setLineDash([]);
                    const elapsed = now - ddosAttackOnEdge.startTime;
                    const DDOS_ADVANCE_SPEED = 4000; // 4 seconds to traverse the entire network
                    
                    // Calculate overall progress (0 to 1) across the entire path
                    const pathProgress = Math.min(1, elapsed / DDOS_ADVANCE_SPEED);
                    
                    // Determine this edge's position in the path
                    const pathLength = ddosAttackOnEdge.attackPath.path.length;
                    const edgeIndex = ddosAttackOnEdge.attackPath.path.indexOf(ddosAttackOnEdge.edgeInPath);
                    const edgeStartProgress = edgeIndex / pathLength;
                    const edgeEndProgress = (edgeIndex + 1) / pathLength;
                    
                    // Calculate this edge's local progress (0 to 1)
                    let localProgress = 0;
                    if (pathProgress >= edgeStartProgress && pathProgress <= edgeEndProgress) {
                        localProgress = (pathProgress - edgeStartProgress) / (edgeEndProgress - edgeStartProgress);
                    } else if (pathProgress > edgeEndProgress) {
                        localProgress = 1; // Attack has passed through
                    }
                    
                    // Create gradient based on direction
                    const direction = ddosAttackOnEdge.edgeInPath.direction;
                    const startNode = direction === 1 ? fromNode : toNode;
                    const endNode = direction === 1 ? toNode : fromNode;
                    
                    const gradient = ctx.createLinearGradient(startNode.x, startNode.y, endNode.x, endNode.y);
                    const darkRedColor = `rgba(139, 0, 0, ${edgeOpacity})`; // Dark red base
                    const brightRedColor = `rgba(255, 50, 50, ${edgeOpacity})`; // Bright red flow
                    
                    if (localProgress > 0) {
                        gradient.addColorStop(0, brightRedColor);
                        gradient.addColorStop(Math.min(1, localProgress), brightRedColor);
                        gradient.addColorStop(Math.min(1, localProgress + 0.01), darkRedColor);
                        gradient.addColorStop(1, darkRedColor);
                    } else {
                        gradient.addColorStop(0, darkRedColor);
                        gradient.addColorStop(1, darkRedColor);
                    }
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 5; // Thicker to emphasize attack
                } else if (edge.isWirelessLink) {
                    ctx.setLineDash([4, 6]);
                    const pulse = 0.45 + 0.35 * Math.sin((now * 0.005) + (edge.pulseSeed || 0));
                    ctx.lineDashOffset = -animValues.nowMod10;
                    ctx.strokeStyle = `rgba(255, 255, 255, ${pulse * edgeOpacity})`;
                } else if (forwardInfection || backwardInfection) {
                    ctx.setLineDash([]);
                    const infection = forwardInfection || backwardInfection;
                    const infector = forwardInfection ? fromNode : toNode;
                    const target = forwardInfection ? toNode : fromNode;
                    
                    const elapsed = now - infection.startTime;
                    let progress;

                    // Special animation for central node attack
                    if (target.parent === null) {
                        const ATTACK_ADVANCE_TIME = 1500;
                        const ATTACK_RETREAT_TIME = 1000;
                        
                        if (elapsed < ATTACK_ADVANCE_TIME) {
                            // Line moves towards center, but stops at 90% of the way
                            progress = (elapsed / ATTACK_ADVANCE_TIME) * 0.9;
                        } else {
                            // Line retracts as the defense pulse fires
                            const retreatElapsed = elapsed - ATTACK_ADVANCE_TIME;
                            progress = 0.9 * (1 - Math.min(1, retreatElapsed / ATTACK_RETREAT_TIME));
                        }
                        progress = Math.max(0, progress); // prevent negative progress

                    } else { // Normal downstream infection
                        progress = Math.min(1, elapsed / 4000);
                    }
                    
                    const gradient = ctx.createLinearGradient(infector.x, infector.y, target.x, target.y);
                    const malwareColor = `rgba(${colors.malware.r}, ${colors.malware.g}, ${colors.malware.b}, ${edgeOpacity})`;
                    const baseColor = `rgba(${colors.line.r}, ${colors.line.g}, ${colors.line.b}, ${0.5 * edgeOpacity})`;
                    
                    gradient.addColorStop(0, malwareColor);
                    gradient.addColorStop(progress, malwareColor);
                    gradient.addColorStop(Math.min(1, progress + 0.01), baseColor);
                    gradient.addColorStop(1, baseColor);

                    ctx.strokeStyle = gradient;

                } else if (edge.isGuardianVpnTunnel) {
                    ctx.setLineDash([6, 3]);
                    ctx.lineDashOffset = -animValues.nowMod9;

                    const attempt = edge.guardianFirewallAttempt;
                    const guardianColor = `rgba(${colors.neonGreen.r}, ${colors.neonGreen.g}, ${colors.neonGreen.b}, ${edgeOpacity})`;
                    const baseColor = `rgba(${colors.blue.r}, ${colors.blue.g}, ${colors.blue.b}, ${0.4 * edgeOpacity})`;
                    const highlightColor = `rgba(${colors.white.r}, ${colors.white.g}, ${colors.white.b}, ${0.6 * edgeOpacity})`;
                    const gradient = ctx.createLinearGradient(fromNode.x, fromNode.y, toNode.x, toNode.y);

                    if (attempt && !attempt.completed) {
                        const elapsed = now - attempt.startTime;
                        const progress = Math.min(1, elapsed / GUARDIAN_FIREWALL_ATTEMPT_DURATION);
                        const halfSpan = Math.min(0.5, progress * 0.5);
                        const innerStart = Math.max(0, 0.5 - halfSpan);
                        const innerEnd = Math.min(1, 0.5 + halfSpan);

                        gradient.addColorStop(0, guardianColor);
                        gradient.addColorStop(innerStart, guardianColor);
                        gradient.addColorStop(Math.min(1, innerStart + 0.02), baseColor);
                        gradient.addColorStop(Math.max(0, innerEnd - 0.02), baseColor);
                        gradient.addColorStop(innerEnd, guardianColor);
                        gradient.addColorStop(1, guardianColor);
                    } else {
                        const pulse = (now * 0.001) % 1;
                        const mirrored = (pulse + 0.5) % 1;
                        const width = 0.08;
                        const stops = [];

                        const pushStop = (pos, color) => {
                            while (pos < 0) pos += 1;
                            while (pos > 1) pos -= 1;
                            stops.push({ pos, color });
                        };

                        const addPulse = (center) => {
                            pushStop(center - width * 2, baseColor);
                            pushStop(center - width, highlightColor);
                            pushStop(center, guardianColor);
                            pushStop(center + width, highlightColor);
                            pushStop(center + width * 2, baseColor);
                        };

                        pushStop(0, baseColor);
                        pushStop(1, baseColor);
                        addPulse(pulse);
                        addPulse(mirrored);

                        stops.sort((a, b) => a.pos - b.pos);

                        let lastPos = -1;
                        stops.forEach(stop => {
                            const clampedPos = Math.max(0, Math.min(1, stop.pos));
                            if (clampedPos !== lastPos) {
                                gradient.addColorStop(clampedPos, stop.color);
                                lastPos = clampedPos;
                            }
                        });
                    }

                    ctx.strokeStyle = gradient;

                } else if ((toNode.status === 'red' || toNode.status === 'yellow' || toNode.status === 'malware' || toNode.status === 'botnet' || toNode.status === 'commandControl')) {
                    ctx.setLineDash([5, 5]);
                    let color;
                    if (toNode.status === 'malware') {
                        color = colors.malware;
                        // Scrolling effect for malware (purple) lines
                        ctx.lineDashOffset = -(Date.now() * 0.025) % 10;
                    } else if (toNode.status === 'botnet') {
                        color = colors.botnet;
                        // Scrolling effect for botnet (red) lines
                        ctx.lineDashOffset = -(Date.now() * 0.025) % 10;
                    } else if (toNode.status === 'commandControl') {
                        color = colors.commandControl;
                        // Scrolling effect for C&C (dark red) lines
                        ctx.lineDashOffset = -(Date.now() * 0.025) % 10;
                    } else {
                        color = colors.red;
                        ctx.lineDashOffset = 0; // No scroll for regular red/yellow lines
                    }
                    const pulse = 0.6 + animValues.pulse005 * 0.4; 
                    ctx.strokeStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${pulse * edgeOpacity})`;
                } else {
                    ctx.setLineDash([]);
                    
                    // Performance: Use simple color for normal edges at high node counts
                    // Only use gradient animation for small networks
                    if (nodes.length <= 150) {
                        const gradient = ctx.createLinearGradient(fromNode.x, fromNode.y, toNode.x, toNode.y);
                        const baseColor = `rgba(${colors.green.r}, ${colors.green.g}, ${colors.green.b}, ${0.15 * edgeOpacity})`;
                        const highlightColor = `rgba(${colors.green.r}, ${colors.green.g}, ${colors.green.b}, ${0.85 * edgeOpacity})`;
                        
                        const pulseWidth = 0.18;
                        const pulseSpacing = 0.35; // Distance between pulses
                        const numPulses = 4; // Number of pulses visible on the line
                        
                        // Build gradient with multiple pulses
                        let stops = [];
                        for (let i = 0; i < numPulses; i++) {
                            const pulseCenter = (gradientOffset + i * pulseSpacing) % 1;
                            stops.push({ pos: pulseCenter - pulseWidth, color: baseColor });
                            stops.push({ pos: pulseCenter, color: highlightColor });
                            stops.push({ pos: pulseCenter + pulseWidth, color: baseColor });
                        }
                        
                        // Sort stops and add them to gradient
                        stops.sort((a, b) => a.pos - b.pos);
                        
                        // Add initial base color
                        gradient.addColorStop(0, baseColor);
                        
                        stops.forEach(stop => {
                            const clampedPos = Math.max(0, Math.min(1, stop.pos));
                            if (clampedPos >= 0 && clampedPos <= 1) {
                                gradient.addColorStop(clampedPos, stop.color);
                            }
                        });
                        
                        // Add final base color
                        gradient.addColorStop(1, baseColor);

                        ctx.strokeStyle = gradient;
                    } else {
                        // Simple static color for performance
                        ctx.strokeStyle = `rgba(${colors.green.r}, ${colors.green.g}, ${colors.green.b}, ${0.3 * edgeOpacity})`;
                    }
                }

                ctx.beginPath();
                ctx.moveTo(fromNode.x, fromNode.y);
                ctx.lineTo(toNode.x, toNode.y);
                ctx.stroke();
                
                // Draw flashing X on central-to-target edge during DDOS
                if (ddosAttackOnEdge) {
                    // Check if this is the edge from central node to target branch
                    const isCentralToTarget = 
                        (fromNode.parent === null && toNode === ddosAttackOnEdge.attackPath.target) ||
                        (toNode.parent === null && fromNode === ddosAttackOnEdge.attackPath.target);
                    
                    if (isCentralToTarget) {
                        // Calculate midpoint of edge
                        const midX = (fromNode.x + toNode.x) / 2;
                        const midY = (fromNode.y + toNode.y) / 2;
                        
                        // Flashing effect (2 Hz = 500ms period)
                        const flashCycle = (now % 500) / 500; // 0 to 1
                        const flashAlpha = flashCycle < 0.5 ? 1 : 0.3; // On/off flash
                        
                        // Draw stop emoji symbol
                        ctx.save();
                        ctx.globalAlpha = flashAlpha * edgeOpacity;
                        ctx.font = 'bold 24px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('‚õî', midX, midY);
                        ctx.restore();
                    }
                }
            });
            ctx.setLineDash([]);
            ctx.lineDashOffset = 0;
            
            // Draw DDOS visual effects
            // Performance: Only iterate C&C nodes with active DDOS (charging or active)
            const activeDDOSNodes = nodes.filter(n => 
                n.status === 'commandControl' && 
                n.state === 'alive' && 
                (n.ddosState === 'charging' || n.ddosState === 'active')
            );
            
            activeDDOSNodes.forEach(ccNode => {
                
                // Charging phase: red lightning between C&C and botnets
                if (ccNode.ddosState === 'charging' && ccNode.ddosBotnets.length > 0) {
                    const chargeProgress = (now - ccNode.ddosChargeStart) / (6000 / attackFreqMultiplier);
                    
                    ccNode.ddosBotnets.forEach(botnet => {
                        if (botnet.state !== 'alive') return;
                        
                        // Lightning effect with increasing intensity
                        const pulseIntensity = 0.3 + (0.5 * chargeProgress);
                        const lightningPulse = animValues.pulse01 * 0.2 + 0.8;
                        const alpha = pulseIntensity * lightningPulse;
                        
                        ctx.strokeStyle = `rgba(220, 38, 38, ${alpha})`;
                        ctx.lineWidth = 2 + (chargeProgress * 2);
                        ctx.setLineDash([5, 5]);
                        
                        // Add zigzag to simulate lightning
                        ctx.beginPath();
                        const dx = botnet.x - ccNode.x;
                        const dy = botnet.y - ccNode.y;
                        const steps = 8;
                        for (let i = 0; i <= steps; i++) {
                            const t = i / steps;
                            const x = ccNode.x + dx * t + (Math.sin(now * 0.02 + i) * 5);
                            const y = ccNode.y + dy * t + (Math.cos(now * 0.02 + i) * 5);
                            if (i === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        ctx.stroke();
                    });
                    
                    ctx.setLineDash([]);
                }
                
                // Active phase: Draw warning on targeted branch node and affected edges
                if (ccNode.ddosState === 'active' && ccNode.ddosTargetBranch) {
                    const targetBranch = ccNode.ddosTargetBranch;
                    
                    // Pulsing red warning ring on target branch node
                    const warningPulse = animValues.pulse008 * 0.3 + 0.7;
                    ctx.strokeStyle = `rgba(139, 0, 0, ${warningPulse * 0.8})`;
                    ctx.lineWidth = 3;
                    const warningRadius = targetBranch.radius + 15 + (animValues.pulse005 * 5);
                    
                    ctx.beginPath();
                    ctx.arc(targetBranch.x, targetBranch.y, warningRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Static/interference particles around the branch
                    for (let i = 0; i < 8; i++) {
                        const angle = (now * 0.001 + i * Math.PI / 4) % (Math.PI * 2);
                        const distance = warningRadius + 10;
                        const px = targetBranch.x + Math.cos(angle) * distance;
                        const py = targetBranch.y + Math.sin(angle) * distance;
                        
                        ctx.fillStyle = `rgba(220, 38, 38, ${Math.random() * 0.6})`;
                        ctx.fillRect(px - 1, py - 1, 2, 2);
                    }
                    // Draw pulsing red glow on participating botnet nodes
                    if (ccNode.ddosBotnets && ccNode.ddosBotnets.length > 0) {
                        ccNode.ddosBotnets.forEach(botnet => {
                            if (botnet.state !== 'alive') return;
                            
                            const botnetPulse = animValues.pulse01 * 0.3 + 0.5;
                            ctx.strokeStyle = `rgba(220, 38, 38, ${botnetPulse * 0.6})`;
                            ctx.lineWidth = 2;
                            const glowRadius = botnet.radius + 8 + (animValues.pulse008 * 3);
                            
                            ctx.beginPath();
                            ctx.arc(botnet.x, botnet.y, glowRadius, 0, Math.PI * 2);
                            ctx.stroke();
                        });
                    }
                }
            });
            
            manageDataPackets();
            manageImmunityPackets();
            managePingOfDeath();
            managePhishPackets();
            manageDDOSAttacks();
            manageCounterStrikes();
            guardianThreatHunting();
            manageDispatchPackets();
            manageParticles();

            nodes.forEach(node => {
                node.update();
                
                // Don't draw drifting satellites - they're being cleaned up
                if (node.state === 'drifting' && node.isSatellite) {
                    return; // Skip drawing entirely
                }
                
                // Performance: Viewport culling - skip drawing off-screen nodes (except central node)
                if (node.parent === null || isInViewport(node.x, node.y, node.radius + 50)) {
                    node.draw();
                }
            });

            // Redraw the central node to ensure it's on top of all other elements
            const rootNode = nodes[0];
            if (rootNode) {
                rootNode.draw();
                
                // Draw immunity packets attached to central node on top of its glow
                immunityPackets.forEach(packet => {
                    const isAttachedToCentral = packet.isAttached && packet.attachedNode && packet.attachedNode.parent === null;
                    if (isAttachedToCentral && packet.active) {
                        packet.draw();
                    }
                });
            }
            
            const nodesToRemove = nodes.filter(node => node.opacity <= 0 && node.state !== 'spawning');
            if (nodesToRemove.length > 0) {
                if (nodesToRemove.some(n => n.parent === nodes[0])) {
                    nodes[0].pulseEffect = 1;
                }

                nodesToRemove.forEach(node => {
                    if (node.parent) {
                        node.parent.children = node.parent.children.filter(child => child.id !== node.id);
                    }
                });
                
                // Count packets on removed branches as received (natural decay)
                const removedNodeIds = new Set(nodesToRemove.map(n => n.id));
                dataPackets.forEach(packet => {
                    if (packet.active && packet.edge && 
                        (removedNodeIds.has(packet.edge.from?.id) || removedNodeIds.has(packet.edge.to?.id))) {
                        incrementStat('packetsReceived');
                    }
                });
                
                nodes = nodes.filter(node => !nodesToRemove.includes(node));
                const nodeIds = new Set(nodes.map(n => n.id));
                edges = edges.filter(edge => nodeIds.has(edge.from.id) && nodeIds.has(edge.to.id));
            }
            
            // Update stats display
            updateStatsDisplay();
            
            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', () => {
            resizeCanvas();
            initializeGalaxy();
            createGraph();
        });

        resizeCanvas();
        initializeGalaxy();
        createGraph();
        animate();
        initializeToolButtons();
        initializeStatsPaneToggle();
        initializeTabs();
        initializeSliders();
        
        // Simulation tick intervals (multipliers affect behavior within functions)
        setInterval(simulateNetworkEvents, 500);
        setInterval(updateNetworkTopology, 500);
    </script>
</body>
</html>

